/*! For license information please see LICENSES */
(window.webpackJsonp = window.webpackJsonp || []).push([
	[2], {
		212: function(t, e, n) {
			"use strict";
			n.d(e, "a", (function() {
				return m
			})), n.d(e, "b", (function() {
				return Gl
			})), n.d(e, "c", (function() {
				return Lc
			})), n.d(e, "d", (function() {
				return Hc
			})), n.d(e, "e", (function() {
				return Dc
			})), n.d(e, "f", (function() {
				return bc
			})), n.d(e, "g", (function() {
				return l
			})), n.d(e, "h", (function() {
				return vt
			})), n.d(e, "i", (function() {
				return za
			})), n.d(e, "j", (function() {
				return oe
			})), n.d(e, "k", (function() {
				return Mn
			})), n.d(e, "l", (function() {
				return On
			})), n.d(e, "m", (function() {
				return ai
			})), n.d(e, "n", (function() {
				return L
			})), n.d(e, "o", (function() {
				return Qt
			})), n.d(e, "p", (function() {
				return hi
			})), n.d(e, "q", (function() {
				return M
			})), n.d(e, "r", (function() {
				return S
			})), n.d(e, "s", (function() {
				return ui
			})), n.d(e, "t", (function() {
				return Kl
			})), n.d(e, "u", (function() {
				return vo
			})), n.d(e, "v", (function() {
				return ka
			})), n.d(e, "w", (function() {
				return pr
			})), n.d(e, "x", (function() {
				return K
			})), n.d(e, "y", (function() {
				return la
			})), n.d(e, "z", (function() {
				return pc
			})), n.d(e, "A", (function() {
				return c
			})), n.d(e, "B", (function() {
				return x
			})), n.d(e, "C", (function() {
				return St
			})), n.d(e, "D", (function() {
				return ql
			})), n.d(e, "E", (function() {
				return V
			})), n.d(e, "F", (function() {
				return o
			})), n.d(e, "G", (function() {
				return w
			})), n.d(e, "H", (function() {
				return _
			})), n.d(e, "I", (function() {
				return sa
			})), n.d(e, "J", (function() {
				return W
			})), n.d(e, "K", (function() {
				return _c
			})), n.d(e, "L", (function() {
				return ma
			})), n.d(e, "M", (function() {
				return va
			})), n.d(e, "N", (function() {
				return Dl
			})), n.d(e, "O", (function() {
				return st
			})), n.d(e, "P", (function() {
				return at
			})), n.d(e, "Q", (function() {
				return v
			})), n.d(e, "R", (function() {
				return y
			})), n.d(e, "S", (function() {
				return io
			})), n.d(e, "T", (function() {
				return Ka
			})), n.d(e, "U", (function() {
				return oo
			})), n.d(e, "V", (function() {
				return ao
			})), n.d(e, "W", (function() {
				return mt
			})), n.d(e, "X", (function() {
				return F
			})), n.d(e, "Y", (function() {
				return U
			})), n.d(e, "Z", (function() {
				return N
			})), n.d(e, "ab", (function() {
				return H
			})), n.d(e, "bb", (function() {
				return Yl
			})), n.d(e, "cb", (function() {
				return yc
			})), n.d(e, "db", (function() {
				return jl
			})), n.d(e, "eb", (function() {
				return Q
			})), n.d(e, "fb", (function() {
				return _n
			})), n.d(e, "gb", (function() {
				return Ht
			})), n.d(e, "hb", (function() {
				return Ut
			})), n.d(e, "ib", (function() {
				return Oe
			})), n.d(e, "jb", (function() {
				return $n
			})), n.d(e, "kb", (function() {
				return wn
			})), n.d(e, "lb", (function() {
				return Zs
			})), n.d(e, "mb", (function() {
				return El
			})), n.d(e, "nb", (function() {
				return Sl
			})), n.d(e, "ob", (function() {
				return Al
			})), n.d(e, "pb", (function() {
				return wl
			})), n.d(e, "qb", (function() {
				return P
			})), n.d(e, "rb", (function() {
				return I
			})), n.d(e, "sb", (function() {
				return O
			})), n.d(e, "tb", (function() {
				return B
			})), n.d(e, "ub", (function() {
				return f
			})), n.d(e, "vb", (function() {
				return h
			})), n.d(e, "wb", (function() {
				return A
			})), n.d(e, "xb", (function() {
				return Hl
			})), n.d(e, "yb", (function() {
				return on
			})), n.d(e, "zb", (function() {
				return Pi
			})), n.d(e, "Ab", (function() {
				return oi
			})), n.d(e, "Bb", (function() {
				return gi
			})), n.d(e, "Cb", (function() {
				return Ai
			})), n.d(e, "Db", (function() {
				return uc
			})), n.d(e, "Eb", (function() {
				return fo
			})), n.d(e, "Fb", (function() {
				return lo
			})), n.d(e, "Gb", (function() {
				return Fc
			})), n.d(e, "Hb", (function() {
				return qc
			})), n.d(e, "Ib", (function() {
				return ie
			})), n.d(e, "Jb", (function() {
				return Ul
			})), n.d(e, "Kb", (function() {
				return yt
			})), n.d(e, "Lb", (function() {
				return Y
			})), n.d(e, "Mb", (function() {
				return X
			})), n.d(e, "Nb", (function() {
				return $
			})), n.d(e, "Ob", (function() {
				return Z
			})), n.d(e, "Pb", (function() {
				return D
			})), n.d(e, "Qb", (function() {
				return fa
			})), n.d(e, "Rb", (function() {
				return si
			})), n.d(e, "Sb", (function() {
				return Wa
			})), n.d(e, "Tb", (function() {
				return Ua
			})), n.d(e, "Ub", (function() {
				return Te
			})), n.d(e, "Vb", (function() {
				return ac
			})), n.d(e, "Wb", (function() {
				return xt
			})), n.d(e, "Xb", (function() {
				return Zt
			})), n.d(e, "Yb", (function() {
				return Zl
			})), n.d(e, "Zb", (function() {
				return xl
			})), n.d(e, "ac", (function() {
				return ft
			})), n.d(e, "bc", (function() {
				return pt
			})), n.d(e, "cc", (function() {
				return Kc
			})), n.d(e, "dc", (function() {
				return ri
			})), n.d(e, "ec", (function() {
				return z
			})), n.d(e, "fc", (function() {
				return j
			})), n.d(e, "gc", (function() {
				return G
			})), n.d(e, "hc", (function() {
				return Nt
			})), n.d(e, "ic", (function() {
				return re
			})), n.d(e, "jc", (function() {
				return te
			})), n.d(e, "kc", (function() {
				return kl
			})), n.d(e, "lc", (function() {
				return di
			})), n.d(e, "mc", (function() {
				return ne
			})), n.d(e, "nc", (function() {
				return ee
			})), n.d(e, "oc", (function() {
				return ua
			})), n.d(e, "pc", (function() {
				return gt
			}));
			const r = "137",
				o = 0,
				l = 1,
				c = 2,
				h = 0,
				d = 100,
				f = 0,
				m = 1,
				v = 2,
				y = 3,
				x = 4,
				_ = 5,
				w = 6,
				A = 7,
				M = 301,
				S = 302,
				T = 303,
				E = 304,
				C = 306,
				R = 307,
				D = 1e3,
				L = 1001,
				P = 1002,
				I = 1003,
				B = 1004,
				O = 1005,
				F = 1006,
				H = 1007,
				N = 1008,
				U = 1008,
				z = 1009,
				k = 1012,
				G = 1014,
				V = 1015,
				W = 1016,
				j = 1020,
				X = 1022,
				Y = 1023,
				Q = 1024,
				J = 1026,
				K = 1027,
				Z = 1028,
				$ = 1030,
				tt = 33776,
				et = 33777,
				nt = 33778,
				it = 33779,
				st = 2300,
				at = 2301,
				ot = 2302,
				lt = 2400,
				ct = 2401,
				ht = 2402,
				ut = 2500,
				pt = 1,
				ft = 2,
				mt = 3e3,
				gt = 3001,
				vt = 3200,
				yt = 3201,
				xt = 0,
				_t = 7680,
				wt = 35044,
				At = 35048,
				bt = "300 es",
				Mt = 1035;
			class St {
				addEventListener(t, e) {
					void 0 === this._listeners && (this._listeners = {});
					const n = this._listeners;
					void 0 === n[t] && (n[t] = []), -1 === n[t].indexOf(e) && n[t].push(e)
				}
				hasEventListener(t, e) {
					if (void 0 === this._listeners) return !1;
					const n = this._listeners;
					return void 0 !== n[t] && -1 !== n[t].indexOf(e)
				}
				removeEventListener(t, e) {
					if (void 0 === this._listeners) return;
					const n = this._listeners[t];
					if (void 0 !== n) {
						const t = n.indexOf(e); - 1 !== t && n.splice(t, 1)
					}
				}
				dispatchEvent(t) {
					if (void 0 === this._listeners) return;
					const e = this._listeners[t.type];
					if (void 0 !== e) {
						t.target = this;
						const n = e.slice(0);
						for (let i = 0, e = n.length; i < e; i++) n[i].call(this, t);
						t.target = null
					}
				}
			}
			const Tt = [];
			for (let i = 0; i < 256; i++) Tt[i] = (i < 16 ? "0" : "") + i.toString(16);
			let Et = 1234567;
			const Ct = Math.PI / 180,
				Rt = 180 / Math.PI;

			function Dt() {
				const t = 4294967295 * Math.random() | 0,
					e = 4294967295 * Math.random() | 0,
					n = 4294967295 * Math.random() | 0,
					r = 4294967295 * Math.random() | 0;
				return (Tt[255 & t] + Tt[t >> 8 & 255] + Tt[t >> 16 & 255] + Tt[t >> 24 & 255] + "-" + Tt[255 & e] + Tt[e >> 8 & 255] + "-" + Tt[e >> 16 & 15 | 64] + Tt[e >> 24 & 255] + "-" + Tt[63 & n | 128] + Tt[n >> 8 & 255] + "-" + Tt[n >> 16 & 255] + Tt[n >> 24 & 255] + Tt[255 & r] + Tt[r >> 8 & 255] + Tt[r >> 16 & 255] + Tt[r >> 24 & 255]).toUpperCase()
			}

			function Lt(t, e, n) {
				return Math.max(e, Math.min(n, t))
			}

			function Pt(t, e) {
				return (t % e + e) % e
			}

			function It(t, e, n) {
				return (1 - n) * t + n * e
			}

			function Bt(t) {
				return 0 == (t & t - 1) && 0 !== t
			}

			function Ot(t) {
				return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
			}

			function Ft(t) {
				return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
			}
			var Ht = Object.freeze({
				__proto__: null,
				DEG2RAD: Ct,
				RAD2DEG: Rt,
				generateUUID: Dt,
				clamp: Lt,
				euclideanModulo: Pt,
				mapLinear: function(t, e, n, r, o) {
					return r + (t - e) * (o - r) / (n - e)
				},
				inverseLerp: function(t, e, n) {
					return t !== e ? (n - t) / (e - t) : 0
				},
				lerp: It,
				damp: function(t, e, n, dt) {
					return It(t, e, 1 - Math.exp(-n * dt))
				},
				pingpong: function(t, e = 1) {
					return e - Math.abs(Pt(t, 2 * e) - e)
				},
				smoothstep: function(t, e, n) {
					return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * (3 - 2 * t)
				},
				smootherstep: function(t, e, n) {
					return t <= e ? 0 : t >= n ? 1 : (t = (t - e) / (n - e)) * t * t * (t * (6 * t - 15) + 10)
				},
				randInt: function(t, e) {
					return t + Math.floor(Math.random() * (e - t + 1))
				},
				randFloat: function(t, e) {
					return t + Math.random() * (e - t)
				},
				randFloatSpread: function(t) {
					return t * (.5 - Math.random())
				},
				seededRandom: function(s) {
					return void 0 !== s && (Et = s % 2147483647), Et = 16807 * Et % 2147483647, (Et - 1) / 2147483646
				},
				degToRad: function(t) {
					return t * Ct
				},
				radToDeg: function(t) {
					return t * Rt
				},
				isPowerOfTwo: Bt,
				ceilPowerOfTwo: Ot,
				floorPowerOfTwo: Ft,
				setQuaternionFromProperEuler: function(q, a, b, t, e) {
					const n = Math.cos,
						r = Math.sin,
						o = n(b / 2),
						l = r(b / 2),
						c = n((a + t) / 2),
						h = r((a + t) / 2),
						d = n((a - t) / 2),
						f = r((a - t) / 2),
						m = n((t - a) / 2),
						v = r((t - a) / 2);
					switch (e) {
						case "XYX":
							q.set(o * h, l * d, l * f, o * c);
							break;
						case "YZY":
							q.set(l * f, o * h, l * d, o * c);
							break;
						case "ZXZ":
							q.set(l * d, l * f, o * h, o * c);
							break;
						case "XZX":
							q.set(o * h, l * v, l * m, o * c);
							break;
						case "YXY":
							q.set(l * m, o * h, l * v, o * c);
							break;
						case "ZYZ":
							q.set(l * v, l * m, o * h, o * c);
							break;
						default:
							console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + e)
					}
				}
			});
			class Nt {
				constructor(t = 0, e = 0) {
					this.x = t, this.y = e
				}
				get width() {
					return this.x
				}
				set width(t) {
					this.x = t
				}
				get height() {
					return this.y
				}
				set height(t) {
					this.y = t
				}
				set(t, e) {
					return this.x = t, this.y = e, this
				}
				setScalar(t) {
					return this.x = t, this.y = t, this
				}
				setX(t) {
					return this.x = t, this
				}
				setY(t) {
					return this.y = t, this
				}
				setComponent(t, e) {
					switch (t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						default:
							throw new Error("index is out of range: " + t)
					}
					return this
				}
				getComponent(t) {
					switch (t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						default:
							throw new Error("index is out of range: " + t)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y)
				}
				copy(t) {
					return this.x = t.x, this.y = t.y, this
				}
				add(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
				}
				addScalar(s) {
					return this.x += s, this.y += s, this
				}
				addVectors(a, b) {
					return this.x = a.x + b.x, this.y = a.y + b.y, this
				}
				addScaledVector(t, s) {
					return this.x += t.x * s, this.y += t.y * s, this
				}
				sub(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
				}
				subScalar(s) {
					return this.x -= s, this.y -= s, this
				}
				subVectors(a, b) {
					return this.x = a.x - b.x, this.y = a.y - b.y, this
				}
				multiply(t) {
					return this.x *= t.x, this.y *= t.y, this
				}
				multiplyScalar(t) {
					return this.x *= t, this.y *= t, this
				}
				divide(t) {
					return this.x /= t.x, this.y /= t.y, this
				}
				divideScalar(t) {
					return this.multiplyScalar(1 / t)
				}
				applyMatrix3(t) {
					const e = this.x,
						n = this.y,
						r = t.elements;
					return this.x = r[0] * e + r[3] * n + r[6], this.y = r[1] * e + r[4] * n + r[7], this
				}
				min(t) {
					return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
				}
				max(t) {
					return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
				}
				clamp(t, e) {
					return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
				}
				clampScalar(t, e) {
					return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this
				}
				clampLength(t, e) {
					const n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
				}
				floor() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
				}
				ceil() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
				}
				round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this
				}
				roundToZero() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this
				}
				negate() {
					return this.x = -this.x, this.y = -this.y, this
				}
				dot(t) {
					return this.x * t.x + this.y * t.y
				}
				cross(t) {
					return this.x * t.y - this.y * t.x
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				angle() {
					return Math.atan2(-this.y, -this.x) + Math.PI
				}
				distanceTo(t) {
					return Math.sqrt(this.distanceToSquared(t))
				}
				distanceToSquared(t) {
					const e = this.x - t.x,
						n = this.y - t.y;
					return e * e + n * n
				}
				manhattanDistanceTo(t) {
					return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
				}
				setLength(t) {
					return this.normalize().multiplyScalar(t)
				}
				lerp(t, e) {
					return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
				}
				lerpVectors(t, e, n) {
					return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this
				}
				equals(t) {
					return t.x === this.x && t.y === this.y
				}
				fromArray(t, e = 0) {
					return this.x = t[e], this.y = t[e + 1], this
				}
				toArray(t = [], e = 0) {
					return t[e] = this.x, t[e + 1] = this.y, t
				}
				fromBufferAttribute(t, e, n) {
					return void 0 !== n && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
				}
				rotateAround(t, e) {
					const n = Math.cos(e),
						s = Math.sin(e),
						r = this.x - t.x,
						o = this.y - t.y;
					return this.x = r * n - o * s + t.x, this.y = r * s + o * n + t.y, this
				}
				random() {
					return this.x = Math.random(), this.y = Math.random(), this
				}*[Symbol.iterator]() {
					yield this.x, yield this.y
				}
			}
			Nt.prototype.isVector2 = !0;
			class Ut {
				constructor() {
					this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
				}
				set(t, e, n, r, o, l, c, h, d) {
					const f = this.elements;
					return f[0] = t, f[1] = r, f[2] = c, f[3] = e, f[4] = o, f[5] = h, f[6] = n, f[7] = l, f[8] = d, this
				}
				identity() {
					return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
				}
				copy(t) {
					const e = this.elements,
						n = t.elements;
					return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], this
				}
				extractBasis(t, e, n) {
					return t.setFromMatrix3Column(this, 0), e.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
				}
				setFromMatrix4(t) {
					const e = t.elements;
					return this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]), this
				}
				multiply(t) {
					return this.multiplyMatrices(this, t)
				}
				premultiply(t) {
					return this.multiplyMatrices(t, this)
				}
				multiplyMatrices(a, b) {
					const t = a.elements,
						e = b.elements,
						n = this.elements,
						r = t[0],
						o = t[3],
						l = t[6],
						c = t[1],
						h = t[4],
						d = t[7],
						f = t[2],
						m = t[5],
						v = t[8],
						y = e[0],
						x = e[3],
						_ = e[6],
						w = e[1],
						A = e[4],
						M = e[7],
						S = e[2],
						T = e[5],
						E = e[8];
					return n[0] = r * y + o * w + l * S, n[3] = r * x + o * A + l * T, n[6] = r * _ + o * M + l * E, n[1] = c * y + h * w + d * S, n[4] = c * x + h * A + d * T, n[7] = c * _ + h * M + d * E, n[2] = f * y + m * w + v * S, n[5] = f * x + m * A + v * T, n[8] = f * _ + m * M + v * E, this
				}
				multiplyScalar(s) {
					const t = this.elements;
					return t[0] *= s, t[3] *= s, t[6] *= s, t[1] *= s, t[4] *= s, t[7] *= s, t[2] *= s, t[5] *= s, t[8] *= s, this
				}
				determinant() {
					const t = this.elements,
						a = t[0],
						b = t[1],
						e = t[2],
						n = t[3],
						r = t[4],
						o = t[5],
						g = t[6],
						l = t[7],
						i = t[8];
					return a * r * i - a * o * l - b * n * i + b * o * g + e * n * l - e * r * g
				}
				invert() {
					const t = this.elements,
						e = t[0],
						n = t[1],
						r = t[2],
						o = t[3],
						l = t[4],
						c = t[5],
						h = t[6],
						d = t[7],
						f = t[8],
						m = f * l - c * d,
						v = c * h - f * o,
						y = d * o - l * h,
						x = e * m + n * v + r * y;
					if (0 === x) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
					const _ = 1 / x;
					return t[0] = m * _, t[1] = (r * d - f * n) * _, t[2] = (c * n - r * l) * _, t[3] = v * _, t[4] = (f * e - r * h) * _, t[5] = (r * o - c * e) * _, t[6] = y * _, t[7] = (n * h - d * e) * _, t[8] = (l * e - n * o) * _, this
				}
				transpose() {
					let t;
					const e = this.elements;
					return t = e[1], e[1] = e[3], e[3] = t, t = e[2], e[2] = e[6], e[6] = t, t = e[5], e[5] = e[7], e[7] = t, this
				}
				getNormalMatrix(t) {
					return this.setFromMatrix4(t).invert().transpose()
				}
				transposeIntoArray(t) {
					const e = this.elements;
					return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
				}
				setUvTransform(t, e, n, r, o, l, c) {
					const h = Math.cos(o),
						s = Math.sin(o);
					return this.set(n * h, n * s, -n * (h * l + s * c) + l + t, -r * s, r * h, -r * (-s * l + h * c) + c + e, 0, 0, 1), this
				}
				scale(t, e) {
					const n = this.elements;
					return n[0] *= t, n[3] *= t, n[6] *= t, n[1] *= e, n[4] *= e, n[7] *= e, this
				}
				rotate(t) {
					const e = Math.cos(t),
						s = Math.sin(t),
						n = this.elements,
						r = n[0],
						o = n[3],
						l = n[6],
						c = n[1],
						h = n[4],
						d = n[7];
					return n[0] = e * r + s * c, n[3] = e * o + s * h, n[6] = e * l + s * d, n[1] = -s * r + e * c, n[4] = -s * o + e * h, n[7] = -s * l + e * d, this
				}
				translate(t, e) {
					const n = this.elements;
					return n[0] += t * n[2], n[3] += t * n[5], n[6] += t * n[8], n[1] += e * n[2], n[4] += e * n[5], n[7] += e * n[8], this
				}
				equals(t) {
					const e = this.elements,
						n = t.elements;
					for (let i = 0; i < 9; i++)
						if (e[i] !== n[i]) return !1;
					return !0
				}
				fromArray(t, e = 0) {
					for (let i = 0; i < 9; i++) this.elements[i] = t[i + e];
					return this
				}
				toArray(t = [], e = 0) {
					const n = this.elements;
					return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t
				}
				clone() {
					return (new this.constructor).fromArray(this.elements)
				}
			}

			function zt(t) {
				for (let i = t.length - 1; i >= 0; --i)
					if (t[i] > 65535) return !0;
				return !1
			}
			Ut.prototype.isMatrix3 = !0;
			Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array;

			function kt(t) {
				return document.createElementNS("http://www.w3.org/1999/xhtml", t)
			}
			const Gt = {
					aliceblue: 15792383,
					antiquewhite: 16444375,
					aqua: 65535,
					aquamarine: 8388564,
					azure: 15794175,
					beige: 16119260,
					bisque: 16770244,
					black: 0,
					blanchedalmond: 16772045,
					blue: 255,
					blueviolet: 9055202,
					brown: 10824234,
					burlywood: 14596231,
					cadetblue: 6266528,
					chartreuse: 8388352,
					chocolate: 13789470,
					coral: 16744272,
					cornflowerblue: 6591981,
					cornsilk: 16775388,
					crimson: 14423100,
					cyan: 65535,
					darkblue: 139,
					darkcyan: 35723,
					darkgoldenrod: 12092939,
					darkgray: 11119017,
					darkgreen: 25600,
					darkgrey: 11119017,
					darkkhaki: 12433259,
					darkmagenta: 9109643,
					darkolivegreen: 5597999,
					darkorange: 16747520,
					darkorchid: 10040012,
					darkred: 9109504,
					darksalmon: 15308410,
					darkseagreen: 9419919,
					darkslateblue: 4734347,
					darkslategray: 3100495,
					darkslategrey: 3100495,
					darkturquoise: 52945,
					darkviolet: 9699539,
					deeppink: 16716947,
					deepskyblue: 49151,
					dimgray: 6908265,
					dimgrey: 6908265,
					dodgerblue: 2003199,
					firebrick: 11674146,
					floralwhite: 16775920,
					forestgreen: 2263842,
					fuchsia: 16711935,
					gainsboro: 14474460,
					ghostwhite: 16316671,
					gold: 16766720,
					goldenrod: 14329120,
					gray: 8421504,
					green: 32768,
					greenyellow: 11403055,
					grey: 8421504,
					honeydew: 15794160,
					hotpink: 16738740,
					indianred: 13458524,
					indigo: 4915330,
					ivory: 16777200,
					khaki: 15787660,
					lavender: 15132410,
					lavenderblush: 16773365,
					lawngreen: 8190976,
					lemonchiffon: 16775885,
					lightblue: 11393254,
					lightcoral: 15761536,
					lightcyan: 14745599,
					lightgoldenrodyellow: 16448210,
					lightgray: 13882323,
					lightgreen: 9498256,
					lightgrey: 13882323,
					lightpink: 16758465,
					lightsalmon: 16752762,
					lightseagreen: 2142890,
					lightskyblue: 8900346,
					lightslategray: 7833753,
					lightslategrey: 7833753,
					lightsteelblue: 11584734,
					lightyellow: 16777184,
					lime: 65280,
					limegreen: 3329330,
					linen: 16445670,
					magenta: 16711935,
					maroon: 8388608,
					mediumaquamarine: 6737322,
					mediumblue: 205,
					mediumorchid: 12211667,
					mediumpurple: 9662683,
					mediumseagreen: 3978097,
					mediumslateblue: 8087790,
					mediumspringgreen: 64154,
					mediumturquoise: 4772300,
					mediumvioletred: 13047173,
					midnightblue: 1644912,
					mintcream: 16121850,
					mistyrose: 16770273,
					moccasin: 16770229,
					navajowhite: 16768685,
					navy: 128,
					oldlace: 16643558,
					olive: 8421376,
					olivedrab: 7048739,
					orange: 16753920,
					orangered: 16729344,
					orchid: 14315734,
					palegoldenrod: 15657130,
					palegreen: 10025880,
					paleturquoise: 11529966,
					palevioletred: 14381203,
					papayawhip: 16773077,
					peachpuff: 16767673,
					peru: 13468991,
					pink: 16761035,
					plum: 14524637,
					powderblue: 11591910,
					purple: 8388736,
					rebeccapurple: 6697881,
					red: 16711680,
					rosybrown: 12357519,
					royalblue: 4286945,
					saddlebrown: 9127187,
					salmon: 16416882,
					sandybrown: 16032864,
					seagreen: 3050327,
					seashell: 16774638,
					sienna: 10506797,
					silver: 12632256,
					skyblue: 8900331,
					slateblue: 6970061,
					slategray: 7372944,
					slategrey: 7372944,
					snow: 16775930,
					springgreen: 65407,
					steelblue: 4620980,
					tan: 13808780,
					teal: 32896,
					thistle: 14204888,
					tomato: 16737095,
					turquoise: 4251856,
					violet: 15631086,
					wheat: 16113331,
					white: 16777215,
					whitesmoke: 16119285,
					yellow: 16776960,
					yellowgreen: 10145074
				},
				Vt = {
					h: 0,
					s: 0,
					l: 0
				},
				Wt = {
					h: 0,
					s: 0,
					l: 0
				};

			function jt(p, q, t) {
				return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + 6 * (q - p) * (2 / 3 - t) : p
			}

			function Xt(t) {
				return t < .04045 ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
			}

			function Yt(t) {
				return t < .0031308 ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
			}
			class Qt {
				constructor(t, g, b) {
					return void 0 === g && void 0 === b ? this.set(t) : this.setRGB(t, g, b)
				}
				set(t) {
					return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
				}
				setScalar(t) {
					return this.r = t, this.g = t, this.b = t, this
				}
				setHex(t) {
					return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
				}
				setRGB(t, g, b) {
					return this.r = t, this.g = g, this.b = b, this
				}
				setHSL(t, s, e) {
					if (t = Pt(t, 1), s = Lt(s, 0, 1), e = Lt(e, 0, 1), 0 === s) this.r = this.g = this.b = e;
					else {
						const p = e <= .5 ? e * (1 + s) : e + s - e * s,
							q = 2 * e - p;
						this.r = jt(q, p, t + 1 / 3), this.g = jt(q, p, t), this.b = jt(q, p, t - 1 / 3)
					}
					return this
				}
				setStyle(style) {
					function t(t) {
						void 0 !== t && parseFloat(t) < 1 && console.warn("THREE.Color: Alpha component of " + style + " will be ignored.")
					}
					let e;
					if (e = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)) {
						let n;
						const r = e[1],
							o = e[2];
						switch (r) {
							case "rgb":
							case "rgba":
								if (n = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255, this.g = Math.min(255, parseInt(n[2], 10)) / 255, this.b = Math.min(255, parseInt(n[3], 10)) / 255, t(n[4]), this;
								if (n = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100, this.g = Math.min(100, parseInt(n[2], 10)) / 100, this.b = Math.min(100, parseInt(n[3], 10)) / 100, t(n[4]), this;
								break;
							case "hsl":
							case "hsla":
								if (n = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)) {
									const e = parseFloat(n[1]) / 360,
										s = parseInt(n[2], 10) / 100,
										r = parseInt(n[3], 10) / 100;
									return t(n[4]), this.setHSL(e, s, r)
								}
						}
					} else if (e = /^\#([A-Fa-f\d]+)$/.exec(style)) {
						const t = e[1],
							n = t.length;
						if (3 === n) return this.r = parseInt(t.charAt(0) + t.charAt(0), 16) / 255, this.g = parseInt(t.charAt(1) + t.charAt(1), 16) / 255, this.b = parseInt(t.charAt(2) + t.charAt(2), 16) / 255, this;
						if (6 === n) return this.r = parseInt(t.charAt(0) + t.charAt(1), 16) / 255, this.g = parseInt(t.charAt(2) + t.charAt(3), 16) / 255, this.b = parseInt(t.charAt(4) + t.charAt(5), 16) / 255, this
					}
					return style && style.length > 0 ? this.setColorName(style) : this
				}
				setColorName(style) {
					const t = Gt[style.toLowerCase()];
					return void 0 !== t ? this.setHex(t) : console.warn("THREE.Color: Unknown color " + style), this
				}
				clone() {
					return new this.constructor(this.r, this.g, this.b)
				}
				copy(t) {
					return this.r = t.r, this.g = t.g, this.b = t.b, this
				}
				copySRGBToLinear(t) {
					return this.r = Xt(t.r), this.g = Xt(t.g), this.b = Xt(t.b), this
				}
				copyLinearToSRGB(t) {
					return this.r = Yt(t.r), this.g = Yt(t.g), this.b = Yt(t.b), this
				}
				convertSRGBToLinear() {
					return this.copySRGBToLinear(this), this
				}
				convertLinearToSRGB() {
					return this.copyLinearToSRGB(this), this
				}
				getHex() {
					return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
				}
				getHexString() {
					return ("000000" + this.getHex().toString(16)).slice(-6)
				}
				getHSL(t) {
					const e = this.r,
						g = this.g,
						b = this.b,
						n = Math.max(e, g, b),
						r = Math.min(e, g, b);
					let o, l;
					const c = (r + n) / 2;
					if (r === n) o = 0, l = 0;
					else {
						const t = n - r;
						switch (l = c <= .5 ? t / (n + r) : t / (2 - n - r), n) {
							case e:
								o = (g - b) / t + (g < b ? 6 : 0);
								break;
							case g:
								o = (b - e) / t + 2;
								break;
							case b:
								o = (e - g) / t + 4
						}
						o /= 6
					}
					return t.h = o, t.s = l, t.l = c, t
				}
				getStyle() {
					return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
				}
				offsetHSL(t, s, e) {
					return this.getHSL(Vt), Vt.h += t, Vt.s += s, Vt.l += e, this.setHSL(Vt.h, Vt.s, Vt.l), this
				}
				add(t) {
					return this.r += t.r, this.g += t.g, this.b += t.b, this
				}
				addColors(t, e) {
					return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
				}
				addScalar(s) {
					return this.r += s, this.g += s, this.b += s, this
				}
				sub(t) {
					return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
				}
				multiply(t) {
					return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
				}
				multiplyScalar(s) {
					return this.r *= s, this.g *= s, this.b *= s, this
				}
				lerp(t, e) {
					return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
				}
				lerpColors(t, e, n) {
					return this.r = t.r + (e.r - t.r) * n, this.g = t.g + (e.g - t.g) * n, this.b = t.b + (e.b - t.b) * n, this
				}
				lerpHSL(t, e) {
					this.getHSL(Vt), t.getHSL(Wt);
					const n = It(Vt.h, Wt.h, e),
						s = It(Vt.s, Wt.s, e),
						r = It(Vt.l, Wt.l, e);
					return this.setHSL(n, s, r), this
				}
				equals(t) {
					return t.r === this.r && t.g === this.g && t.b === this.b
				}
				fromArray(t, e = 0) {
					return this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
				}
				toArray(t = [], e = 0) {
					return t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
				}
				fromBufferAttribute(t, e) {
					return this.r = t.getX(e), this.g = t.getY(e), this.b = t.getZ(e), !0 === t.normalized && (this.r /= 255, this.g /= 255, this.b /= 255), this
				}
				toJSON() {
					return this.getHex()
				}
			}
			let qt;
			Qt.NAMES = Gt, Qt.prototype.isColor = !0, Qt.prototype.r = 1, Qt.prototype.g = 1, Qt.prototype.b = 1;
			class Jt {
				static getDataURL(image) {
					if (/^data:/i.test(image.src)) return image.src;
					if ("undefined" == typeof HTMLCanvasElement) return image.src;
					let canvas;
					if (image instanceof HTMLCanvasElement) canvas = image;
					else {
						void 0 === qt && (qt = kt("canvas")), qt.width = image.width, qt.height = image.height;
						const t = qt.getContext("2d");
						image instanceof ImageData ? t.putImageData(image, 0, 0) : t.drawImage(image, 0, 0, image.width, image.height), canvas = qt
					}
					return canvas.width > 2048 || canvas.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", image), canvas.toDataURL("image/jpeg", .6)) : canvas.toDataURL("image/png")
				}
				static sRGBToLinear(image) {
					if ("undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap) {
						const canvas = kt("canvas");
						canvas.width = image.width, canvas.height = image.height;
						const t = canvas.getContext("2d");
						t.drawImage(image, 0, 0, image.width, image.height);
						const e = t.getImageData(0, 0, image.width, image.height),
							data = e.data;
						for (let i = 0; i < data.length; i++) data[i] = 255 * Xt(data[i] / 255);
						return t.putImageData(e, 0, 0), canvas
					}
					if (image.data) {
						const data = image.data.slice(0);
						for (let i = 0; i < data.length; i++) data instanceof Uint8Array || data instanceof Uint8ClampedArray ? data[i] = Math.floor(255 * Xt(data[i] / 255)) : data[i] = Xt(data[i]);
						return {
							data: data,
							width: image.width,
							height: image.height
						}
					}
					return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), image
				}
			}
			let Kt = 0;
			class Zt extends St {
				constructor(image = Zt.DEFAULT_IMAGE, t = Zt.DEFAULT_MAPPING, e = L, n = L, r = F, o = N, l = Y, c = z, h = 1, d = mt) {
					super(), Object.defineProperty(this, "id", {
						value: Kt++
					}), this.uuid = Dt(), this.name = "", this.image = image, this.mipmaps = [], this.mapping = t, this.wrapS = e, this.wrapT = n, this.magFilter = r, this.minFilter = o, this.anisotropy = h, this.format = l, this.internalFormat = null, this.type = c, this.offset = new Nt(0, 0), this.repeat = new Nt(1, 1), this.center = new Nt(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new Ut, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = d, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.needsPMREMUpdate = !1
				}
				updateMatrix() {
					this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(source) {
					return this.name = source.name, this.image = source.image, this.mipmaps = source.mipmaps.slice(0), this.mapping = source.mapping, this.wrapS = source.wrapS, this.wrapT = source.wrapT, this.magFilter = source.magFilter, this.minFilter = source.minFilter, this.anisotropy = source.anisotropy, this.format = source.format, this.internalFormat = source.internalFormat, this.type = source.type, this.offset.copy(source.offset), this.repeat.copy(source.repeat), this.center.copy(source.center), this.rotation = source.rotation, this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrix.copy(source.matrix), this.generateMipmaps = source.generateMipmaps, this.premultiplyAlpha = source.premultiplyAlpha, this.flipY = source.flipY, this.unpackAlignment = source.unpackAlignment, this.encoding = source.encoding, this.userData = JSON.parse(JSON.stringify(source.userData)), this
				}
				toJSON(meta) {
					const t = void 0 === meta || "string" == typeof meta;
					if (!t && void 0 !== meta.textures[this.uuid]) return meta.textures[this.uuid];
					const output = {
						metadata: {
							version: 4.5,
							type: "Texture",
							generator: "Texture.toJSON"
						},
						uuid: this.uuid,
						name: this.name,
						mapping: this.mapping,
						repeat: [this.repeat.x, this.repeat.y],
						offset: [this.offset.x, this.offset.y],
						center: [this.center.x, this.center.y],
						rotation: this.rotation,
						wrap: [this.wrapS, this.wrapT],
						format: this.format,
						type: this.type,
						encoding: this.encoding,
						minFilter: this.minFilter,
						magFilter: this.magFilter,
						anisotropy: this.anisotropy,
						flipY: this.flipY,
						premultiplyAlpha: this.premultiplyAlpha,
						unpackAlignment: this.unpackAlignment
					};
					if (void 0 !== this.image) {
						const image = this.image;
						if (void 0 === image.uuid && (image.uuid = Dt()), !t && void 0 === meta.images[image.uuid]) {
							let t;
							if (Array.isArray(image)) {
								t = [];
								for (let i = 0, e = image.length; i < e; i++) image[i].isDataTexture ? t.push($t(image[i].image)) : t.push($t(image[i]))
							} else t = $t(image);
							meta.images[image.uuid] = {
								uuid: image.uuid,
								url: t
							}
						}
						output.image = image.uuid
					}
					return "{}" !== JSON.stringify(this.userData) && (output.userData = this.userData), t || (meta.textures[this.uuid] = output), output
				}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
				transformUv(t) {
					if (300 !== this.mapping) return t;
					if (t.applyMatrix3(this.matrix), t.x < 0 || t.x > 1) switch (this.wrapS) {
						case D:
							t.x = t.x - Math.floor(t.x);
							break;
						case L:
							t.x = t.x < 0 ? 0 : 1;
							break;
						case P:
							1 === Math.abs(Math.floor(t.x) % 2) ? t.x = Math.ceil(t.x) - t.x : t.x = t.x - Math.floor(t.x)
					}
					if (t.y < 0 || t.y > 1) switch (this.wrapT) {
						case D:
							t.y = t.y - Math.floor(t.y);
							break;
						case L:
							t.y = t.y < 0 ? 0 : 1;
							break;
						case P:
							1 === Math.abs(Math.floor(t.y) % 2) ? t.y = Math.ceil(t.y) - t.y : t.y = t.y - Math.floor(t.y)
					}
					return this.flipY && (t.y = 1 - t.y), t
				}
				set needsUpdate(t) {
					!0 === t && this.version++
				}
			}

			function $t(image) {
				return "undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap ? Jt.getDataURL(image) : image.data ? {
					data: Array.prototype.slice.call(image.data),
					width: image.width,
					height: image.height,
					type: image.data.constructor.name
				} : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
			}
			Zt.DEFAULT_IMAGE = void 0, Zt.DEFAULT_MAPPING = 300, Zt.prototype.isTexture = !0;
			class te {
				constructor(t = 0, e = 0, n = 0, r = 1) {
					this.x = t, this.y = e, this.z = n, this.w = r
				}
				get width() {
					return this.z
				}
				set width(t) {
					this.z = t
				}
				get height() {
					return this.w
				}
				set height(t) {
					this.w = t
				}
				set(t, e, n, r) {
					return this.x = t, this.y = e, this.z = n, this.w = r, this
				}
				setScalar(t) {
					return this.x = t, this.y = t, this.z = t, this.w = t, this
				}
				setX(t) {
					return this.x = t, this
				}
				setY(t) {
					return this.y = t, this
				}
				setZ(t) {
					return this.z = t, this
				}
				setW(t) {
					return this.w = t, this
				}
				setComponent(t, e) {
					switch (t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						case 2:
							this.z = e;
							break;
						case 3:
							this.w = e;
							break;
						default:
							throw new Error("index is out of range: " + t)
					}
					return this
				}
				getComponent(t) {
					switch (t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						case 3:
							return this.w;
						default:
							throw new Error("index is out of range: " + t)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y, this.z, this.w)
				}
				copy(t) {
					return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
				}
				add(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
				}
				addScalar(s) {
					return this.x += s, this.y += s, this.z += s, this.w += s, this
				}
				addVectors(a, b) {
					return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this.w = a.w + b.w, this
				}
				addScaledVector(t, s) {
					return this.x += t.x * s, this.y += t.y * s, this.z += t.z * s, this.w += t.w * s, this
				}
				sub(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
				}
				subScalar(s) {
					return this.x -= s, this.y -= s, this.z -= s, this.w -= s, this
				}
				subVectors(a, b) {
					return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this.w = a.w - b.w, this
				}
				multiply(t) {
					return this.x *= t.x, this.y *= t.y, this.z *= t.z, this.w *= t.w, this
				}
				multiplyScalar(t) {
					return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
				}
				applyMatrix4(t) {
					const e = this.x,
						n = this.y,
						r = this.z,
						o = this.w,
						l = t.elements;
					return this.x = l[0] * e + l[4] * n + l[8] * r + l[12] * o, this.y = l[1] * e + l[5] * n + l[9] * r + l[13] * o, this.z = l[2] * e + l[6] * n + l[10] * r + l[14] * o, this.w = l[3] * e + l[7] * n + l[11] * r + l[15] * o, this
				}
				divideScalar(t) {
					return this.multiplyScalar(1 / t)
				}
				setAxisAngleFromQuaternion(q) {
					this.w = 2 * Math.acos(q.w);
					const s = Math.sqrt(1 - q.w * q.w);
					return s < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = q.x / s, this.y = q.y / s, this.z = q.z / s), this
				}
				setAxisAngleFromRotationMatrix(t) {
					let e, n, r, o;
					const l = .01,
						c = .1,
						h = t.elements,
						d = h[0],
						f = h[4],
						m = h[8],
						v = h[1],
						y = h[5],
						x = h[9],
						_ = h[2],
						w = h[6],
						A = h[10];
					if (Math.abs(f - v) < l && Math.abs(m - _) < l && Math.abs(x - w) < l) {
						if (Math.abs(f + v) < c && Math.abs(m + _) < c && Math.abs(x + w) < c && Math.abs(d + y + A - 3) < c) return this.set(1, 0, 0, 0), this;
						e = Math.PI;
						const t = (d + 1) / 2,
							h = (y + 1) / 2,
							M = (A + 1) / 2,
							S = (f + v) / 4,
							T = (m + _) / 4,
							E = (x + w) / 4;
						return t > h && t > M ? t < l ? (n = 0, r = .707106781, o = .707106781) : (n = Math.sqrt(t), r = S / n, o = T / n) : h > M ? h < l ? (n = .707106781, r = 0, o = .707106781) : (r = Math.sqrt(h), n = S / r, o = E / r) : M < l ? (n = .707106781, r = .707106781, o = 0) : (o = Math.sqrt(M), n = T / o, r = E / o), this.set(n, r, o, e), this
					}
					let s = Math.sqrt((w - x) * (w - x) + (m - _) * (m - _) + (v - f) * (v - f));
					return Math.abs(s) < .001 && (s = 1), this.x = (w - x) / s, this.y = (m - _) / s, this.z = (v - f) / s, this.w = Math.acos((d + y + A - 1) / 2), this
				}
				min(t) {
					return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
				}
				max(t) {
					return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
				}
				clamp(t, e) {
					return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
				}
				clampScalar(t, e) {
					return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this.w = Math.max(t, Math.min(e, this.w)), this
				}
				clampLength(t, e) {
					const n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
				}
				floor() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
				}
				ceil() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
				}
				round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
				}
				roundToZero() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w), this
				}
				negate() {
					return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
				}
				dot(t) {
					return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				setLength(t) {
					return this.normalize().multiplyScalar(t)
				}
				lerp(t, e) {
					return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
				}
				lerpVectors(t, e, n) {
					return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this.w = t.w + (e.w - t.w) * n, this
				}
				equals(t) {
					return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
				}
				fromArray(t, e = 0) {
					return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
				}
				toArray(t = [], e = 0) {
					return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
				}
				fromBufferAttribute(t, e, n) {
					return void 0 !== n && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
				}
				random() {
					return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
				}*[Symbol.iterator]() {
					yield this.x, yield this.y, yield this.z, yield this.w
				}
			}
			te.prototype.isVector4 = !0;
			class ee extends St {
				constructor(t, e, n = {}) {
					super(), this.width = t, this.height = e, this.depth = 1, this.scissor = new te(0, 0, t, e), this.scissorTest = !1, this.viewport = new te(0, 0, t, e), this.texture = new Zt(void 0, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.encoding), this.texture.isRenderTargetTexture = !0, this.texture.image = {
						width: t,
						height: e,
						depth: 1
					}, this.texture.generateMipmaps = void 0 !== n.generateMipmaps && n.generateMipmaps, this.texture.internalFormat = void 0 !== n.internalFormat ? n.internalFormat : null, this.texture.minFilter = void 0 !== n.minFilter ? n.minFilter : F, this.depthBuffer = void 0 === n.depthBuffer || n.depthBuffer, this.stencilBuffer = void 0 !== n.stencilBuffer && n.stencilBuffer, this.depthTexture = void 0 !== n.depthTexture ? n.depthTexture : null
				}
				setTexture(t) {
					t.image = {
						width: this.width,
						height: this.height,
						depth: this.depth
					}, this.texture = t
				}
				setSize(t, e, n = 1) {
					this.width === t && this.height === e && this.depth === n || (this.width = t, this.height = e, this.depth = n, this.texture.image.width = t, this.texture.image.height = e, this.texture.image.depth = n, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(source) {
					return this.width = source.width, this.height = source.height, this.depth = source.depth, this.viewport.copy(source.viewport), this.texture = source.texture.clone(), this.texture.image = Object.assign({}, source.texture.image), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, this.depthTexture = source.depthTexture, this
				}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}
			ee.prototype.isWebGLRenderTarget = !0;
			(class extends ee {
				constructor(t, e, n) {
					super(t, e);
					const r = this.texture;
					this.texture = [];
					for (let i = 0; i < n; i++) this.texture[i] = r.clone()
				}
				setSize(t, e, n = 1) {
					if (this.width !== t || this.height !== e || this.depth !== n) {
						this.width = t, this.height = e, this.depth = n;
						for (let i = 0, r = this.texture.length; i < r; i++) this.texture[i].image.width = t, this.texture[i].image.height = e, this.texture[i].image.depth = n;
						this.dispose()
					}
					return this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e), this
				}
				copy(source) {
					this.dispose(), this.width = source.width, this.height = source.height, this.depth = source.depth, this.viewport.set(0, 0, this.width, this.height), this.scissor.set(0, 0, this.width, this.height), this.depthBuffer = source.depthBuffer, this.stencilBuffer = source.stencilBuffer, this.depthTexture = source.depthTexture, this.texture.length = 0;
					for (let i = 0, t = source.texture.length; i < t; i++) this.texture[i] = source.texture[i].clone();
					return this
				}
			}).prototype.isWebGLMultipleRenderTargets = !0;
			class ne extends ee {
				constructor(t, e, n = {}) {
					super(t, e, n), this.samples = 4, this.ignoreDepthForMultisampleCopy = void 0 === n.ignoreDepth || n.ignoreDepth, this.useRenderToTexture = void 0 !== n.useRenderToTexture && n.useRenderToTexture, this.useRenderbuffer = !1 === this.useRenderToTexture
				}
				copy(source) {
					return super.copy.call(this, source), this.samples = source.samples, this.useRenderToTexture = source.useRenderToTexture, this.useRenderbuffer = source.useRenderbuffer, this
				}
			}
			ne.prototype.isWebGLMultisampleRenderTarget = !0;
			class ie {
				constructor(t = 0, e = 0, n = 0, r = 1) {
					this._x = t, this._y = e, this._z = n, this._w = r
				}
				static slerp(t, e, n, r) {
					return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."), n.slerpQuaternions(t, e, r)
				}
				static slerpFlat(t, e, n, r, o, l, c) {
					let h = n[r + 0],
						d = n[r + 1],
						f = n[r + 2],
						m = n[r + 3];
					const v = o[l + 0],
						y = o[l + 1],
						x = o[l + 2],
						_ = o[l + 3];
					if (0 === c) return t[e + 0] = h, t[e + 1] = d, t[e + 2] = f, void(t[e + 3] = m);
					if (1 === c) return t[e + 0] = v, t[e + 1] = y, t[e + 2] = x, void(t[e + 3] = _);
					if (m !== _ || h !== v || d !== y || f !== x) {
						let s = 1 - c;
						const t = h * v + d * y + f * x + m * _,
							e = t >= 0 ? 1 : -1,
							n = 1 - t * t;
						if (n > Number.EPSILON) {
							const r = Math.sqrt(n),
								o = Math.atan2(r, t * e);
							s = Math.sin(s * o) / r, c = Math.sin(c * o) / r
						}
						const r = c * e;
						if (h = h * s + v * r, d = d * s + y * r, f = f * s + x * r, m = m * s + _ * r, s === 1 - c) {
							const t = 1 / Math.sqrt(h * h + d * d + f * f + m * m);
							h *= t, d *= t, f *= t, m *= t
						}
					}
					t[e] = h, t[e + 1] = d, t[e + 2] = f, t[e + 3] = m
				}
				static multiplyQuaternionsFlat(t, e, n, r, o, l) {
					const c = n[r],
						h = n[r + 1],
						d = n[r + 2],
						f = n[r + 3],
						m = o[l],
						v = o[l + 1],
						y = o[l + 2],
						x = o[l + 3];
					return t[e] = c * x + f * m + h * y - d * v, t[e + 1] = h * x + f * v + d * m - c * y, t[e + 2] = d * x + f * y + c * v - h * m, t[e + 3] = f * x - c * m - h * v - d * y, t
				}
				get x() {
					return this._x
				}
				set x(t) {
					this._x = t, this._onChangeCallback()
				}
				get y() {
					return this._y
				}
				set y(t) {
					this._y = t, this._onChangeCallback()
				}
				get z() {
					return this._z
				}
				set z(t) {
					this._z = t, this._onChangeCallback()
				}
				get w() {
					return this._w
				}
				set w(t) {
					this._w = t, this._onChangeCallback()
				}
				set(t, e, n, r) {
					return this._x = t, this._y = e, this._z = n, this._w = r, this._onChangeCallback(), this
				}
				clone() {
					return new this.constructor(this._x, this._y, this._z, this._w)
				}
				copy(t) {
					return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this._onChangeCallback(), this
				}
				setFromEuler(t, e) {
					if (!t || !t.isEuler) throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
					const n = t._x,
						r = t._y,
						o = t._z,
						l = t._order,
						c = Math.cos,
						h = Math.sin,
						d = c(n / 2),
						f = c(r / 2),
						m = c(o / 2),
						v = h(n / 2),
						y = h(r / 2),
						x = h(o / 2);
					switch (l) {
						case "XYZ":
							this._x = v * f * m + d * y * x, this._y = d * y * m - v * f * x, this._z = d * f * x + v * y * m, this._w = d * f * m - v * y * x;
							break;
						case "YXZ":
							this._x = v * f * m + d * y * x, this._y = d * y * m - v * f * x, this._z = d * f * x - v * y * m, this._w = d * f * m + v * y * x;
							break;
						case "ZXY":
							this._x = v * f * m - d * y * x, this._y = d * y * m + v * f * x, this._z = d * f * x + v * y * m, this._w = d * f * m - v * y * x;
							break;
						case "ZYX":
							this._x = v * f * m - d * y * x, this._y = d * y * m + v * f * x, this._z = d * f * x - v * y * m, this._w = d * f * m + v * y * x;
							break;
						case "YZX":
							this._x = v * f * m + d * y * x, this._y = d * y * m + v * f * x, this._z = d * f * x - v * y * m, this._w = d * f * m - v * y * x;
							break;
						case "XZY":
							this._x = v * f * m - d * y * x, this._y = d * y * m - v * f * x, this._z = d * f * x + v * y * m, this._w = d * f * m + v * y * x;
							break;
						default:
							console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + l)
					}
					return !1 !== e && this._onChangeCallback(), this
				}
				setFromAxisAngle(t, e) {
					const n = e / 2,
						s = Math.sin(n);
					return this._x = t.x * s, this._y = t.y * s, this._z = t.z * s, this._w = Math.cos(n), this._onChangeCallback(), this
				}
				setFromRotationMatrix(t) {
					const e = t.elements,
						n = e[0],
						r = e[4],
						o = e[8],
						l = e[1],
						c = e[5],
						h = e[9],
						d = e[2],
						f = e[6],
						m = e[10],
						v = n + c + m;
					if (v > 0) {
						const s = .5 / Math.sqrt(v + 1);
						this._w = .25 / s, this._x = (f - h) * s, this._y = (o - d) * s, this._z = (l - r) * s
					} else if (n > c && n > m) {
						const s = 2 * Math.sqrt(1 + n - c - m);
						this._w = (f - h) / s, this._x = .25 * s, this._y = (r + l) / s, this._z = (o + d) / s
					} else if (c > m) {
						const s = 2 * Math.sqrt(1 + c - n - m);
						this._w = (o - d) / s, this._x = (r + l) / s, this._y = .25 * s, this._z = (h + f) / s
					} else {
						const s = 2 * Math.sqrt(1 + m - n - c);
						this._w = (l - r) / s, this._x = (o + d) / s, this._y = (h + f) / s, this._z = .25 * s
					}
					return this._onChangeCallback(), this
				}
				setFromUnitVectors(t, e) {
					let n = t.dot(e) + 1;
					return n < Number.EPSILON ? (n = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -t.z, this._z = t.y, this._w = n)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x, this._w = n), this.normalize()
				}
				angleTo(q) {
					return 2 * Math.acos(Math.abs(Lt(this.dot(q), -1, 1)))
				}
				rotateTowards(q, t) {
					const e = this.angleTo(q);
					if (0 === e) return this;
					const n = Math.min(1, t / e);
					return this.slerp(q, n), this
				}
				identity() {
					return this.set(0, 0, 0, 1)
				}
				invert() {
					return this.conjugate()
				}
				conjugate() {
					return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
				}
				dot(t) {
					return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
				}
				lengthSq() {
					return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
				}
				length() {
					return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
				}
				normalize() {
					let t = this.length();
					return 0 === t ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (t = 1 / t, this._x = this._x * t, this._y = this._y * t, this._z = this._z * t, this._w = this._w * t), this._onChangeCallback(), this
				}
				multiply(q, p) {
					return void 0 !== p ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(q, p)) : this.multiplyQuaternions(this, q)
				}
				premultiply(q) {
					return this.multiplyQuaternions(q, this)
				}
				multiplyQuaternions(a, b) {
					const t = a._x,
						e = a._y,
						n = a._z,
						r = a._w,
						o = b._x,
						l = b._y,
						c = b._z,
						h = b._w;
					return this._x = t * h + r * o + e * c - n * l, this._y = e * h + r * l + n * o - t * c, this._z = n * h + r * c + t * l - e * o, this._w = r * h - t * o - e * l - n * c, this._onChangeCallback(), this
				}
				slerp(t, e) {
					if (0 === e) return this;
					if (1 === e) return this.copy(t);
					const n = this._x,
						r = this._y,
						o = this._z,
						l = this._w;
					let c = l * t._w + n * t._x + r * t._y + o * t._z;
					if (c < 0 ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, c = -c) : this.copy(t), c >= 1) return this._w = l, this._x = n, this._y = r, this._z = o, this;
					const h = 1 - c * c;
					if (h <= Number.EPSILON) {
						const s = 1 - e;
						return this._w = s * l + e * this._w, this._x = s * n + e * this._x, this._y = s * r + e * this._y, this._z = s * o + e * this._z, this.normalize(), this._onChangeCallback(), this
					}
					const d = Math.sqrt(h),
						f = Math.atan2(d, c),
						m = Math.sin((1 - e) * f) / d,
						v = Math.sin(e * f) / d;
					return this._w = l * m + this._w * v, this._x = n * m + this._x * v, this._y = r * m + this._y * v, this._z = o * m + this._z * v, this._onChangeCallback(), this
				}
				slerpQuaternions(t, e, n) {
					return this.copy(t).slerp(e, n)
				}
				random() {
					const t = Math.random(),
						e = Math.sqrt(1 - t),
						n = Math.sqrt(t),
						r = 2 * Math.PI * Math.random(),
						o = 2 * Math.PI * Math.random();
					return this.set(e * Math.cos(r), n * Math.sin(o), n * Math.cos(o), e * Math.sin(r))
				}
				equals(t) {
					return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
				}
				fromArray(t, e = 0) {
					return this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this._onChangeCallback(), this
				}
				toArray(t = [], e = 0) {
					return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
				}
				fromBufferAttribute(t, e) {
					return this._x = t.getX(e), this._y = t.getY(e), this._z = t.getZ(e), this._w = t.getW(e), this
				}
				_onChange(t) {
					return this._onChangeCallback = t, this
				}
				_onChangeCallback() {}
			}
			ie.prototype.isQuaternion = !0;
			class re {
				constructor(t = 0, e = 0, n = 0) {
					this.x = t, this.y = e, this.z = n
				}
				set(t, e, n) {
					return void 0 === n && (n = this.z), this.x = t, this.y = e, this.z = n, this
				}
				setScalar(t) {
					return this.x = t, this.y = t, this.z = t, this
				}
				setX(t) {
					return this.x = t, this
				}
				setY(t) {
					return this.y = t, this
				}
				setZ(t) {
					return this.z = t, this
				}
				setComponent(t, e) {
					switch (t) {
						case 0:
							this.x = e;
							break;
						case 1:
							this.y = e;
							break;
						case 2:
							this.z = e;
							break;
						default:
							throw new Error("index is out of range: " + t)
					}
					return this
				}
				getComponent(t) {
					switch (t) {
						case 0:
							return this.x;
						case 1:
							return this.y;
						case 2:
							return this.z;
						default:
							throw new Error("index is out of range: " + t)
					}
				}
				clone() {
					return new this.constructor(this.x, this.y, this.z)
				}
				copy(t) {
					return this.x = t.x, this.y = t.y, this.z = t.z, this
				}
				add(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
				}
				addScalar(s) {
					return this.x += s, this.y += s, this.z += s, this
				}
				addVectors(a, b) {
					return this.x = a.x + b.x, this.y = a.y + b.y, this.z = a.z + b.z, this
				}
				addScaledVector(t, s) {
					return this.x += t.x * s, this.y += t.y * s, this.z += t.z * s, this
				}
				sub(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
				}
				subScalar(s) {
					return this.x -= s, this.y -= s, this.z -= s, this
				}
				subVectors(a, b) {
					return this.x = a.x - b.x, this.y = a.y - b.y, this.z = a.z - b.z, this
				}
				multiply(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
				}
				multiplyScalar(t) {
					return this.x *= t, this.y *= t, this.z *= t, this
				}
				multiplyVectors(a, b) {
					return this.x = a.x * b.x, this.y = a.y * b.y, this.z = a.z * b.z, this
				}
				applyEuler(t) {
					return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(ae.setFromEuler(t))
				}
				applyAxisAngle(t, e) {
					return this.applyQuaternion(ae.setFromAxisAngle(t, e))
				}
				applyMatrix3(t) {
					const e = this.x,
						n = this.y,
						r = this.z,
						o = t.elements;
					return this.x = o[0] * e + o[3] * n + o[6] * r, this.y = o[1] * e + o[4] * n + o[7] * r, this.z = o[2] * e + o[5] * n + o[8] * r, this
				}
				applyNormalMatrix(t) {
					return this.applyMatrix3(t).normalize()
				}
				applyMatrix4(t) {
					const e = this.x,
						n = this.y,
						r = this.z,
						o = t.elements,
						l = 1 / (o[3] * e + o[7] * n + o[11] * r + o[15]);
					return this.x = (o[0] * e + o[4] * n + o[8] * r + o[12]) * l, this.y = (o[1] * e + o[5] * n + o[9] * r + o[13]) * l, this.z = (o[2] * e + o[6] * n + o[10] * r + o[14]) * l, this
				}
				applyQuaternion(q) {
					const t = this.x,
						e = this.y,
						n = this.z,
						r = q.x,
						o = q.y,
						l = q.z,
						c = q.w,
						h = c * t + o * n - l * e,
						d = c * e + l * t - r * n,
						f = c * n + r * e - o * t,
						m = -r * t - o * e - l * n;
					return this.x = h * c + m * -r + d * -l - f * -o, this.y = d * c + m * -o + f * -r - h * -l, this.z = f * c + m * -l + h * -o - d * -r, this
				}
				project(t) {
					return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
				}
				unproject(t) {
					return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)
				}
				transformDirection(t) {
					const e = this.x,
						n = this.y,
						r = this.z,
						o = t.elements;
					return this.x = o[0] * e + o[4] * n + o[8] * r, this.y = o[1] * e + o[5] * n + o[9] * r, this.z = o[2] * e + o[6] * n + o[10] * r, this.normalize()
				}
				divide(t) {
					return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
				}
				divideScalar(t) {
					return this.multiplyScalar(1 / t)
				}
				min(t) {
					return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
				}
				max(t) {
					return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
				}
				clamp(t, e) {
					return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
				}
				clampScalar(t, e) {
					return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this
				}
				clampLength(t, e) {
					const n = this.length();
					return this.divideScalar(n || 1).multiplyScalar(Math.max(t, Math.min(e, n)))
				}
				floor() {
					return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
				}
				ceil() {
					return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
				}
				round() {
					return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
				}
				roundToZero() {
					return this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x), this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y), this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z), this
				}
				negate() {
					return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
				}
				dot(t) {
					return this.x * t.x + this.y * t.y + this.z * t.z
				}
				lengthSq() {
					return this.x * this.x + this.y * this.y + this.z * this.z
				}
				length() {
					return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
				}
				manhattanLength() {
					return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
				}
				normalize() {
					return this.divideScalar(this.length() || 1)
				}
				setLength(t) {
					return this.normalize().multiplyScalar(t)
				}
				lerp(t, e) {
					return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
				}
				lerpVectors(t, e, n) {
					return this.x = t.x + (e.x - t.x) * n, this.y = t.y + (e.y - t.y) * n, this.z = t.z + (e.z - t.z) * n, this
				}
				cross(t, e) {
					return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
				}
				crossVectors(a, b) {
					const t = a.x,
						e = a.y,
						n = a.z,
						r = b.x,
						o = b.y,
						l = b.z;
					return this.x = e * l - n * o, this.y = n * r - t * l, this.z = t * o - e * r, this
				}
				projectOnVector(t) {
					const e = t.lengthSq();
					if (0 === e) return this.set(0, 0, 0);
					const n = t.dot(this) / e;
					return this.copy(t).multiplyScalar(n)
				}
				projectOnPlane(t) {
					return se.copy(this).projectOnVector(t), this.sub(se)
				}
				reflect(t) {
					return this.sub(se.copy(t).multiplyScalar(2 * this.dot(t)))
				}
				angleTo(t) {
					const e = Math.sqrt(this.lengthSq() * t.lengthSq());
					if (0 === e) return Math.PI / 2;
					const n = this.dot(t) / e;
					return Math.acos(Lt(n, -1, 1))
				}
				distanceTo(t) {
					return Math.sqrt(this.distanceToSquared(t))
				}
				distanceToSquared(t) {
					const e = this.x - t.x,
						n = this.y - t.y,
						r = this.z - t.z;
					return e * e + n * n + r * r
				}
				manhattanDistanceTo(t) {
					return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
				}
				setFromSpherical(s) {
					return this.setFromSphericalCoords(s.radius, s.phi, s.theta)
				}
				setFromSphericalCoords(t, e, n) {
					const r = Math.sin(e) * t;
					return this.x = r * Math.sin(n), this.y = Math.cos(e) * t, this.z = r * Math.cos(n), this
				}
				setFromCylindrical(t) {
					return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
				}
				setFromCylindricalCoords(t, e, n) {
					return this.x = t * Math.sin(e), this.y = n, this.z = t * Math.cos(e), this
				}
				setFromMatrixPosition(t) {
					const e = t.elements;
					return this.x = e[12], this.y = e[13], this.z = e[14], this
				}
				setFromMatrixScale(t) {
					const e = this.setFromMatrixColumn(t, 0).length(),
						n = this.setFromMatrixColumn(t, 1).length(),
						r = this.setFromMatrixColumn(t, 2).length();
					return this.x = e, this.y = n, this.z = r, this
				}
				setFromMatrixColumn(t, e) {
					return this.fromArray(t.elements, 4 * e)
				}
				setFromMatrix3Column(t, e) {
					return this.fromArray(t.elements, 3 * e)
				}
				equals(t) {
					return t.x === this.x && t.y === this.y && t.z === this.z
				}
				fromArray(t, e = 0) {
					return this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
				}
				toArray(t = [], e = 0) {
					return t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
				}
				fromBufferAttribute(t, e, n) {
					return void 0 !== n && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
				}
				random() {
					return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
				}
				randomDirection() {
					const u = 2 * (Math.random() - .5),
						t = Math.random() * Math.PI * 2,
						e = Math.sqrt(1 - u ** 2);
					return this.x = e * Math.cos(t), this.y = e * Math.sin(t), this.z = u, this
				}*[Symbol.iterator]() {
					yield this.x, yield this.y, yield this.z
				}
			}
			re.prototype.isVector3 = !0;
			const se = new re,
				ae = new ie;
			class oe {
				constructor(t = new re(1 / 0, 1 / 0, 1 / 0), e = new re(-1 / 0, -1 / 0, -1 / 0)) {
					this.min = t, this.max = e
				}
				set(t, e) {
					return this.min.copy(t), this.max.copy(e), this
				}
				setFromArray(t) {
					let e = 1 / 0,
						n = 1 / 0,
						r = 1 / 0,
						o = -1 / 0,
						l = -1 / 0,
						c = -1 / 0;
					for (let i = 0, h = t.length; i < h; i += 3) {
						const h = t[i],
							d = t[i + 1],
							f = t[i + 2];
						h < e && (e = h), d < n && (n = d), f < r && (r = f), h > o && (o = h), d > l && (l = d), f > c && (c = f)
					}
					return this.min.set(e, n, r), this.max.set(o, l, c), this
				}
				setFromBufferAttribute(t) {
					let e = 1 / 0,
						n = 1 / 0,
						r = 1 / 0,
						o = -1 / 0,
						l = -1 / 0,
						c = -1 / 0;
					for (let i = 0, h = t.count; i < h; i++) {
						const h = t.getX(i),
							d = t.getY(i),
							f = t.getZ(i);
						h < e && (e = h), d < n && (n = d), f < r && (r = f), h > o && (o = h), d > l && (l = d), f > c && (c = f)
					}
					return this.min.set(e, n, r), this.max.set(o, l, c), this
				}
				setFromPoints(t) {
					this.makeEmpty();
					for (let i = 0, e = t.length; i < e; i++) this.expandByPoint(t[i]);
					return this
				}
				setFromCenterAndSize(t, e) {
					const n = ce.copy(e).multiplyScalar(.5);
					return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
				}
				setFromObject(object, t = !1) {
					return this.makeEmpty(), this.expandByObject(object, t)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(t) {
					return this.min.copy(t.min), this.max.copy(t.max), this
				}
				makeEmpty() {
					return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
				}
				isEmpty() {
					return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
				}
				getCenter(t) {
					return this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
				}
				getSize(t) {
					return this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
				}
				expandByPoint(t) {
					return this.min.min(t), this.max.max(t), this
				}
				expandByVector(t) {
					return this.min.sub(t), this.max.add(t), this
				}
				expandByScalar(t) {
					return this.min.addScalar(-t), this.max.addScalar(t), this
				}
				expandByObject(object, t = !1) {
					object.updateWorldMatrix(!1, !1);
					const e = object.geometry;
					if (void 0 !== e)
						if (t && null != e.attributes && void 0 !== e.attributes.position) {
							const t = e.attributes.position;
							for (let i = 0, e = t.count; i < e; i++) ce.fromBufferAttribute(t, i).applyMatrix4(object.matrixWorld), this.expandByPoint(ce)
						} else null === e.boundingBox && e.computeBoundingBox(), he.copy(e.boundingBox), he.applyMatrix4(object.matrixWorld), this.union(he);
					const n = object.children;
					for (let i = 0, e = n.length; i < e; i++) this.expandByObject(n[i], t);
					return this
				}
				containsPoint(t) {
					return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
				}
				containsBox(t) {
					return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
				}
				getParameter(t, e) {
					return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
				}
				intersectsBox(t) {
					return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
				}
				intersectsSphere(t) {
					return this.clampPoint(t.center, ce), ce.distanceToSquared(t.center) <= t.radius * t.radius
				}
				intersectsPlane(t) {
					let e, n;
					return t.normal.x > 0 ? (e = t.normal.x * this.min.x, n = t.normal.x * this.max.x) : (e = t.normal.x * this.max.x, n = t.normal.x * this.min.x), t.normal.y > 0 ? (e += t.normal.y * this.min.y, n += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, n += t.normal.y * this.min.y), t.normal.z > 0 ? (e += t.normal.z * this.min.z, n += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, n += t.normal.z * this.min.z), e <= -t.constant && n >= -t.constant
				}
				intersectsTriangle(t) {
					if (this.isEmpty()) return !1;
					this.getCenter(ve), ye.subVectors(this.max, ve), ue.subVectors(t.a, ve), de.subVectors(t.b, ve), pe.subVectors(t.c, ve), fe.subVectors(de, ue), me.subVectors(pe, de), ge.subVectors(ue, pe);
					let e = [0, -fe.z, fe.y, 0, -me.z, me.y, 0, -ge.z, ge.y, fe.z, 0, -fe.x, me.z, 0, -me.x, ge.z, 0, -ge.x, -fe.y, fe.x, 0, -me.y, me.x, 0, -ge.y, ge.x, 0];
					return !!we(e, ue, de, pe, ye) && (e = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!we(e, ue, de, pe, ye) && (xe.crossVectors(fe, me), e = [xe.x, xe.y, xe.z], we(e, ue, de, pe, ye)))
				}
				clampPoint(t, e) {
					return e.copy(t).clamp(this.min, this.max)
				}
				distanceToPoint(t) {
					return ce.copy(t).clamp(this.min, this.max).sub(t).length()
				}
				getBoundingSphere(t) {
					return this.getCenter(t.center), t.radius = .5 * this.getSize(ce).length(), t
				}
				intersect(t) {
					return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
				}
				union(t) {
					return this.min.min(t.min), this.max.max(t.max), this
				}
				applyMatrix4(t) {
					return this.isEmpty() || (le[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t), le[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t), le[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t), le[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t), le[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t), le[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t), le[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t), le[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t), this.setFromPoints(le)), this
				}
				translate(t) {
					return this.min.add(t), this.max.add(t), this
				}
				equals(t) {
					return t.min.equals(this.min) && t.max.equals(this.max)
				}
			}
			oe.prototype.isBox3 = !0;
			const le = [new re, new re, new re, new re, new re, new re, new re, new re],
				ce = new re,
				he = new oe,
				ue = new re,
				de = new re,
				pe = new re,
				fe = new re,
				me = new re,
				ge = new re,
				ve = new re,
				ye = new re,
				xe = new re,
				_e = new re;

			function we(t, e, n, r, o) {
				for (let i = 0, l = t.length - 3; i <= l; i += 3) {
					_e.fromArray(t, i);
					const l = o.x * Math.abs(_e.x) + o.y * Math.abs(_e.y) + o.z * Math.abs(_e.z),
						c = e.dot(_e),
						h = n.dot(_e),
						d = r.dot(_e);
					if (Math.max(-Math.max(c, h, d), Math.min(c, h, d)) > l) return !1
				}
				return !0
			}
			const Ae = new oe,
				be = new re,
				Me = new re,
				Se = new re;
			class Te {
				constructor(t = new re, e = -1) {
					this.center = t, this.radius = e
				}
				set(t, e) {
					return this.center.copy(t), this.radius = e, this
				}
				setFromPoints(t, e) {
					const n = this.center;
					void 0 !== e ? n.copy(e) : Ae.setFromPoints(t).getCenter(n);
					let r = 0;
					for (let i = 0, e = t.length; i < e; i++) r = Math.max(r, n.distanceToSquared(t[i]));
					return this.radius = Math.sqrt(r), this
				}
				copy(t) {
					return this.center.copy(t.center), this.radius = t.radius, this
				}
				isEmpty() {
					return this.radius < 0
				}
				makeEmpty() {
					return this.center.set(0, 0, 0), this.radius = -1, this
				}
				containsPoint(t) {
					return t.distanceToSquared(this.center) <= this.radius * this.radius
				}
				distanceToPoint(t) {
					return t.distanceTo(this.center) - this.radius
				}
				intersectsSphere(t) {
					const e = this.radius + t.radius;
					return t.center.distanceToSquared(this.center) <= e * e
				}
				intersectsBox(t) {
					return t.intersectsSphere(this)
				}
				intersectsPlane(t) {
					return Math.abs(t.distanceToPoint(this.center)) <= this.radius
				}
				clampPoint(t, e) {
					const n = this.center.distanceToSquared(t);
					return e.copy(t), n > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
				}
				getBoundingBox(t) {
					return this.isEmpty() ? (t.makeEmpty(), t) : (t.set(this.center, this.center), t.expandByScalar(this.radius), t)
				}
				applyMatrix4(t) {
					return this.center.applyMatrix4(t), this.radius = this.radius * t.getMaxScaleOnAxis(), this
				}
				translate(t) {
					return this.center.add(t), this
				}
				expandByPoint(t) {
					Se.subVectors(t, this.center);
					const e = Se.lengthSq();
					if (e > this.radius * this.radius) {
						const t = Math.sqrt(e),
							n = .5 * (t - this.radius);
						this.center.add(Se.multiplyScalar(n / t)), this.radius += n
					}
					return this
				}
				union(t) {
					return !0 === this.center.equals(t.center) ? Me.set(0, 0, 1).multiplyScalar(t.radius) : Me.subVectors(t.center, this.center).normalize().multiplyScalar(t.radius), this.expandByPoint(be.copy(t.center).add(Me)), this.expandByPoint(be.copy(t.center).sub(Me)), this
				}
				equals(t) {
					return t.center.equals(this.center) && t.radius === this.radius
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			const Ee = new re,
				Ce = new re,
				Re = new re,
				De = new re,
				Le = new re,
				Pe = new re,
				Ie = new re;
			class Be {
				constructor(t = new re, e = new re(0, 0, -1)) {
					this.origin = t, this.direction = e
				}
				set(t, e) {
					return this.origin.copy(t), this.direction.copy(e), this
				}
				copy(t) {
					return this.origin.copy(t.origin), this.direction.copy(t.direction), this
				}
				at(t, e) {
					return e.copy(this.direction).multiplyScalar(t).add(this.origin)
				}
				lookAt(t) {
					return this.direction.copy(t).sub(this.origin).normalize(), this
				}
				recast(t) {
					return this.origin.copy(this.at(t, Ee)), this
				}
				closestPointToPoint(t, e) {
					e.subVectors(t, this.origin);
					const n = e.dot(this.direction);
					return n < 0 ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(n).add(this.origin)
				}
				distanceToPoint(t) {
					return Math.sqrt(this.distanceSqToPoint(t))
				}
				distanceSqToPoint(t) {
					const e = Ee.subVectors(t, this.origin).dot(this.direction);
					return e < 0 ? this.origin.distanceToSquared(t) : (Ee.copy(this.direction).multiplyScalar(e).add(this.origin), Ee.distanceToSquared(t))
				}
				distanceSqToSegment(t, e, n, r) {
					Ce.copy(t).add(e).multiplyScalar(.5), Re.copy(e).sub(t).normalize(), De.copy(this.origin).sub(Ce);
					const o = .5 * t.distanceTo(e),
						l = -this.direction.dot(Re),
						c = De.dot(this.direction),
						h = -De.dot(Re),
						d = De.lengthSq(),
						f = Math.abs(1 - l * l);
					let m, v, y, x;
					if (f > 0)
						if (m = l * h - c, v = l * c - h, x = o * f, m >= 0)
							if (v >= -x)
								if (v <= x) {
									const t = 1 / f;
									m *= t, v *= t, y = m * (m + l * v + 2 * c) + v * (l * m + v + 2 * h) + d
								} else v = o, m = Math.max(0, -(l * v + c)), y = -m * m + v * (v + 2 * h) + d;
					else v = -o, m = Math.max(0, -(l * v + c)), y = -m * m + v * (v + 2 * h) + d;
					else v <= -x ? (m = Math.max(0, -(-l * o + c)), v = m > 0 ? -o : Math.min(Math.max(-o, -h), o), y = -m * m + v * (v + 2 * h) + d) : v <= x ? (m = 0, v = Math.min(Math.max(-o, -h), o), y = v * (v + 2 * h) + d) : (m = Math.max(0, -(l * o + c)), v = m > 0 ? o : Math.min(Math.max(-o, -h), o), y = -m * m + v * (v + 2 * h) + d);
					else v = l > 0 ? -o : o, m = Math.max(0, -(l * v + c)), y = -m * m + v * (v + 2 * h) + d;
					return n && n.copy(this.direction).multiplyScalar(m).add(this.origin), r && r.copy(Re).multiplyScalar(v).add(Ce), y
				}
				intersectSphere(t, e) {
					Ee.subVectors(t.center, this.origin);
					const n = Ee.dot(this.direction),
						r = Ee.dot(Ee) - n * n,
						o = t.radius * t.radius;
					if (r > o) return null;
					const l = Math.sqrt(o - r),
						c = n - l,
						h = n + l;
					return c < 0 && h < 0 ? null : c < 0 ? this.at(h, e) : this.at(c, e)
				}
				intersectsSphere(t) {
					return this.distanceSqToPoint(t.center) <= t.radius * t.radius
				}
				distanceToPlane(t) {
					const e = t.normal.dot(this.direction);
					if (0 === e) return 0 === t.distanceToPoint(this.origin) ? 0 : null;
					const n = -(this.origin.dot(t.normal) + t.constant) / e;
					return n >= 0 ? n : null
				}
				intersectPlane(t, e) {
					const n = this.distanceToPlane(t);
					return null === n ? null : this.at(n, e)
				}
				intersectsPlane(t) {
					const e = t.distanceToPoint(this.origin);
					if (0 === e) return !0;
					return t.normal.dot(this.direction) * e < 0
				}
				intersectBox(t, e) {
					let n, r, o, l, c, h;
					const d = 1 / this.direction.x,
						f = 1 / this.direction.y,
						m = 1 / this.direction.z,
						v = this.origin;
					return d >= 0 ? (n = (t.min.x - v.x) * d, r = (t.max.x - v.x) * d) : (n = (t.max.x - v.x) * d, r = (t.min.x - v.x) * d), f >= 0 ? (o = (t.min.y - v.y) * f, l = (t.max.y - v.y) * f) : (o = (t.max.y - v.y) * f, l = (t.min.y - v.y) * f), n > l || o > r ? null : ((o > n || n != n) && (n = o), (l < r || r != r) && (r = l), m >= 0 ? (c = (t.min.z - v.z) * m, h = (t.max.z - v.z) * m) : (c = (t.max.z - v.z) * m, h = (t.min.z - v.z) * m), n > h || c > r ? null : ((c > n || n != n) && (n = c), (h < r || r != r) && (r = h), r < 0 ? null : this.at(n >= 0 ? n : r, e)))
				}
				intersectsBox(t) {
					return null !== this.intersectBox(t, Ee)
				}
				intersectTriangle(a, b, t, e, n) {
					Le.subVectors(b, a), Pe.subVectors(t, a), Ie.crossVectors(Le, Pe);
					let r, o = this.direction.dot(Ie);
					if (o > 0) {
						if (e) return null;
						r = 1
					} else {
						if (!(o < 0)) return null;
						r = -1, o = -o
					}
					De.subVectors(this.origin, a);
					const l = r * this.direction.dot(Pe.crossVectors(De, Pe));
					if (l < 0) return null;
					const c = r * this.direction.dot(Le.cross(De));
					if (c < 0) return null;
					if (l + c > o) return null;
					const h = -r * De.dot(Ie);
					return h < 0 ? null : this.at(h / o, n)
				}
				applyMatrix4(t) {
					return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
				}
				equals(t) {
					return t.origin.equals(this.origin) && t.direction.equals(this.direction)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			class Oe {
				constructor() {
					this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], arguments.length > 0 && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
				}
				set(t, e, n, r, o, l, c, h, d, f, m, v, y, x, _, w) {
					const A = this.elements;
					return A[0] = t, A[4] = e, A[8] = n, A[12] = r, A[1] = o, A[5] = l, A[9] = c, A[13] = h, A[2] = d, A[6] = f, A[10] = m, A[14] = v, A[3] = y, A[7] = x, A[11] = _, A[15] = w, this
				}
				identity() {
					return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
				}
				clone() {
					return (new Oe).fromArray(this.elements)
				}
				copy(t) {
					const e = this.elements,
						n = t.elements;
					return e[0] = n[0], e[1] = n[1], e[2] = n[2], e[3] = n[3], e[4] = n[4], e[5] = n[5], e[6] = n[6], e[7] = n[7], e[8] = n[8], e[9] = n[9], e[10] = n[10], e[11] = n[11], e[12] = n[12], e[13] = n[13], e[14] = n[14], e[15] = n[15], this
				}
				copyPosition(t) {
					const e = this.elements,
						n = t.elements;
					return e[12] = n[12], e[13] = n[13], e[14] = n[14], this
				}
				setFromMatrix3(t) {
					const e = t.elements;
					return this.set(e[0], e[3], e[6], 0, e[1], e[4], e[7], 0, e[2], e[5], e[8], 0, 0, 0, 0, 1), this
				}
				extractBasis(t, e, n) {
					return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
				}
				makeBasis(t, e, n) {
					return this.set(t.x, e.x, n.x, 0, t.y, e.y, n.y, 0, t.z, e.z, n.z, 0, 0, 0, 0, 1), this
				}
				extractRotation(t) {
					const e = this.elements,
						n = t.elements,
						r = 1 / Fe.setFromMatrixColumn(t, 0).length(),
						o = 1 / Fe.setFromMatrixColumn(t, 1).length(),
						l = 1 / Fe.setFromMatrixColumn(t, 2).length();
					return e[0] = n[0] * r, e[1] = n[1] * r, e[2] = n[2] * r, e[3] = 0, e[4] = n[4] * o, e[5] = n[5] * o, e[6] = n[6] * o, e[7] = 0, e[8] = n[8] * l, e[9] = n[9] * l, e[10] = n[10] * l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
				}
				makeRotationFromEuler(t) {
					t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
					const e = this.elements,
						n = t.x,
						r = t.y,
						o = t.z,
						a = Math.cos(n),
						b = Math.sin(n),
						l = Math.cos(r),
						c = Math.sin(r),
						h = Math.cos(o),
						d = Math.sin(o);
					if ("XYZ" === t.order) {
						const t = a * h,
							n = a * d,
							r = b * h,
							o = b * d;
						e[0] = l * h, e[4] = -l * d, e[8] = c, e[1] = n + r * c, e[5] = t - o * c, e[9] = -b * l, e[2] = o - t * c, e[6] = r + n * c, e[10] = a * l
					} else if ("YXZ" === t.order) {
						const t = l * h,
							n = l * d,
							r = c * h,
							o = c * d;
						e[0] = t + o * b, e[4] = r * b - n, e[8] = a * c, e[1] = a * d, e[5] = a * h, e[9] = -b, e[2] = n * b - r, e[6] = o + t * b, e[10] = a * l
					} else if ("ZXY" === t.order) {
						const t = l * h,
							n = l * d,
							r = c * h,
							o = c * d;
						e[0] = t - o * b, e[4] = -a * d, e[8] = r + n * b, e[1] = n + r * b, e[5] = a * h, e[9] = o - t * b, e[2] = -a * c, e[6] = b, e[10] = a * l
					} else if ("ZYX" === t.order) {
						const t = a * h,
							n = a * d,
							r = b * h,
							o = b * d;
						e[0] = l * h, e[4] = r * c - n, e[8] = t * c + o, e[1] = l * d, e[5] = o * c + t, e[9] = n * c - r, e[2] = -c, e[6] = b * l, e[10] = a * l
					} else if ("YZX" === t.order) {
						const t = a * l,
							n = a * c,
							r = b * l,
							o = b * c;
						e[0] = l * h, e[4] = o - t * d, e[8] = r * d + n, e[1] = d, e[5] = a * h, e[9] = -b * h, e[2] = -c * h, e[6] = n * d + r, e[10] = t - o * d
					} else if ("XZY" === t.order) {
						const t = a * l,
							n = a * c,
							r = b * l,
							o = b * c;
						e[0] = l * h, e[4] = -d, e[8] = c * h, e[1] = t * d + o, e[5] = a * h, e[9] = n * d - r, e[2] = r * d - n, e[6] = b * h, e[10] = o * d + t
					}
					return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
				}
				makeRotationFromQuaternion(q) {
					return this.compose(Ne, q, Ue)
				}
				lookAt(t, e, n) {
					const r = this.elements;
					return Ge.subVectors(t, e), 0 === Ge.lengthSq() && (Ge.z = 1), Ge.normalize(), ze.crossVectors(n, Ge), 0 === ze.lengthSq() && (1 === Math.abs(n.z) ? Ge.x += 1e-4 : Ge.z += 1e-4, Ge.normalize(), ze.crossVectors(n, Ge)), ze.normalize(), ke.crossVectors(Ge, ze), r[0] = ze.x, r[4] = ke.x, r[8] = Ge.x, r[1] = ze.y, r[5] = ke.y, r[9] = Ge.y, r[2] = ze.z, r[6] = ke.z, r[10] = Ge.z, this
				}
				multiply(t, e) {
					return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
				}
				premultiply(t) {
					return this.multiplyMatrices(t, this)
				}
				multiplyMatrices(a, b) {
					const t = a.elements,
						e = b.elements,
						n = this.elements,
						r = t[0],
						o = t[4],
						l = t[8],
						c = t[12],
						h = t[1],
						d = t[5],
						f = t[9],
						m = t[13],
						v = t[2],
						y = t[6],
						x = t[10],
						_ = t[14],
						w = t[3],
						A = t[7],
						M = t[11],
						S = t[15],
						T = e[0],
						E = e[4],
						C = e[8],
						R = e[12],
						D = e[1],
						L = e[5],
						P = e[9],
						I = e[13],
						B = e[2],
						O = e[6],
						F = e[10],
						H = e[14],
						N = e[3],
						U = e[7],
						z = e[11],
						k = e[15];
					return n[0] = r * T + o * D + l * B + c * N, n[4] = r * E + o * L + l * O + c * U, n[8] = r * C + o * P + l * F + c * z, n[12] = r * R + o * I + l * H + c * k, n[1] = h * T + d * D + f * B + m * N, n[5] = h * E + d * L + f * O + m * U, n[9] = h * C + d * P + f * F + m * z, n[13] = h * R + d * I + f * H + m * k, n[2] = v * T + y * D + x * B + _ * N, n[6] = v * E + y * L + x * O + _ * U, n[10] = v * C + y * P + x * F + _ * z, n[14] = v * R + y * I + x * H + _ * k, n[3] = w * T + A * D + M * B + S * N, n[7] = w * E + A * L + M * O + S * U, n[11] = w * C + A * P + M * F + S * z, n[15] = w * R + A * I + M * H + S * k, this
				}
				multiplyScalar(s) {
					const t = this.elements;
					return t[0] *= s, t[4] *= s, t[8] *= s, t[12] *= s, t[1] *= s, t[5] *= s, t[9] *= s, t[13] *= s, t[2] *= s, t[6] *= s, t[10] *= s, t[14] *= s, t[3] *= s, t[7] *= s, t[11] *= s, t[15] *= s, this
				}
				determinant() {
					const t = this.elements,
						e = t[0],
						n = t[4],
						r = t[8],
						o = t[12],
						l = t[1],
						c = t[5],
						h = t[9],
						d = t[13],
						f = t[2],
						m = t[6],
						v = t[10],
						y = t[14];
					return t[3] * (+o * h * m - r * d * m - o * c * v + n * d * v + r * c * y - n * h * y) + t[7] * (+e * h * y - e * d * v + o * l * v - r * l * y + r * d * f - o * h * f) + t[11] * (+e * d * m - e * c * y - o * l * m + n * l * y + o * c * f - n * d * f) + t[15] * (-r * c * f - e * h * m + e * c * v + r * l * m - n * l * v + n * h * f)
				}
				transpose() {
					const t = this.elements;
					let e;
					return e = t[1], t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
				}
				setPosition(t, e, n) {
					const r = this.elements;
					return t.isVector3 ? (r[12] = t.x, r[13] = t.y, r[14] = t.z) : (r[12] = t, r[13] = e, r[14] = n), this
				}
				invert() {
					const t = this.elements,
						e = t[0],
						n = t[1],
						r = t[2],
						o = t[3],
						l = t[4],
						c = t[5],
						h = t[6],
						d = t[7],
						f = t[8],
						m = t[9],
						v = t[10],
						y = t[11],
						x = t[12],
						_ = t[13],
						w = t[14],
						A = t[15],
						M = m * w * d - _ * v * d + _ * h * y - c * w * y - m * h * A + c * v * A,
						S = x * v * d - f * w * d - x * h * y + l * w * y + f * h * A - l * v * A,
						T = f * _ * d - x * m * d + x * c * y - l * _ * y - f * c * A + l * m * A,
						E = x * m * h - f * _ * h - x * c * v + l * _ * v + f * c * w - l * m * w,
						C = e * M + n * S + r * T + o * E;
					if (0 === C) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
					const R = 1 / C;
					return t[0] = M * R, t[1] = (_ * v * o - m * w * o - _ * r * y + n * w * y + m * r * A - n * v * A) * R, t[2] = (c * w * o - _ * h * o + _ * r * d - n * w * d - c * r * A + n * h * A) * R, t[3] = (m * h * o - c * v * o - m * r * d + n * v * d + c * r * y - n * h * y) * R, t[4] = S * R, t[5] = (f * w * o - x * v * o + x * r * y - e * w * y - f * r * A + e * v * A) * R, t[6] = (x * h * o - l * w * o - x * r * d + e * w * d + l * r * A - e * h * A) * R, t[7] = (l * v * o - f * h * o + f * r * d - e * v * d - l * r * y + e * h * y) * R, t[8] = T * R, t[9] = (x * m * o - f * _ * o - x * n * y + e * _ * y + f * n * A - e * m * A) * R, t[10] = (l * _ * o - x * c * o + x * n * d - e * _ * d - l * n * A + e * c * A) * R, t[11] = (f * c * o - l * m * o - f * n * d + e * m * d + l * n * y - e * c * y) * R, t[12] = E * R, t[13] = (f * _ * r - x * m * r + x * n * v - e * _ * v - f * n * w + e * m * w) * R, t[14] = (x * c * r - l * _ * r - x * n * h + e * _ * h + l * n * w - e * c * w) * R, t[15] = (l * m * r - f * c * r + f * n * h - e * m * h - l * n * v + e * c * v) * R, this
				}
				scale(t) {
					const e = this.elements,
						n = t.x,
						r = t.y,
						o = t.z;
					return e[0] *= n, e[4] *= r, e[8] *= o, e[1] *= n, e[5] *= r, e[9] *= o, e[2] *= n, e[6] *= r, e[10] *= o, e[3] *= n, e[7] *= r, e[11] *= o, this
				}
				getMaxScaleOnAxis() {
					const t = this.elements,
						e = t[0] * t[0] + t[1] * t[1] + t[2] * t[2],
						n = t[4] * t[4] + t[5] * t[5] + t[6] * t[6],
						r = t[8] * t[8] + t[9] * t[9] + t[10] * t[10];
					return Math.sqrt(Math.max(e, n, r))
				}
				makeTranslation(t, e, n) {
					return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, n, 0, 0, 0, 1), this
				}
				makeRotationX(t) {
					const e = Math.cos(t),
						s = Math.sin(t);
					return this.set(1, 0, 0, 0, 0, e, -s, 0, 0, s, e, 0, 0, 0, 0, 1), this
				}
				makeRotationY(t) {
					const e = Math.cos(t),
						s = Math.sin(t);
					return this.set(e, 0, s, 0, 0, 1, 0, 0, -s, 0, e, 0, 0, 0, 0, 1), this
				}
				makeRotationZ(t) {
					const e = Math.cos(t),
						s = Math.sin(t);
					return this.set(e, -s, 0, 0, s, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
				}
				makeRotationAxis(t, e) {
					const n = Math.cos(e),
						s = Math.sin(e),
						r = 1 - n,
						o = t.x,
						l = t.y,
						c = t.z,
						h = r * o,
						d = r * l;
					return this.set(h * o + n, h * l - s * c, h * c + s * l, 0, h * l + s * c, d * l + n, d * c - s * o, 0, h * c - s * l, d * c + s * o, r * c * c + n, 0, 0, 0, 0, 1), this
				}
				makeScale(t, e, n) {
					return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
				}
				makeShear(t, e, n, r, o, l) {
					return this.set(1, n, o, 0, t, 1, l, 0, e, r, 1, 0, 0, 0, 0, 1), this
				}
				compose(t, e, n) {
					const r = this.elements,
						o = e._x,
						l = e._y,
						c = e._z,
						h = e._w,
						d = o + o,
						f = l + l,
						m = c + c,
						v = o * d,
						y = o * f,
						x = o * m,
						_ = l * f,
						w = l * m,
						A = c * m,
						M = h * d,
						S = h * f,
						T = h * m,
						E = n.x,
						C = n.y,
						R = n.z;
					return r[0] = (1 - (_ + A)) * E, r[1] = (y + T) * E, r[2] = (x - S) * E, r[3] = 0, r[4] = (y - T) * C, r[5] = (1 - (v + A)) * C, r[6] = (w + M) * C, r[7] = 0, r[8] = (x + S) * R, r[9] = (w - M) * R, r[10] = (1 - (v + _)) * R, r[11] = 0, r[12] = t.x, r[13] = t.y, r[14] = t.z, r[15] = 1, this
				}
				decompose(t, e, n) {
					const r = this.elements;
					let o = Fe.set(r[0], r[1], r[2]).length();
					const l = Fe.set(r[4], r[5], r[6]).length(),
						c = Fe.set(r[8], r[9], r[10]).length();
					this.determinant() < 0 && (o = -o), t.x = r[12], t.y = r[13], t.z = r[14], He.copy(this);
					const h = 1 / o,
						d = 1 / l,
						f = 1 / c;
					return He.elements[0] *= h, He.elements[1] *= h, He.elements[2] *= h, He.elements[4] *= d, He.elements[5] *= d, He.elements[6] *= d, He.elements[8] *= f, He.elements[9] *= f, He.elements[10] *= f, e.setFromRotationMatrix(He), n.x = o, n.y = l, n.z = c, this
				}
				makePerspective(t, e, n, r, o, l) {
					void 0 === l && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
					const c = this.elements,
						h = 2 * o / (e - t),
						d = 2 * o / (n - r),
						a = (e + t) / (e - t),
						b = (n + r) / (n - r),
						f = -(l + o) / (l - o),
						m = -2 * l * o / (l - o);
					return c[0] = h, c[4] = 0, c[8] = a, c[12] = 0, c[1] = 0, c[5] = d, c[9] = b, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = f, c[14] = m, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this
				}
				makeOrthographic(t, e, n, r, o, l) {
					const c = this.elements,
						h = 1 / (e - t),
						d = 1 / (n - r),
						p = 1 / (l - o),
						f = (e + t) * h,
						m = (n + r) * d,
						v = (l + o) * p;
					return c[0] = 2 * h, c[4] = 0, c[8] = 0, c[12] = -f, c[1] = 0, c[5] = 2 * d, c[9] = 0, c[13] = -m, c[2] = 0, c[6] = 0, c[10] = -2 * p, c[14] = -v, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this
				}
				equals(t) {
					const e = this.elements,
						n = t.elements;
					for (let i = 0; i < 16; i++)
						if (e[i] !== n[i]) return !1;
					return !0
				}
				fromArray(t, e = 0) {
					for (let i = 0; i < 16; i++) this.elements[i] = t[i + e];
					return this
				}
				toArray(t = [], e = 0) {
					const n = this.elements;
					return t[e] = n[0], t[e + 1] = n[1], t[e + 2] = n[2], t[e + 3] = n[3], t[e + 4] = n[4], t[e + 5] = n[5], t[e + 6] = n[6], t[e + 7] = n[7], t[e + 8] = n[8], t[e + 9] = n[9], t[e + 10] = n[10], t[e + 11] = n[11], t[e + 12] = n[12], t[e + 13] = n[13], t[e + 14] = n[14], t[e + 15] = n[15], t
				}
			}
			Oe.prototype.isMatrix4 = !0;
			const Fe = new re,
				He = new Oe,
				Ne = new re(0, 0, 0),
				Ue = new re(1, 1, 1),
				ze = new re,
				ke = new re,
				Ge = new re,
				Ve = new Oe,
				We = new ie;
			class je {
				constructor(t = 0, e = 0, n = 0, r = je.DefaultOrder) {
					this._x = t, this._y = e, this._z = n, this._order = r
				}
				get x() {
					return this._x
				}
				set x(t) {
					this._x = t, this._onChangeCallback()
				}
				get y() {
					return this._y
				}
				set y(t) {
					this._y = t, this._onChangeCallback()
				}
				get z() {
					return this._z
				}
				set z(t) {
					this._z = t, this._onChangeCallback()
				}
				get order() {
					return this._order
				}
				set order(t) {
					this._order = t, this._onChangeCallback()
				}
				set(t, e, n, r = this._order) {
					return this._x = t, this._y = e, this._z = n, this._order = r, this._onChangeCallback(), this
				}
				clone() {
					return new this.constructor(this._x, this._y, this._z, this._order)
				}
				copy(t) {
					return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this._onChangeCallback(), this
				}
				setFromRotationMatrix(t, e = this._order, n = !0) {
					const r = t.elements,
						o = r[0],
						l = r[4],
						c = r[8],
						h = r[1],
						d = r[5],
						f = r[9],
						m = r[2],
						v = r[6],
						y = r[10];
					switch (e) {
						case "XYZ":
							this._y = Math.asin(Lt(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-f, y), this._z = Math.atan2(-l, o)) : (this._x = Math.atan2(v, d), this._z = 0);
							break;
						case "YXZ":
							this._x = Math.asin(-Lt(f, -1, 1)), Math.abs(f) < .9999999 ? (this._y = Math.atan2(c, y), this._z = Math.atan2(h, d)) : (this._y = Math.atan2(-m, o), this._z = 0);
							break;
						case "ZXY":
							this._x = Math.asin(Lt(v, -1, 1)), Math.abs(v) < .9999999 ? (this._y = Math.atan2(-m, y), this._z = Math.atan2(-l, d)) : (this._y = 0, this._z = Math.atan2(h, o));
							break;
						case "ZYX":
							this._y = Math.asin(-Lt(m, -1, 1)), Math.abs(m) < .9999999 ? (this._x = Math.atan2(v, y), this._z = Math.atan2(h, o)) : (this._x = 0, this._z = Math.atan2(-l, d));
							break;
						case "YZX":
							this._z = Math.asin(Lt(h, -1, 1)), Math.abs(h) < .9999999 ? (this._x = Math.atan2(-f, d), this._y = Math.atan2(-m, o)) : (this._x = 0, this._y = Math.atan2(c, y));
							break;
						case "XZY":
							this._z = Math.asin(-Lt(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(v, d), this._y = Math.atan2(c, o)) : (this._x = Math.atan2(-f, y), this._y = 0);
							break;
						default:
							console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + e)
					}
					return this._order = e, !0 === n && this._onChangeCallback(), this
				}
				setFromQuaternion(q, t, e) {
					return Ve.makeRotationFromQuaternion(q), this.setFromRotationMatrix(Ve, t, e)
				}
				setFromVector3(t, e = this._order) {
					return this.set(t.x, t.y, t.z, e)
				}
				reorder(t) {
					return We.setFromEuler(this), this.setFromQuaternion(We, t)
				}
				equals(t) {
					return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
				}
				fromArray(t) {
					return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this._onChangeCallback(), this
				}
				toArray(t = [], e = 0) {
					return t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
				}
				toVector3(t) {
					return t ? t.set(this._x, this._y, this._z) : new re(this._x, this._y, this._z)
				}
				_onChange(t) {
					return this._onChangeCallback = t, this
				}
				_onChangeCallback() {}
			}
			je.prototype.isEuler = !0, je.DefaultOrder = "XYZ", je.RotationOrders = ["XYZ", "YZX", "ZXY", "XZY", "YXZ", "ZYX"];
			class Xe {
				constructor() {
					this.mask = 1
				}
				set(t) {
					this.mask = (1 << t | 0) >>> 0
				}
				enable(t) {
					this.mask |= 1 << t | 0
				}
				enableAll() {
					this.mask = -1
				}
				toggle(t) {
					this.mask ^= 1 << t | 0
				}
				disable(t) {
					this.mask &= ~(1 << t | 0)
				}
				disableAll() {
					this.mask = 0
				}
				test(t) {
					return 0 != (this.mask & t.mask)
				}
				isEnabled(t) {
					return 0 != (this.mask & (1 << t | 0))
				}
			}
			let Ye = 0;
			const Qe = new re,
				qe = new ie,
				Je = new Oe,
				Ke = new re,
				Ze = new re,
				$e = new re,
				tn = new ie,
				en = new re(1, 0, 0),
				nn = new re(0, 1, 0),
				rn = new re(0, 0, 1),
				sn = {
					type: "added"
				},
				an = {
					type: "removed"
				};
			class on extends St {
				constructor() {
					super(), Object.defineProperty(this, "id", {
						value: Ye++
					}), this.uuid = Dt(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = on.DefaultUp.clone();
					const t = new re,
						e = new je,
						n = new ie,
						r = new re(1, 1, 1);
					e._onChange((function() {
						n.setFromEuler(e, !1)
					})), n._onChange((function() {
						e.setFromQuaternion(n, void 0, !1)
					})), Object.defineProperties(this, {
						position: {
							configurable: !0,
							enumerable: !0,
							value: t
						},
						rotation: {
							configurable: !0,
							enumerable: !0,
							value: e
						},
						quaternion: {
							configurable: !0,
							enumerable: !0,
							value: n
						},
						scale: {
							configurable: !0,
							enumerable: !0,
							value: r
						},
						modelViewMatrix: {
							value: new Oe
						},
						normalMatrix: {
							value: new Ut
						}
					}), this.matrix = new Oe, this.matrixWorld = new Oe, this.matrixAutoUpdate = on.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new Xe, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
				}
				onBeforeRender() {}
				onAfterRender() {}
				applyMatrix4(t) {
					this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale)
				}
				applyQuaternion(q) {
					return this.quaternion.premultiply(q), this
				}
				setRotationFromAxisAngle(t, e) {
					this.quaternion.setFromAxisAngle(t, e)
				}
				setRotationFromEuler(t) {
					this.quaternion.setFromEuler(t, !0)
				}
				setRotationFromMatrix(t) {
					this.quaternion.setFromRotationMatrix(t)
				}
				setRotationFromQuaternion(q) {
					this.quaternion.copy(q)
				}
				rotateOnAxis(t, e) {
					return qe.setFromAxisAngle(t, e), this.quaternion.multiply(qe), this
				}
				rotateOnWorldAxis(t, e) {
					return qe.setFromAxisAngle(t, e), this.quaternion.premultiply(qe), this
				}
				rotateX(t) {
					return this.rotateOnAxis(en, t)
				}
				rotateY(t) {
					return this.rotateOnAxis(nn, t)
				}
				rotateZ(t) {
					return this.rotateOnAxis(rn, t)
				}
				translateOnAxis(t, e) {
					return Qe.copy(t).applyQuaternion(this.quaternion), this.position.add(Qe.multiplyScalar(e)), this
				}
				translateX(t) {
					return this.translateOnAxis(en, t)
				}
				translateY(t) {
					return this.translateOnAxis(nn, t)
				}
				translateZ(t) {
					return this.translateOnAxis(rn, t)
				}
				localToWorld(t) {
					return t.applyMatrix4(this.matrixWorld)
				}
				worldToLocal(t) {
					return t.applyMatrix4(Je.copy(this.matrixWorld).invert())
				}
				lookAt(t, e, n) {
					t.isVector3 ? Ke.copy(t) : Ke.set(t, e, n);
					const r = this.parent;
					this.updateWorldMatrix(!0, !1), Ze.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? Je.lookAt(Ze, Ke, this.up) : Je.lookAt(Ke, Ze, this.up), this.quaternion.setFromRotationMatrix(Je), r && (Je.extractRotation(r.matrixWorld), qe.setFromRotationMatrix(Je), this.quaternion.premultiply(qe.invert()))
				}
				add(object) {
					if (arguments.length > 1) {
						for (let i = 0; i < arguments.length; i++) this.add(arguments[i]);
						return this
					}
					return object === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", object), this) : (object && object.isObject3D ? (null !== object.parent && object.parent.remove(object), object.parent = this, this.children.push(object), object.dispatchEvent(sn)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", object), this)
				}
				remove(object) {
					if (arguments.length > 1) {
						for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
						return this
					}
					const t = this.children.indexOf(object);
					return -1 !== t && (object.parent = null, this.children.splice(t, 1), object.dispatchEvent(an)), this
				}
				removeFromParent() {
					const t = this.parent;
					return null !== t && t.remove(this), this
				}
				clear() {
					for (let i = 0; i < this.children.length; i++) {
						const object = this.children[i];
						object.parent = null, object.dispatchEvent(an)
					}
					return this.children.length = 0, this
				}
				attach(object) {
					return this.updateWorldMatrix(!0, !1), Je.copy(this.matrixWorld).invert(), null !== object.parent && (object.parent.updateWorldMatrix(!0, !1), Je.multiply(object.parent.matrixWorld)), object.applyMatrix4(Je), this.add(object), object.updateWorldMatrix(!1, !0), this
				}
				getObjectById(t) {
					return this.getObjectByProperty("id", t)
				}
				getObjectByName(t) {
					return this.getObjectByProperty("name", t)
				}
				getObjectByProperty(t, e) {
					if (this[t] === e) return this;
					for (let i = 0, n = this.children.length; i < n; i++) {
						const object = this.children[i].getObjectByProperty(t, e);
						if (void 0 !== object) return object
					}
				}
				getWorldPosition(t) {
					return this.updateWorldMatrix(!0, !1), t.setFromMatrixPosition(this.matrixWorld)
				}
				getWorldQuaternion(t) {
					return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ze, t, $e), t
				}
				getWorldScale(t) {
					return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Ze, tn, t), t
				}
				getWorldDirection(t) {
					this.updateWorldMatrix(!0, !1);
					const e = this.matrixWorld.elements;
					return t.set(e[8], e[9], e[10]).normalize()
				}
				raycast() {}
				traverse(t) {
					t(this);
					const e = this.children;
					for (let i = 0, n = e.length; i < n; i++) e[i].traverse(t)
				}
				traverseVisible(t) {
					if (!1 === this.visible) return;
					t(this);
					const e = this.children;
					for (let i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
				}
				traverseAncestors(t) {
					const e = this.parent;
					null !== e && (t(e), e.traverseAncestors(t))
				}
				updateMatrix() {
					this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
				}
				updateMatrixWorld(t) {
					this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
					const e = this.children;
					for (let i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
				}
				updateWorldMatrix(t, e) {
					const n = this.parent;
					if (!0 === t && null !== n && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) {
						const t = this.children;
						for (let i = 0, e = t.length; i < e; i++) t[i].updateWorldMatrix(!1, !0)
					}
				}
				toJSON(meta) {
					const t = void 0 === meta || "string" == typeof meta,
						output = {};
					t && (meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {},
						shapes: {},
						skeletons: {},
						animations: {}
					}, output.metadata = {
						version: 4.5,
						type: "Object",
						generator: "Object3D.toJSON"
					});
					const object = {};

					function e(t, element) {
						return void 0 === t[element.uuid] && (t[element.uuid] = element.toJSON(meta)), element.uuid
					}
					if (object.uuid = this.uuid, object.type = this.type, "" !== this.name && (object.name = this.name), !0 === this.castShadow && (object.castShadow = !0), !0 === this.receiveShadow && (object.receiveShadow = !0), !1 === this.visible && (object.visible = !1), !1 === this.frustumCulled && (object.frustumCulled = !1), 0 !== this.renderOrder && (object.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (object.userData = this.userData), object.layers = this.layers.mask, object.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (object.matrixAutoUpdate = !1), this.isInstancedMesh && (object.type = "InstancedMesh", object.count = this.count, object.instanceMatrix = this.instanceMatrix.toJSON(), null !== this.instanceColor && (object.instanceColor = this.instanceColor.toJSON())), this.isScene) this.background && (this.background.isColor ? object.background = this.background.toJSON() : this.background.isTexture && (object.background = this.background.toJSON(meta).uuid)), this.environment && this.environment.isTexture && (object.environment = this.environment.toJSON(meta).uuid);
					else if (this.isMesh || this.isLine || this.isPoints) {
						object.geometry = e(meta.geometries, this.geometry);
						const t = this.geometry.parameters;
						if (void 0 !== t && void 0 !== t.shapes) {
							const n = t.shapes;
							if (Array.isArray(n))
								for (let i = 0, t = n.length; i < t; i++) {
									const t = n[i];
									e(meta.shapes, t)
								} else e(meta.shapes, n)
						}
					}
					if (this.isSkinnedMesh && (object.bindMode = this.bindMode, object.bindMatrix = this.bindMatrix.toArray(), void 0 !== this.skeleton && (e(meta.skeletons, this.skeleton), object.skeleton = this.skeleton.uuid)), void 0 !== this.material)
						if (Array.isArray(this.material)) {
							const t = [];
							for (let i = 0, n = this.material.length; i < n; i++) t.push(e(meta.materials, this.material[i]));
							object.material = t
						} else object.material = e(meta.materials, this.material);
					if (this.children.length > 0) {
						object.children = [];
						for (let i = 0; i < this.children.length; i++) object.children.push(this.children[i].toJSON(meta).object)
					}
					if (this.animations.length > 0) {
						object.animations = [];
						for (let i = 0; i < this.animations.length; i++) {
							const t = this.animations[i];
							object.animations.push(e(meta.animations, t))
						}
					}
					if (t) {
						const t = n(meta.geometries),
							e = n(meta.materials),
							r = n(meta.textures),
							o = n(meta.images),
							l = n(meta.shapes),
							c = n(meta.skeletons),
							h = n(meta.animations);
						t.length > 0 && (output.geometries = t), e.length > 0 && (output.materials = e), r.length > 0 && (output.textures = r), o.length > 0 && (output.images = o), l.length > 0 && (output.shapes = l), c.length > 0 && (output.skeletons = c), h.length > 0 && (output.animations = h)
					}
					return output.object = object, output;

					function n(t) {
						const e = [];
						for (const n in t) {
							const data = t[n];
							delete data.metadata, e.push(data)
						}
						return e
					}
				}
				clone(t) {
					return (new this.constructor).copy(this, t)
				}
				copy(source, t = !0) {
					if (this.name = source.name, this.up.copy(source.up), this.position.copy(source.position), this.rotation.order = source.rotation.order, this.quaternion.copy(source.quaternion), this.scale.copy(source.scale), this.matrix.copy(source.matrix), this.matrixWorld.copy(source.matrixWorld), this.matrixAutoUpdate = source.matrixAutoUpdate, this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate, this.layers.mask = source.layers.mask, this.visible = source.visible, this.castShadow = source.castShadow, this.receiveShadow = source.receiveShadow, this.frustumCulled = source.frustumCulled, this.renderOrder = source.renderOrder, this.userData = JSON.parse(JSON.stringify(source.userData)), !0 === t)
						for (let i = 0; i < source.children.length; i++) {
							const t = source.children[i];
							this.add(t.clone())
						}
					return this
				}
			}
			on.DefaultUp = new re(0, 1, 0), on.DefaultMatrixAutoUpdate = !0, on.prototype.isObject3D = !0;
			const ln = new re,
				cn = new re,
				hn = new re,
				un = new re,
				dn = new re,
				pn = new re,
				fn = new re,
				mn = new re,
				gn = new re,
				vn = new re;
			class yn {
				constructor(a = new re, b = new re, t = new re) {
					this.a = a, this.b = b, this.c = t
				}
				static getNormal(a, b, t, e) {
					e.subVectors(t, b), ln.subVectors(a, b), e.cross(ln);
					const n = e.lengthSq();
					return n > 0 ? e.multiplyScalar(1 / Math.sqrt(n)) : e.set(0, 0, 0)
				}
				static getBarycoord(t, a, b, e, n) {
					ln.subVectors(e, a), cn.subVectors(b, a), hn.subVectors(t, a);
					const r = ln.dot(ln),
						o = ln.dot(cn),
						l = ln.dot(hn),
						c = cn.dot(cn),
						h = cn.dot(hn),
						d = r * c - o * o;
					if (0 === d) return n.set(-2, -1, -1);
					const f = 1 / d,
						u = (c * l - o * h) * f,
						m = (r * h - o * l) * f;
					return n.set(1 - u - m, m, u)
				}
				static containsPoint(t, a, b, e) {
					return this.getBarycoord(t, a, b, e, un), un.x >= 0 && un.y >= 0 && un.x + un.y <= 1
				}
				static getUV(t, e, n, r, o, l, c, h) {
					return this.getBarycoord(t, e, n, r, un), h.set(0, 0), h.addScaledVector(o, un.x), h.addScaledVector(l, un.y), h.addScaledVector(c, un.z), h
				}
				static isFrontFacing(a, b, t, e) {
					return ln.subVectors(t, b), cn.subVectors(a, b), ln.cross(cn).dot(e) < 0
				}
				set(a, b, t) {
					return this.a.copy(a), this.b.copy(b), this.c.copy(t), this
				}
				setFromPointsAndIndices(t, e, n, r) {
					return this.a.copy(t[e]), this.b.copy(t[n]), this.c.copy(t[r]), this
				}
				setFromAttributeAndIndices(t, e, n, r) {
					return this.a.fromBufferAttribute(t, e), this.b.fromBufferAttribute(t, n), this.c.fromBufferAttribute(t, r), this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(t) {
					return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
				}
				getArea() {
					return ln.subVectors(this.c, this.b), cn.subVectors(this.a, this.b), .5 * ln.cross(cn).length()
				}
				getMidpoint(t) {
					return t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
				}
				getNormal(t) {
					return yn.getNormal(this.a, this.b, this.c, t)
				}
				getPlane(t) {
					return t.setFromCoplanarPoints(this.a, this.b, this.c)
				}
				getBarycoord(t, e) {
					return yn.getBarycoord(t, this.a, this.b, this.c, e)
				}
				getUV(t, e, n, r, o) {
					return yn.getUV(t, this.a, this.b, this.c, e, n, r, o)
				}
				containsPoint(t) {
					return yn.containsPoint(t, this.a, this.b, this.c)
				}
				isFrontFacing(t) {
					return yn.isFrontFacing(this.a, this.b, this.c, t)
				}
				intersectsBox(t) {
					return t.intersectsTriangle(this)
				}
				closestPointToPoint(p, t) {
					const a = this.a,
						b = this.b,
						e = this.c;
					let n, r;
					dn.subVectors(b, a), pn.subVectors(e, a), mn.subVectors(p, a);
					const o = dn.dot(mn),
						l = pn.dot(mn);
					if (o <= 0 && l <= 0) return t.copy(a);
					gn.subVectors(p, b);
					const c = dn.dot(gn),
						h = pn.dot(gn);
					if (c >= 0 && h <= c) return t.copy(b);
					const d = o * h - c * l;
					if (d <= 0 && o >= 0 && c <= 0) return n = o / (o - c), t.copy(a).addScaledVector(dn, n);
					vn.subVectors(p, e);
					const f = dn.dot(vn),
						m = pn.dot(vn);
					if (m >= 0 && f <= m) return t.copy(e);
					const v = f * l - o * m;
					if (v <= 0 && l >= 0 && m <= 0) return r = l / (l - m), t.copy(a).addScaledVector(pn, r);
					const y = c * m - f * h;
					if (y <= 0 && h - c >= 0 && f - m >= 0) return fn.subVectors(e, b), r = (h - c) / (h - c + (f - m)), t.copy(b).addScaledVector(fn, r);
					const x = 1 / (y + v + d);
					return n = v * x, r = d * x, t.copy(a).addScaledVector(dn, n).addScaledVector(pn, r)
				}
				equals(t) {
					return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
				}
			}
			let xn = 0;
			class _n extends St {
				constructor() {
					super(), Object.defineProperty(this, "id", {
						value: xn++
					}), this.uuid = Dt(), this.name = "", this.type = "Material", this.fog = !0, this.blending = 1, this.side = o, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = d, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.depthFunc = y, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = 519, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = _t, this.stencilZFail = _t, this.stencilZPass = _t, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
				}
				get alphaTest() {
					return this._alphaTest
				}
				set alphaTest(t) {
					this._alphaTest > 0 != t > 0 && this.version++, this._alphaTest = t
				}
				onBuild() {}
				onBeforeRender() {}
				onBeforeCompile() {}
				customProgramCacheKey() {
					return this.onBeforeCompile.toString()
				}
				setValues(t) {
					if (void 0 !== t)
						for (const e in t) {
							const n = t[e];
							if (void 0 === n) {
								console.warn("THREE.Material: '" + e + "' parameter is undefined.");
								continue
							}
							if ("shading" === e) {
								console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === n;
								continue
							}
							const r = this[e];
							void 0 !== r ? r && r.isColor ? r.set(n) : r && r.isVector3 && n && n.isVector3 ? r.copy(n) : this[e] = n : console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.")
						}
				}
				toJSON(meta) {
					const t = void 0 === meta || "string" == typeof meta;
					t && (meta = {
						textures: {},
						images: {}
					});
					const data = {
						metadata: {
							version: 4.5,
							type: "Material",
							generator: "Material.toJSON"
						}
					};

					function e(t) {
						const e = [];
						for (const n in t) {
							const data = t[n];
							delete data.metadata, e.push(data)
						}
						return e
					}
					if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), this.color && this.color.isColor && (data.color = this.color.getHex()), void 0 !== this.roughness && (data.roughness = this.roughness), void 0 !== this.metalness && (data.metalness = this.metalness), void 0 !== this.sheen && (data.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (data.sheenColor = this.sheenColor.getHex()), void 0 !== this.sheenRoughness && (data.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (data.emissive = this.emissive.getHex()), this.emissiveIntensity && 1 !== this.emissiveIntensity && (data.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (data.specular = this.specular.getHex()), void 0 !== this.specularIntensity && (data.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (data.specularColor = this.specularColor.getHex()), void 0 !== this.shininess && (data.shininess = this.shininess), void 0 !== this.clearcoat && (data.clearcoat = this.clearcoat), void 0 !== this.clearcoatRoughness && (data.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid, data.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.map && this.map.isTexture && (data.map = this.map.toJSON(meta).uuid), this.matcap && this.matcap.isTexture && (data.matcap = this.matcap.toJSON(meta).uuid), this.alphaMap && this.alphaMap.isTexture && (data.alphaMap = this.alphaMap.toJSON(meta).uuid), this.lightMap && this.lightMap.isTexture && (data.lightMap = this.lightMap.toJSON(meta).uuid, data.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (data.aoMap = this.aoMap.toJSON(meta).uuid, data.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (data.bumpMap = this.bumpMap.toJSON(meta).uuid, data.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (data.normalMap = this.normalMap.toJSON(meta).uuid, data.normalMapType = this.normalMapType, data.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (data.displacementMap = this.displacementMap.toJSON(meta).uuid, data.displacementScale = this.displacementScale, data.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (data.roughnessMap = this.roughnessMap.toJSON(meta).uuid), this.metalnessMap && this.metalnessMap.isTexture && (data.metalnessMap = this.metalnessMap.toJSON(meta).uuid), this.emissiveMap && this.emissiveMap.isTexture && (data.emissiveMap = this.emissiveMap.toJSON(meta).uuid), this.specularMap && this.specularMap.isTexture && (data.specularMap = this.specularMap.toJSON(meta).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid), this.specularColorMap && this.specularColorMap.isTexture && (data.specularColorMap = this.specularColorMap.toJSON(meta).uuid), this.envMap && this.envMap.isTexture && (data.envMap = this.envMap.toJSON(meta).uuid, void 0 !== this.combine && (data.combine = this.combine)), void 0 !== this.envMapIntensity && (data.envMapIntensity = this.envMapIntensity), void 0 !== this.reflectivity && (data.reflectivity = this.reflectivity), void 0 !== this.refractionRatio && (data.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (data.gradientMap = this.gradientMap.toJSON(meta).uuid), void 0 !== this.transmission && (data.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (data.transmissionMap = this.transmissionMap.toJSON(meta).uuid), void 0 !== this.thickness && (data.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (data.thicknessMap = this.thicknessMap.toJSON(meta).uuid), void 0 !== this.attenuationDistance && (data.attenuationDistance = this.attenuationDistance), void 0 !== this.attenuationColor && (data.attenuationColor = this.attenuationColor.getHex()), void 0 !== this.size && (data.size = this.size), null !== this.shadowSide && (data.shadowSide = this.shadowSide), void 0 !== this.sizeAttenuation && (data.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (data.blending = this.blending), this.side !== o && (data.side = this.side), this.vertexColors && (data.vertexColors = !0), this.opacity < 1 && (data.opacity = this.opacity), !0 === this.transparent && (data.transparent = this.transparent), data.depthFunc = this.depthFunc, data.depthTest = this.depthTest, data.depthWrite = this.depthWrite, data.colorWrite = this.colorWrite, data.stencilWrite = this.stencilWrite, data.stencilWriteMask = this.stencilWriteMask, data.stencilFunc = this.stencilFunc, data.stencilRef = this.stencilRef, data.stencilFuncMask = this.stencilFuncMask, data.stencilFail = this.stencilFail, data.stencilZFail = this.stencilZFail, data.stencilZPass = this.stencilZPass, this.rotation && 0 !== this.rotation && (data.rotation = this.rotation), !0 === this.polygonOffset && (data.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (data.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (data.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth && 1 !== this.linewidth && (data.linewidth = this.linewidth), void 0 !== this.dashSize && (data.dashSize = this.dashSize), void 0 !== this.gapSize && (data.gapSize = this.gapSize), void 0 !== this.scale && (data.scale = this.scale), !0 === this.dithering && (data.dithering = !0), this.alphaTest > 0 && (data.alphaTest = this.alphaTest), !0 === this.alphaToCoverage && (data.alphaToCoverage = this.alphaToCoverage), !0 === this.premultipliedAlpha && (data.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (data.wireframe = this.wireframe), this.wireframeLinewidth > 1 && (data.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (data.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (data.wireframeLinejoin = this.wireframeLinejoin), !0 === this.flatShading && (data.flatShading = this.flatShading), !1 === this.visible && (data.visible = !1), !1 === this.toneMapped && (data.toneMapped = !1), "{}" !== JSON.stringify(this.userData) && (data.userData = this.userData), t) {
						const t = e(meta.textures),
							n = e(meta.images);
						t.length > 0 && (data.textures = t), n.length > 0 && (data.images = n)
					}
					return data
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(source) {
					this.name = source.name, this.fog = source.fog, this.blending = source.blending, this.side = source.side, this.vertexColors = source.vertexColors, this.opacity = source.opacity, this.transparent = source.transparent, this.blendSrc = source.blendSrc, this.blendDst = source.blendDst, this.blendEquation = source.blendEquation, this.blendSrcAlpha = source.blendSrcAlpha, this.blendDstAlpha = source.blendDstAlpha, this.blendEquationAlpha = source.blendEquationAlpha, this.depthFunc = source.depthFunc, this.depthTest = source.depthTest, this.depthWrite = source.depthWrite, this.stencilWriteMask = source.stencilWriteMask, this.stencilFunc = source.stencilFunc, this.stencilRef = source.stencilRef, this.stencilFuncMask = source.stencilFuncMask, this.stencilFail = source.stencilFail, this.stencilZFail = source.stencilZFail, this.stencilZPass = source.stencilZPass, this.stencilWrite = source.stencilWrite;
					const t = source.clippingPlanes;
					let e = null;
					if (null !== t) {
						const n = t.length;
						e = new Array(n);
						for (let i = 0; i !== n; ++i) e[i] = t[i].clone()
					}
					return this.clippingPlanes = e, this.clipIntersection = source.clipIntersection, this.clipShadows = source.clipShadows, this.shadowSide = source.shadowSide, this.colorWrite = source.colorWrite, this.precision = source.precision, this.polygonOffset = source.polygonOffset, this.polygonOffsetFactor = source.polygonOffsetFactor, this.polygonOffsetUnits = source.polygonOffsetUnits, this.dithering = source.dithering, this.alphaTest = source.alphaTest, this.alphaToCoverage = source.alphaToCoverage, this.premultipliedAlpha = source.premultipliedAlpha, this.visible = source.visible, this.toneMapped = source.toneMapped, this.userData = JSON.parse(JSON.stringify(source.userData)), this
				}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
				set needsUpdate(t) {
					!0 === t && this.version++
				}
			}
			_n.prototype.isMaterial = !0;
			class wn extends _n {
				constructor(t) {
					super(), this.type = "MeshBasicMaterial", this.color = new Qt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this
				}
			}
			wn.prototype.isMeshBasicMaterial = !0;
			const An = new re,
				bn = new Nt;
			class Mn {
				constructor(t, e, n) {
					if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
					this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === n, this.usage = wt, this.updateRange = {
						offset: 0,
						count: -1
					}, this.version = 0
				}
				onUploadCallback() {}
				set needsUpdate(t) {
					!0 === t && this.version++
				}
				setUsage(t) {
					return this.usage = t, this
				}
				copy(source) {
					return this.name = source.name, this.array = new source.array.constructor(source.array), this.itemSize = source.itemSize, this.count = source.count, this.normalized = source.normalized, this.usage = source.usage, this
				}
				copyAt(t, e, n) {
					t *= this.itemSize, n *= e.itemSize;
					for (let i = 0, r = this.itemSize; i < r; i++) this.array[t + i] = e.array[n + i];
					return this
				}
				copyArray(t) {
					return this.array.set(t), this
				}
				copyColorsArray(t) {
					const e = this.array;
					let n = 0;
					for (let i = 0, r = t.length; i < r; i++) {
						let r = t[i];
						void 0 === r && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", i), r = new Qt), e[n++] = r.r, e[n++] = r.g, e[n++] = r.b
					}
					return this
				}
				copyVector2sArray(t) {
					const e = this.array;
					let n = 0;
					for (let i = 0, r = t.length; i < r; i++) {
						let r = t[i];
						void 0 === r && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", i), r = new Nt), e[n++] = r.x, e[n++] = r.y
					}
					return this
				}
				copyVector3sArray(t) {
					const e = this.array;
					let n = 0;
					for (let i = 0, r = t.length; i < r; i++) {
						let r = t[i];
						void 0 === r && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", i), r = new re), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z
					}
					return this
				}
				copyVector4sArray(t) {
					const e = this.array;
					let n = 0;
					for (let i = 0, r = t.length; i < r; i++) {
						let r = t[i];
						void 0 === r && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", i), r = new te), e[n++] = r.x, e[n++] = r.y, e[n++] = r.z, e[n++] = r.w
					}
					return this
				}
				applyMatrix3(t) {
					if (2 === this.itemSize)
						for (let i = 0, e = this.count; i < e; i++) bn.fromBufferAttribute(this, i), bn.applyMatrix3(t), this.setXY(i, bn.x, bn.y);
					else if (3 === this.itemSize)
						for (let i = 0, e = this.count; i < e; i++) An.fromBufferAttribute(this, i), An.applyMatrix3(t), this.setXYZ(i, An.x, An.y, An.z);
					return this
				}
				applyMatrix4(t) {
					for (let i = 0, e = this.count; i < e; i++) An.x = this.getX(i), An.y = this.getY(i), An.z = this.getZ(i), An.applyMatrix4(t), this.setXYZ(i, An.x, An.y, An.z);
					return this
				}
				applyNormalMatrix(t) {
					for (let i = 0, e = this.count; i < e; i++) An.x = this.getX(i), An.y = this.getY(i), An.z = this.getZ(i), An.applyNormalMatrix(t), this.setXYZ(i, An.x, An.y, An.z);
					return this
				}
				transformDirection(t) {
					for (let i = 0, e = this.count; i < e; i++) An.x = this.getX(i), An.y = this.getY(i), An.z = this.getZ(i), An.transformDirection(t), this.setXYZ(i, An.x, An.y, An.z);
					return this
				}
				set(t, e = 0) {
					return this.array.set(t, e), this
				}
				getX(t) {
					return this.array[t * this.itemSize]
				}
				setX(t, e) {
					return this.array[t * this.itemSize] = e, this
				}
				getY(t) {
					return this.array[t * this.itemSize + 1]
				}
				setY(t, e) {
					return this.array[t * this.itemSize + 1] = e, this
				}
				getZ(t) {
					return this.array[t * this.itemSize + 2]
				}
				setZ(t, e) {
					return this.array[t * this.itemSize + 2] = e, this
				}
				getW(t) {
					return this.array[t * this.itemSize + 3]
				}
				setW(t, e) {
					return this.array[t * this.itemSize + 3] = e, this
				}
				setXY(t, e, n) {
					return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this
				}
				setXYZ(t, e, n, r) {
					return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this
				}
				setXYZW(t, e, n, r, o) {
					return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = n, this.array[t + 2] = r, this.array[t + 3] = o, this
				}
				onUpload(t) {
					return this.onUploadCallback = t, this
				}
				clone() {
					return new this.constructor(this.array, this.itemSize).copy(this)
				}
				toJSON() {
					const data = {
						itemSize: this.itemSize,
						type: this.array.constructor.name,
						array: Array.prototype.slice.call(this.array),
						normalized: this.normalized
					};
					return "" !== this.name && (data.name = this.name), this.usage !== wt && (data.usage = this.usage), 0 === this.updateRange.offset && -1 === this.updateRange.count || (data.updateRange = this.updateRange), data
				}
			}
			Mn.prototype.isBufferAttribute = !0;
			class Sn extends Mn {
				constructor(t, e, n) {
					super(new Uint16Array(t), e, n)
				}
			}
			class Tn extends Mn {
				constructor(t, e, n) {
					super(new Uint32Array(t), e, n)
				}
			}(class extends Mn {
				constructor(t, e, n) {
					super(new Uint16Array(t), e, n)
				}
			}).prototype.isFloat16BufferAttribute = !0;
			class En extends Mn {
				constructor(t, e, n) {
					super(new Float32Array(t), e, n)
				}
			}
			let Cn = 0;
			const Rn = new Oe,
				Dn = new on,
				Ln = new re,
				Pn = new oe,
				In = new oe,
				Bn = new re;
			class On extends St {
				constructor() {
					super(), Object.defineProperty(this, "id", {
						value: Cn++
					}), this.uuid = Dt(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
						start: 0,
						count: 1 / 0
					}, this.userData = {}
				}
				getIndex() {
					return this.index
				}
				setIndex(t) {
					return Array.isArray(t) ? this.index = new(zt(t) ? Tn : Sn)(t, 1) : this.index = t, this
				}
				getAttribute(t) {
					return this.attributes[t]
				}
				setAttribute(t, e) {
					return this.attributes[t] = e, this
				}
				deleteAttribute(t) {
					return delete this.attributes[t], this
				}
				hasAttribute(t) {
					return void 0 !== this.attributes[t]
				}
				addGroup(t, e, n = 0) {
					this.groups.push({
						start: t,
						count: e,
						materialIndex: n
					})
				}
				clearGroups() {
					this.groups = []
				}
				setDrawRange(t, e) {
					this.drawRange.start = t, this.drawRange.count = e
				}
				applyMatrix4(t) {
					const e = this.attributes.position;
					void 0 !== e && (e.applyMatrix4(t), e.needsUpdate = !0);
					const n = this.attributes.normal;
					if (void 0 !== n) {
						const e = (new Ut).getNormalMatrix(t);
						n.applyNormalMatrix(e), n.needsUpdate = !0
					}
					const r = this.attributes.tangent;
					return void 0 !== r && (r.transformDirection(t), r.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
				}
				applyQuaternion(q) {
					return Rn.makeRotationFromQuaternion(q), this.applyMatrix4(Rn), this
				}
				rotateX(t) {
					return Rn.makeRotationX(t), this.applyMatrix4(Rn), this
				}
				rotateY(t) {
					return Rn.makeRotationY(t), this.applyMatrix4(Rn), this
				}
				rotateZ(t) {
					return Rn.makeRotationZ(t), this.applyMatrix4(Rn), this
				}
				translate(t, e, n) {
					return Rn.makeTranslation(t, e, n), this.applyMatrix4(Rn), this
				}
				scale(t, e, n) {
					return Rn.makeScale(t, e, n), this.applyMatrix4(Rn), this
				}
				lookAt(t) {
					return Dn.lookAt(t), Dn.updateMatrix(), this.applyMatrix4(Dn.matrix), this
				}
				center() {
					return this.computeBoundingBox(), this.boundingBox.getCenter(Ln).negate(), this.translate(Ln.x, Ln.y, Ln.z), this
				}
				setFromPoints(t) {
					const e = [];
					for (let i = 0, n = t.length; i < n; i++) {
						const n = t[i];
						e.push(n.x, n.y, n.z || 0)
					}
					return this.setAttribute("position", new En(e, 3)), this
				}
				computeBoundingBox() {
					null === this.boundingBox && (this.boundingBox = new oe);
					const t = this.attributes.position,
						e = this.morphAttributes.position;
					if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingBox.set(new re(-1 / 0, -1 / 0, -1 / 0), new re(1 / 0, 1 / 0, 1 / 0));
					if (void 0 !== t) {
						if (this.boundingBox.setFromBufferAttribute(t), e)
							for (let i = 0, t = e.length; i < t; i++) {
								const t = e[i];
								Pn.setFromBufferAttribute(t), this.morphTargetsRelative ? (Bn.addVectors(this.boundingBox.min, Pn.min), this.boundingBox.expandByPoint(Bn), Bn.addVectors(this.boundingBox.max, Pn.max), this.boundingBox.expandByPoint(Bn)) : (this.boundingBox.expandByPoint(Pn.min), this.boundingBox.expandByPoint(Pn.max))
							}
					} else this.boundingBox.makeEmpty();
					(isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
				}
				computeBoundingSphere() {
					null === this.boundingSphere && (this.boundingSphere = new Te);
					const t = this.attributes.position,
						e = this.morphAttributes.position;
					if (t && t.isGLBufferAttribute) return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this), void this.boundingSphere.set(new re, 1 / 0);
					if (t) {
						const n = this.boundingSphere.center;
						if (Pn.setFromBufferAttribute(t), e)
							for (let i = 0, t = e.length; i < t; i++) {
								const t = e[i];
								In.setFromBufferAttribute(t), this.morphTargetsRelative ? (Bn.addVectors(Pn.min, In.min), Pn.expandByPoint(Bn), Bn.addVectors(Pn.max, In.max), Pn.expandByPoint(Bn)) : (Pn.expandByPoint(In.min), Pn.expandByPoint(In.max))
							}
						Pn.getCenter(n);
						let r = 0;
						for (let i = 0, e = t.count; i < e; i++) Bn.fromBufferAttribute(t, i), r = Math.max(r, n.distanceToSquared(Bn));
						if (e)
							for (let i = 0, o = e.length; i < o; i++) {
								const o = e[i],
									l = this.morphTargetsRelative;
								for (let e = 0, c = o.count; e < c; e++) Bn.fromBufferAttribute(o, e), l && (Ln.fromBufferAttribute(t, e), Bn.add(Ln)), r = Math.max(r, n.distanceToSquared(Bn))
							}
						this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
					}
				}
				computeTangents() {
					const t = this.index,
						e = this.attributes;
					if (null === t || void 0 === e.position || void 0 === e.normal || void 0 === e.uv) return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
					const n = t.array,
						r = e.position.array,
						o = e.normal.array,
						l = e.uv.array,
						c = r.length / 3;
					void 0 === e.tangent && this.setAttribute("tangent", new Mn(new Float32Array(4 * c), 4));
					const h = e.tangent.array,
						d = [],
						f = [];
					for (let i = 0; i < c; i++) d[i] = new re, f[i] = new re;
					const m = new re,
						v = new re,
						y = new re,
						x = new Nt,
						_ = new Nt,
						w = new Nt,
						A = new re,
						M = new re;

					function S(a, b, t) {
						m.fromArray(r, 3 * a), v.fromArray(r, 3 * b), y.fromArray(r, 3 * t), x.fromArray(l, 2 * a), _.fromArray(l, 2 * b), w.fromArray(l, 2 * t), v.sub(m), y.sub(m), _.sub(x), w.sub(x);
						const e = 1 / (_.x * w.y - w.x * _.y);
						isFinite(e) && (A.copy(v).multiplyScalar(w.y).addScaledVector(y, -_.y).multiplyScalar(e), M.copy(y).multiplyScalar(_.x).addScaledVector(v, -w.x).multiplyScalar(e), d[a].add(A), d[b].add(A), d[t].add(A), f[a].add(M), f[b].add(M), f[t].add(M))
					}
					let T = this.groups;
					0 === T.length && (T = [{
						start: 0,
						count: n.length
					}]);
					for (let i = 0, t = T.length; i < t; ++i) {
						const t = T[i],
							e = t.start;
						for (let r = e, o = e + t.count; r < o; r += 3) S(n[r + 0], n[r + 1], n[r + 2])
					}
					const E = new re,
						C = new re,
						R = new re,
						D = new re;

					function L(t) {
						R.fromArray(o, 3 * t), D.copy(R);
						const e = d[t];
						E.copy(e), E.sub(R.multiplyScalar(R.dot(e))).normalize(), C.crossVectors(D, e);
						const n = C.dot(f[t]) < 0 ? -1 : 1;
						h[4 * t] = E.x, h[4 * t + 1] = E.y, h[4 * t + 2] = E.z, h[4 * t + 3] = n
					}
					for (let i = 0, t = T.length; i < t; ++i) {
						const t = T[i],
							e = t.start;
						for (let r = e, o = e + t.count; r < o; r += 3) L(n[r + 0]), L(n[r + 1]), L(n[r + 2])
					}
				}
				computeVertexNormals() {
					const t = this.index,
						e = this.getAttribute("position");
					if (void 0 !== e) {
						let n = this.getAttribute("normal");
						if (void 0 === n) n = new Mn(new Float32Array(3 * e.count), 3), this.setAttribute("normal", n);
						else
							for (let i = 0, t = n.count; i < t; i++) n.setXYZ(i, 0, 0, 0);
						const r = new re,
							o = new re,
							l = new re,
							c = new re,
							h = new re,
							d = new re,
							f = new re,
							m = new re;
						if (t)
							for (let i = 0, v = t.count; i < v; i += 3) {
								const v = t.getX(i + 0),
									y = t.getX(i + 1),
									x = t.getX(i + 2);
								r.fromBufferAttribute(e, v), o.fromBufferAttribute(e, y), l.fromBufferAttribute(e, x), f.subVectors(l, o), m.subVectors(r, o), f.cross(m), c.fromBufferAttribute(n, v), h.fromBufferAttribute(n, y), d.fromBufferAttribute(n, x), c.add(f), h.add(f), d.add(f), n.setXYZ(v, c.x, c.y, c.z), n.setXYZ(y, h.x, h.y, h.z), n.setXYZ(x, d.x, d.y, d.z)
							} else
								for (let i = 0, t = e.count; i < t; i += 3) r.fromBufferAttribute(e, i + 0), o.fromBufferAttribute(e, i + 1), l.fromBufferAttribute(e, i + 2), f.subVectors(l, o), m.subVectors(r, o), f.cross(m), n.setXYZ(i + 0, f.x, f.y, f.z), n.setXYZ(i + 1, f.x, f.y, f.z), n.setXYZ(i + 2, f.x, f.y, f.z);
						this.normalizeNormals(), n.needsUpdate = !0
					}
				}
				merge(t, e) {
					if (!t || !t.isBufferGeometry) return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t);
					void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
					const n = this.attributes;
					for (const r in n) {
						if (void 0 === t.attributes[r]) continue;
						const o = n[r].array,
							l = t.attributes[r],
							c = l.array,
							h = l.itemSize * e,
							d = Math.min(c.length, o.length - h);
						for (let i = 0, t = h; i < d; i++, t++) o[t] = c[i]
					}
					return this
				}
				normalizeNormals() {
					const t = this.attributes.normal;
					for (let i = 0, e = t.count; i < e; i++) Bn.fromBufferAttribute(t, i), Bn.normalize(), t.setXYZ(i, Bn.x, Bn.y, Bn.z)
				}
				toNonIndexed() {
					function t(t, e) {
						const n = t.array,
							r = t.itemSize,
							o = t.normalized,
							l = new n.constructor(e.length * r);
						let c = 0,
							h = 0;
						for (let i = 0, o = e.length; i < o; i++) {
							c = t.isInterleavedBufferAttribute ? e[i] * t.data.stride + t.offset : e[i] * r;
							for (let t = 0; t < r; t++) l[h++] = n[c++]
						}
						return new Mn(l, r, o)
					}
					if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
					const e = new On,
						n = this.index.array,
						r = this.attributes;
					for (const o in r) {
						const l = t(r[o], n);
						e.setAttribute(o, l)
					}
					const o = this.morphAttributes;
					for (const r in o) {
						const l = [],
							c = o[r];
						for (let i = 0, e = c.length; i < e; i++) {
							const e = t(c[i], n);
							l.push(e)
						}
						e.morphAttributes[r] = l
					}
					e.morphTargetsRelative = this.morphTargetsRelative;
					const l = this.groups;
					for (let i = 0, t = l.length; i < t; i++) {
						const t = l[i];
						e.addGroup(t.start, t.count, t.materialIndex)
					}
					return e
				}
				toJSON() {
					const data = {
						metadata: {
							version: 4.5,
							type: "BufferGeometry",
							generator: "BufferGeometry.toJSON"
						}
					};
					if (data.uuid = this.uuid, data.type = this.type, "" !== this.name && (data.name = this.name), Object.keys(this.userData).length > 0 && (data.userData = this.userData), void 0 !== this.parameters) {
						const t = this.parameters;
						for (const e in t) void 0 !== t[e] && (data[e] = t[e]);
						return data
					}
					data.data = {
						attributes: {}
					};
					const t = this.index;
					null !== t && (data.data.index = {
						type: t.array.constructor.name,
						array: Array.prototype.slice.call(t.array)
					});
					const e = this.attributes;
					for (const t in e) {
						const n = e[t];
						data.data.attributes[t] = n.toJSON(data.data)
					}
					const n = {};
					let r = !1;
					for (const t in this.morphAttributes) {
						const e = this.morphAttributes[t],
							o = [];
						for (let i = 0, t = e.length; i < t; i++) {
							const t = e[i];
							o.push(t.toJSON(data.data))
						}
						o.length > 0 && (n[t] = o, r = !0)
					}
					r && (data.data.morphAttributes = n, data.data.morphTargetsRelative = this.morphTargetsRelative);
					const o = this.groups;
					o.length > 0 && (data.data.groups = JSON.parse(JSON.stringify(o)));
					const l = this.boundingSphere;
					return null !== l && (data.data.boundingSphere = {
						center: l.center.toArray(),
						radius: l.radius
					}), data
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(source) {
					this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
					const data = {};
					this.name = source.name;
					const t = source.index;
					null !== t && this.setIndex(t.clone(data));
					const e = source.attributes;
					for (const t in e) {
						const n = e[t];
						this.setAttribute(t, n.clone(data))
					}
					const n = source.morphAttributes;
					for (const t in n) {
						const e = [],
							r = n[t];
						for (let i = 0, t = r.length; i < t; i++) e.push(r[i].clone(data));
						this.morphAttributes[t] = e
					}
					this.morphTargetsRelative = source.morphTargetsRelative;
					const r = source.groups;
					for (let i = 0, t = r.length; i < t; i++) {
						const t = r[i];
						this.addGroup(t.start, t.count, t.materialIndex)
					}
					const o = source.boundingBox;
					null !== o && (this.boundingBox = o.clone());
					const l = source.boundingSphere;
					return null !== l && (this.boundingSphere = l.clone()), this.drawRange.start = source.drawRange.start, this.drawRange.count = source.drawRange.count, this.userData = source.userData, void 0 !== source.parameters && (this.parameters = Object.assign({}, source.parameters)), this
				}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}
			On.prototype.isBufferGeometry = !0;
			const Fn = new Oe,
				Hn = new Be,
				Nn = new Te,
				Un = new re,
				zn = new re,
				kn = new re,
				Gn = new re,
				Vn = new re,
				Wn = new re,
				jn = new re,
				Xn = new re,
				Yn = new re,
				Qn = new Nt,
				qn = new Nt,
				Jn = new Nt,
				Kn = new re,
				Zn = new re;
			class $n extends on {
				constructor(t = new On, e = new wn) {
					super(), this.type = "Mesh", this.geometry = t, this.material = e, this.updateMorphTargets()
				}
				copy(source) {
					return super.copy(source), void 0 !== source.morphTargetInfluences && (this.morphTargetInfluences = source.morphTargetInfluences.slice()), void 0 !== source.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary)), this.material = source.material, this.geometry = source.geometry, this
				}
				updateMorphTargets() {
					const t = this.geometry;
					if (t.isBufferGeometry) {
						const e = t.morphAttributes,
							n = Object.keys(e);
						if (n.length > 0) {
							const t = e[n[0]];
							if (void 0 !== t) {
								this.morphTargetInfluences = [], this.morphTargetDictionary = {};
								for (let e = 0, n = t.length; e < n; e++) {
									const n = t[e].name || String(e);
									this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
								}
							}
						}
					} else {
						const e = t.morphTargets;
						void 0 !== e && e.length > 0 && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
					}
				}
				raycast(t, e) {
					const n = this.geometry,
						r = this.material,
						o = this.matrixWorld;
					if (void 0 === r) return;
					if (null === n.boundingSphere && n.computeBoundingSphere(), Nn.copy(n.boundingSphere), Nn.applyMatrix4(o), !1 === t.ray.intersectsSphere(Nn)) return;
					if (Fn.copy(o).invert(), Hn.copy(t.ray).applyMatrix4(Fn), null !== n.boundingBox && !1 === Hn.intersectsBox(n.boundingBox)) return;
					let l;
					if (n.isBufferGeometry) {
						const o = n.index,
							c = n.attributes.position,
							h = n.morphAttributes.position,
							d = n.morphTargetsRelative,
							f = n.attributes.uv,
							m = n.attributes.uv2,
							v = n.groups,
							y = n.drawRange;
						if (null !== o)
							if (Array.isArray(r))
								for (let i = 0, n = v.length; i < n; i++) {
									const n = v[i],
										x = r[n.materialIndex];
									for (let r = Math.max(n.start, y.start), v = Math.min(o.count, Math.min(n.start + n.count, y.start + y.count)); r < v; r += 3) {
										const a = o.getX(r),
											b = o.getX(r + 1),
											v = o.getX(r + 2);
										l = ti(this, x, t, Hn, c, h, d, f, m, a, b, v), l && (l.faceIndex = Math.floor(r / 3), l.face.materialIndex = n.materialIndex, e.push(l))
									}
								} else {
									for (let i = Math.max(0, y.start), n = Math.min(o.count, y.start + y.count); i < n; i += 3) {
										const a = o.getX(i),
											b = o.getX(i + 1),
											n = o.getX(i + 2);
										l = ti(this, r, t, Hn, c, h, d, f, m, a, b, n), l && (l.faceIndex = Math.floor(i / 3), e.push(l))
									}
								} else if (void 0 !== c)
									if (Array.isArray(r))
										for (let i = 0, n = v.length; i < n; i++) {
											const n = v[i],
												o = r[n.materialIndex];
											for (let r = Math.max(n.start, y.start), v = Math.min(c.count, Math.min(n.start + n.count, y.start + y.count)); r < v; r += 3) {
												l = ti(this, o, t, Hn, c, h, d, f, m, r, r + 1, r + 2), l && (l.faceIndex = Math.floor(r / 3), l.face.materialIndex = n.materialIndex, e.push(l))
											}
										} else {
											for (let i = Math.max(0, y.start), n = Math.min(c.count, y.start + y.count); i < n; i += 3) {
												l = ti(this, r, t, Hn, c, h, d, f, m, i, i + 1, i + 2), l && (l.faceIndex = Math.floor(i / 3), e.push(l))
											}
										}
					} else n.isGeometry && console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				}
			}

			function ti(object, t, e, n, r, o, h, d, f, a, b, m) {
				Un.fromBufferAttribute(r, a), zn.fromBufferAttribute(r, b), kn.fromBufferAttribute(r, m);
				const v = object.morphTargetInfluences;
				if (o && v) {
					jn.set(0, 0, 0), Xn.set(0, 0, 0), Yn.set(0, 0, 0);
					for (let i = 0, t = o.length; i < t; i++) {
						const t = v[i],
							e = o[i];
						0 !== t && (Gn.fromBufferAttribute(e, a), Vn.fromBufferAttribute(e, b), Wn.fromBufferAttribute(e, m), h ? (jn.addScaledVector(Gn, t), Xn.addScaledVector(Vn, t), Yn.addScaledVector(Wn, t)) : (jn.addScaledVector(Gn.sub(Un), t), Xn.addScaledVector(Vn.sub(zn), t), Yn.addScaledVector(Wn.sub(kn), t)))
					}
					Un.add(jn), zn.add(Xn), kn.add(Yn)
				}
				object.isSkinnedMesh && (object.boneTransform(a, Un), object.boneTransform(b, zn), object.boneTransform(m, kn));
				const y = function(object, t, e, n, r, o, h, d) {
					let f;
					if (f = t.side === l ? n.intersectTriangle(h, o, r, !0, d) : n.intersectTriangle(r, o, h, t.side !== c, d), null === f) return null;
					Zn.copy(d), Zn.applyMatrix4(object.matrixWorld);
					const m = e.ray.origin.distanceTo(Zn);
					return m < e.near || m > e.far ? null : {
						distance: m,
						point: Zn.clone(),
						object: object
					}
				}(object, t, e, n, Un, zn, kn, Kn);
				if (y) {
					d && (Qn.fromBufferAttribute(d, a), qn.fromBufferAttribute(d, b), Jn.fromBufferAttribute(d, m), y.uv = yn.getUV(Kn, Un, zn, kn, Qn, qn, Jn, new Nt)), f && (Qn.fromBufferAttribute(f, a), qn.fromBufferAttribute(f, b), Jn.fromBufferAttribute(f, m), y.uv2 = yn.getUV(Kn, Un, zn, kn, Qn, qn, Jn, new Nt));
					const t = {
						a: a,
						b: b,
						c: m,
						normal: new re,
						materialIndex: 0
					};
					yn.getNormal(Un, zn, kn, t.normal), y.face = t
				}
				return y
			}
			$n.prototype.isMesh = !0;
			class ei extends On {
				constructor(t = 1, e = 1, n = 1, r = 1, o = 1, l = 1) {
					super(), this.type = "BoxGeometry", this.parameters = {
						width: t,
						height: e,
						depth: n,
						widthSegments: r,
						heightSegments: o,
						depthSegments: l
					};
					const c = this;
					r = Math.floor(r), o = Math.floor(o), l = Math.floor(l);
					const h = [],
						d = [],
						f = [],
						m = [];
					let v = 0,
						y = 0;

					function x(u, t, e, n, r, o, l, x, _, w, A) {
						const M = o / _,
							S = l / w,
							T = o / 2,
							E = l / 2,
							C = x / 2,
							R = _ + 1,
							D = w + 1;
						let L = 0,
							P = 0;
						const I = new re;
						for (let o = 0; o < D; o++) {
							const l = o * S - E;
							for (let c = 0; c < R; c++) {
								const h = c * M - T;
								I[u] = h * n, I[t] = l * r, I[e] = C, d.push(I.x, I.y, I.z), I[u] = 0, I[t] = 0, I[e] = x > 0 ? 1 : -1, f.push(I.x, I.y, I.z), m.push(c / _), m.push(1 - o / w), L += 1
							}
						}
						for (let t = 0; t < w; t++)
							for (let e = 0; e < _; e++) {
								const a = v + e + R * t,
									b = v + e + R * (t + 1),
									n = v + (e + 1) + R * (t + 1),
									r = v + (e + 1) + R * t;
								h.push(a, b, r), h.push(b, n, r), P += 6
							}
						c.addGroup(y, P, A), y += P, v += L
					}
					x("z", "y", "x", -1, -1, n, e, t, l, o, 0), x("z", "y", "x", 1, -1, n, e, -t, l, o, 1), x("x", "z", "y", 1, 1, t, n, e, r, l, 2), x("x", "z", "y", 1, -1, t, n, -e, r, l, 3), x("x", "y", "z", 1, -1, t, e, n, r, o, 4), x("x", "y", "z", -1, -1, t, e, -n, r, o, 5), this.setIndex(h), this.setAttribute("position", new En(d, 3)), this.setAttribute("normal", new En(f, 3)), this.setAttribute("uv", new En(m, 2))
				}
				static fromJSON(data) {
					return new ei(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments)
				}
			}

			function ni(t) {
				const e = {};
				for (const u in t) {
					e[u] = {};
					for (const p in t[u]) {
						const n = t[u][p];
						n && (n.isColor || n.isMatrix3 || n.isMatrix4 || n.isVector2 || n.isVector3 || n.isVector4 || n.isTexture || n.isQuaternion) ? e[u][p] = n.clone() : Array.isArray(n) ? e[u][p] = n.slice() : e[u][p] = n
					}
				}
				return e
			}

			function ii(t) {
				const e = {};
				for (let u = 0; u < t.length; u++) {
					const n = ni(t[u]);
					for (const p in n) e[p] = n[p]
				}
				return e
			}
			const ri = {
				clone: ni,
				merge: ii
			};
			class si extends _n {
				constructor(t) {
					super(), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.extensions = {
						derivatives: !1,
						fragDepth: !1,
						drawBuffers: !1,
						shaderTextureLOD: !1
					}, this.defaultAttributeValues = {
						color: [1, 1, 1],
						uv: [0, 0],
						uv2: [0, 0]
					}, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
				}
				copy(source) {
					return super.copy(source), this.fragmentShader = source.fragmentShader, this.vertexShader = source.vertexShader, this.uniforms = ni(source.uniforms), this.defines = Object.assign({}, source.defines), this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.lights = source.lights, this.clipping = source.clipping, this.extensions = Object.assign({}, source.extensions), this.glslVersion = source.glslVersion, this
				}
				toJSON(meta) {
					const data = super.toJSON(meta);
					data.glslVersion = this.glslVersion, data.uniforms = {};
					for (const t in this.uniforms) {
						const e = this.uniforms[t].value;
						e && e.isTexture ? data.uniforms[t] = {
							type: "t",
							value: e.toJSON(meta).uuid
						} : e && e.isColor ? data.uniforms[t] = {
							type: "c",
							value: e.getHex()
						} : e && e.isVector2 ? data.uniforms[t] = {
							type: "v2",
							value: e.toArray()
						} : e && e.isVector3 ? data.uniforms[t] = {
							type: "v3",
							value: e.toArray()
						} : e && e.isVector4 ? data.uniforms[t] = {
							type: "v4",
							value: e.toArray()
						} : e && e.isMatrix3 ? data.uniforms[t] = {
							type: "m3",
							value: e.toArray()
						} : e && e.isMatrix4 ? data.uniforms[t] = {
							type: "m4",
							value: e.toArray()
						} : data.uniforms[t] = {
							value: e
						}
					}
					Object.keys(this.defines).length > 0 && (data.defines = this.defines), data.vertexShader = this.vertexShader, data.fragmentShader = this.fragmentShader;
					const t = {};
					for (const e in this.extensions) !0 === this.extensions[e] && (t[e] = !0);
					return Object.keys(t).length > 0 && (data.extensions = t), data
				}
			}
			si.prototype.isShaderMaterial = !0;
			class ai extends on {
				constructor() {
					super(), this.type = "Camera", this.matrixWorldInverse = new Oe, this.projectionMatrix = new Oe, this.projectionMatrixInverse = new Oe
				}
				copy(source, t) {
					return super.copy(source, t), this.matrixWorldInverse.copy(source.matrixWorldInverse), this.projectionMatrix.copy(source.projectionMatrix), this.projectionMatrixInverse.copy(source.projectionMatrixInverse), this
				}
				getWorldDirection(t) {
					this.updateWorldMatrix(!0, !1);
					const e = this.matrixWorld.elements;
					return t.set(-e[8], -e[9], -e[10]).normalize()
				}
				updateMatrixWorld(t) {
					super.updateMatrixWorld(t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
				}
				updateWorldMatrix(t, e) {
					super.updateWorldMatrix(t, e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			ai.prototype.isCamera = !0;
			class oi extends ai {
				constructor(t = 50, e = 1, n = .1, r = 2e3) {
					super(), this.type = "PerspectiveCamera", this.fov = t, this.zoom = 1, this.near = n, this.far = r, this.focus = 10, this.aspect = e, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
				}
				copy(source, t) {
					return super.copy(source, t), this.fov = source.fov, this.zoom = source.zoom, this.near = source.near, this.far = source.far, this.focus = source.focus, this.aspect = source.aspect, this.view = null === source.view ? null : Object.assign({}, source.view), this.filmGauge = source.filmGauge, this.filmOffset = source.filmOffset, this
				}
				setFocalLength(t) {
					const e = .5 * this.getFilmHeight() / t;
					this.fov = 2 * Rt * Math.atan(e), this.updateProjectionMatrix()
				}
				getFocalLength() {
					const t = Math.tan(.5 * Ct * this.fov);
					return .5 * this.getFilmHeight() / t
				}
				getEffectiveFOV() {
					return 2 * Rt * Math.atan(Math.tan(.5 * Ct * this.fov) / this.zoom)
				}
				getFilmWidth() {
					return this.filmGauge * Math.min(this.aspect, 1)
				}
				getFilmHeight() {
					return this.filmGauge / Math.max(this.aspect, 1)
				}
				setViewOffset(t, e, n, r, o, l) {
					this.aspect = t / e, null === this.view && (this.view = {
						enabled: !0,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1
					}), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = o, this.view.height = l, this.updateProjectionMatrix()
				}
				clearViewOffset() {
					null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
				}
				updateProjectionMatrix() {
					const t = this.near;
					let e = t * Math.tan(.5 * Ct * this.fov) / this.zoom,
						n = 2 * e,
						r = this.aspect * n,
						o = -.5 * r;
					const view = this.view;
					if (null !== this.view && this.view.enabled) {
						const t = view.fullWidth,
							l = view.fullHeight;
						o += view.offsetX * r / t, e -= view.offsetY * n / l, r *= view.width / t, n *= view.height / l
					}
					const l = this.filmOffset;
					0 !== l && (o += t * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(o, o + r, e, e - n, t, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
				}
				toJSON(meta) {
					const data = super.toJSON(meta);
					return data.object.fov = this.fov, data.object.zoom = this.zoom, data.object.near = this.near, data.object.far = this.far, data.object.focus = this.focus, data.object.aspect = this.aspect, null !== this.view && (data.object.view = Object.assign({}, this.view)), data.object.filmGauge = this.filmGauge, data.object.filmOffset = this.filmOffset, data
				}
			}
			oi.prototype.isPerspectiveCamera = !0;
			const ci = 90;
			class hi extends on {
				constructor(t, e, n) {
					if (super(), this.type = "CubeCamera", !0 !== n.isWebGLCubeRenderTarget) return void console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");
					this.renderTarget = n;
					const r = new oi(ci, 1, t, e);
					r.layers = this.layers, r.up.set(0, -1, 0), r.lookAt(new re(1, 0, 0)), this.add(r);
					const o = new oi(ci, 1, t, e);
					o.layers = this.layers, o.up.set(0, -1, 0), o.lookAt(new re(-1, 0, 0)), this.add(o);
					const l = new oi(ci, 1, t, e);
					l.layers = this.layers, l.up.set(0, 0, 1), l.lookAt(new re(0, 1, 0)), this.add(l);
					const c = new oi(ci, 1, t, e);
					c.layers = this.layers, c.up.set(0, 0, -1), c.lookAt(new re(0, -1, 0)), this.add(c);
					const h = new oi(ci, 1, t, e);
					h.layers = this.layers, h.up.set(0, -1, 0), h.lookAt(new re(0, 0, 1)), this.add(h);
					const d = new oi(ci, 1, t, e);
					d.layers = this.layers, d.up.set(0, -1, 0), d.lookAt(new re(0, 0, -1)), this.add(d)
				}
				update(t, e) {
					null === this.parent && this.updateMatrixWorld();
					const n = this.renderTarget,
						[r, o, l, c, h, d] = this.children,
						f = t.xr.enabled,
						m = t.getRenderTarget();
					t.xr.enabled = !1;
					const v = n.texture.generateMipmaps;
					n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, r), t.setRenderTarget(n, 1), t.render(e, o), t.setRenderTarget(n, 2), t.render(e, l), t.setRenderTarget(n, 3), t.render(e, c), t.setRenderTarget(n, 4), t.render(e, h), n.texture.generateMipmaps = v, t.setRenderTarget(n, 5), t.render(e, d), t.setRenderTarget(m), t.xr.enabled = f, n.texture.needsPMREMUpdate = !0
				}
			}
			class ui extends Zt {
				constructor(t, e, n, r, o, l, c, h, d, f) {
					super(t = void 0 !== t ? t : [], e = void 0 !== e ? e : M, n, r, o, l, c, h, d, f), this.flipY = !1
				}
				get images() {
					return this.image
				}
				set images(t) {
					this.image = t
				}
			}
			ui.prototype.isCubeTexture = !0;
			class di extends ee {
				constructor(t, e, n) {
					Number.isInteger(e) && (console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"), e = n), super(t, t, e), e = e || {}, this.texture = new ui(void 0, e.mapping, e.wrapS, e.wrapT, e.magFilter, e.minFilter, e.format, e.type, e.anisotropy, e.encoding), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = void 0 !== e.generateMipmaps && e.generateMipmaps, this.texture.minFilter = void 0 !== e.minFilter ? e.minFilter : F
				}
				fromEquirectangularTexture(t, e) {
					this.texture.type = e.type, this.texture.format = Y, this.texture.encoding = e.encoding, this.texture.generateMipmaps = e.generateMipmaps, this.texture.minFilter = e.minFilter, this.texture.magFilter = e.magFilter;
					const n = {
							uniforms: {
								tEquirect: {
									value: null
								}
							},
							vertexShader: "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
							fragmentShader: "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t"
						},
						r = new ei(5, 5, 5),
						o = new si({
							name: "CubemapFromEquirect",
							uniforms: ni(n.uniforms),
							vertexShader: n.vertexShader,
							fragmentShader: n.fragmentShader,
							side: l,
							blending: h
						});
					o.uniforms.tEquirect.value = e;
					const c = new $n(r, o),
						d = e.minFilter;
					e.minFilter === N && (e.minFilter = F);
					return new hi(1, 10, this).update(t, c), e.minFilter = d, c.geometry.dispose(), c.material.dispose(), this
				}
				clear(t, e, n, r) {
					const o = t.getRenderTarget();
					for (let i = 0; i < 6; i++) t.setRenderTarget(this, i), t.clear(e, n, r);
					t.setRenderTarget(o)
				}
			}
			di.prototype.isWebGLCubeRenderTarget = !0;
			const pi = new re,
				fi = new re,
				mi = new Ut;
			class gi {
				constructor(t = new re(1, 0, 0), e = 0) {
					this.normal = t, this.constant = e
				}
				set(t, e) {
					return this.normal.copy(t), this.constant = e, this
				}
				setComponents(t, e, n, r) {
					return this.normal.set(t, e, n), this.constant = r, this
				}
				setFromNormalAndCoplanarPoint(t, e) {
					return this.normal.copy(t), this.constant = -e.dot(this.normal), this
				}
				setFromCoplanarPoints(a, b, t) {
					const e = pi.subVectors(t, b).cross(fi.subVectors(a, b)).normalize();
					return this.setFromNormalAndCoplanarPoint(e, a), this
				}
				copy(t) {
					return this.normal.copy(t.normal), this.constant = t.constant, this
				}
				normalize() {
					const t = 1 / this.normal.length();
					return this.normal.multiplyScalar(t), this.constant *= t, this
				}
				negate() {
					return this.constant *= -1, this.normal.negate(), this
				}
				distanceToPoint(t) {
					return this.normal.dot(t) + this.constant
				}
				distanceToSphere(t) {
					return this.distanceToPoint(t.center) - t.radius
				}
				projectPoint(t, e) {
					return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
				}
				intersectLine(line, t) {
					const e = line.delta(pi),
						n = this.normal.dot(e);
					if (0 === n) return 0 === this.distanceToPoint(line.start) ? t.copy(line.start) : null;
					const r = -(line.start.dot(this.normal) + this.constant) / n;
					return r < 0 || r > 1 ? null : t.copy(e).multiplyScalar(r).add(line.start)
				}
				intersectsLine(line) {
					const t = this.distanceToPoint(line.start),
						e = this.distanceToPoint(line.end);
					return t < 0 && e > 0 || e < 0 && t > 0
				}
				intersectsBox(t) {
					return t.intersectsPlane(this)
				}
				intersectsSphere(t) {
					return t.intersectsPlane(this)
				}
				coplanarPoint(t) {
					return t.copy(this.normal).multiplyScalar(-this.constant)
				}
				applyMatrix4(t, e) {
					const n = e || mi.getNormalMatrix(t),
						r = this.coplanarPoint(pi).applyMatrix4(t),
						o = this.normal.applyMatrix3(n).normalize();
					return this.constant = -r.dot(o), this
				}
				translate(t) {
					return this.constant -= t.dot(this.normal), this
				}
				equals(t) {
					return t.normal.equals(this.normal) && t.constant === this.constant
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}
			gi.prototype.isPlane = !0;
			const vi = new Te,
				yi = new re;
			class xi {
				constructor(t = new gi, e = new gi, n = new gi, r = new gi, o = new gi, l = new gi) {
					this.planes = [t, e, n, r, o, l]
				}
				set(t, e, n, r, o, l) {
					const c = this.planes;
					return c[0].copy(t), c[1].copy(e), c[2].copy(n), c[3].copy(r), c[4].copy(o), c[5].copy(l), this
				}
				copy(t) {
					const e = this.planes;
					for (let i = 0; i < 6; i++) e[i].copy(t.planes[i]);
					return this
				}
				setFromProjectionMatrix(t) {
					const e = this.planes,
						n = t.elements,
						r = n[0],
						o = n[1],
						l = n[2],
						c = n[3],
						h = n[4],
						d = n[5],
						f = n[6],
						m = n[7],
						v = n[8],
						y = n[9],
						x = n[10],
						_ = n[11],
						w = n[12],
						A = n[13],
						M = n[14],
						S = n[15];
					return e[0].setComponents(c - r, m - h, _ - v, S - w).normalize(), e[1].setComponents(c + r, m + h, _ + v, S + w).normalize(), e[2].setComponents(c + o, m + d, _ + y, S + A).normalize(), e[3].setComponents(c - o, m - d, _ - y, S - A).normalize(), e[4].setComponents(c - l, m - f, _ - x, S - M).normalize(), e[5].setComponents(c + l, m + f, _ + x, S + M).normalize(), this
				}
				intersectsObject(object) {
					const t = object.geometry;
					return null === t.boundingSphere && t.computeBoundingSphere(), vi.copy(t.boundingSphere).applyMatrix4(object.matrixWorld), this.intersectsSphere(vi)
				}
				intersectsSprite(t) {
					return vi.center.set(0, 0, 0), vi.radius = .7071067811865476, vi.applyMatrix4(t.matrixWorld), this.intersectsSphere(vi)
				}
				intersectsSphere(t) {
					const e = this.planes,
						n = t.center,
						r = -t.radius;
					for (let i = 0; i < 6; i++) {
						if (e[i].distanceToPoint(n) < r) return !1
					}
					return !0
				}
				intersectsBox(t) {
					const e = this.planes;
					for (let i = 0; i < 6; i++) {
						const n = e[i];
						if (yi.x = n.normal.x > 0 ? t.max.x : t.min.x, yi.y = n.normal.y > 0 ? t.max.y : t.min.y, yi.z = n.normal.z > 0 ? t.max.z : t.min.z, n.distanceToPoint(yi) < 0) return !1
					}
					return !0
				}
				containsPoint(t) {
					const e = this.planes;
					for (let i = 0; i < 6; i++)
						if (e[i].distanceToPoint(t) < 0) return !1;
					return !0
				}
				clone() {
					return (new this.constructor).copy(this)
				}
			}

			function _i() {
				let t = null,
					e = !1,
					n = null,
					r = null;

				function o(time, e) {
					n(time, e), r = t.requestAnimationFrame(o)
				}
				return {
					start: function() {
						!0 !== e && null !== n && (r = t.requestAnimationFrame(o), e = !0)
					},
					stop: function() {
						t.cancelAnimationFrame(r), e = !1
					},
					setAnimationLoop: function(t) {
						n = t
					},
					setContext: function(e) {
						t = e
					}
				}
			}

			function wi(t, e) {
				const n = e.isWebGL2,
					r = new WeakMap;
				return {
					get: function(t) {
						return t.isInterleavedBufferAttribute && (t = t.data), r.get(t)
					},
					remove: function(e) {
						e.isInterleavedBufferAttribute && (e = e.data);
						const data = r.get(e);
						data && (t.deleteBuffer(data.buffer), r.delete(e))
					},
					update: function(e, o) {
						if (e.isGLBufferAttribute) {
							const t = r.get(e);
							return void((!t || t.version < e.version) && r.set(e, {
								buffer: e.buffer,
								type: e.type,
								bytesPerElement: e.elementSize,
								version: e.version
							}))
						}
						e.isInterleavedBufferAttribute && (e = e.data);
						const data = r.get(e);
						void 0 === data ? r.set(e, function(e, r) {
							const o = e.array,
								l = e.usage,
								c = t.createBuffer();
							t.bindBuffer(r, c), t.bufferData(r, o, l), e.onUploadCallback();
							let h = 5126;
							return o instanceof Float32Array ? h = 5126 : o instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : o instanceof Uint16Array ? e.isFloat16BufferAttribute ? n ? h = 5131 : console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.") : h = 5123 : o instanceof Int16Array ? h = 5122 : o instanceof Uint32Array ? h = 5125 : o instanceof Int32Array ? h = 5124 : o instanceof Int8Array ? h = 5120 : (o instanceof Uint8Array || o instanceof Uint8ClampedArray) && (h = 5121), {
								buffer: c,
								type: h,
								bytesPerElement: o.BYTES_PER_ELEMENT,
								version: e.version
							}
						}(e, o)) : data.version < e.version && (! function(e, r, o) {
							const l = r.array,
								c = r.updateRange;
							t.bindBuffer(o, e), -1 === c.count ? t.bufferSubData(o, 0, l) : (n ? t.bufferSubData(o, c.offset * l.BYTES_PER_ELEMENT, l, c.offset, c.count) : t.bufferSubData(o, c.offset * l.BYTES_PER_ELEMENT, l.subarray(c.offset, c.offset + c.count)), c.count = -1)
						}(data.buffer, e, o), data.version = e.version)
					}
				}
			}
			class Ai extends On {
				constructor(t = 1, e = 1, n = 1, r = 1) {
					super(), this.type = "PlaneGeometry", this.parameters = {
						width: t,
						height: e,
						widthSegments: n,
						heightSegments: r
					};
					const o = t / 2,
						l = e / 2,
						c = Math.floor(n),
						h = Math.floor(r),
						d = c + 1,
						f = h + 1,
						m = t / c,
						v = e / h,
						y = [],
						x = [],
						_ = [],
						w = [];
					for (let t = 0; t < f; t++) {
						const e = t * v - l;
						for (let n = 0; n < d; n++) {
							const r = n * m - o;
							x.push(r, -e, 0), _.push(0, 0, 1), w.push(n / c), w.push(1 - t / h)
						}
					}
					for (let t = 0; t < h; t++)
						for (let e = 0; e < c; e++) {
							const a = e + d * t,
								b = e + d * (t + 1),
								n = e + 1 + d * (t + 1),
								r = e + 1 + d * t;
							y.push(a, b, r), y.push(b, n, r)
						}
					this.setIndex(y), this.setAttribute("position", new En(x, 3)), this.setAttribute("normal", new En(_, 3)), this.setAttribute("uv", new En(w, 2))
				}
				static fromJSON(data) {
					return new Ai(data.width, data.height, data.widthSegments, data.heightSegments)
				}
			}
			const bi = {
					alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
					alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					alphatest_fragment: "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
					alphatest_pars_fragment: "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
					aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
					aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
					begin_vertex: "vec3 transformed = vec3( position );",
					beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
					bsdfs: "vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
					bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
					clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
					clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
					clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
					clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
					color_fragment: "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
					color_pars_fragment: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
					color_pars_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
					color_vertex: "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
					common: "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
					cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\treturn texture2D( envMap, uv ).rgb;\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
					defaultnormal_vertex: "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
					displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
					displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",
					emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
					emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
					encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
					encodings_pars_fragment: "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
					envmap_fragment: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
					envmap_common_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
					envmap_pars_fragment: "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
					envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
					envmap_physical_pars_fragment: "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec;\n\t\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\t\treflectVec = reflect( - viewDir, normal );\n\t\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\t#else\n\t\t\t\treflectVec = refract( - viewDir, normal, refractionRatio );\n\t\t\t#endif\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
					envmap_vertex: "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
					fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
					fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
					fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
					fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
					gradientmap_pars_fragment: "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}",
					lightmap_fragment: "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tlightMapIrradiance *= PI;\n\t#endif\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
					lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
					lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif",
					lights_pars_begin: "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
					lights_toon_fragment: "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
					lights_toon_pars_fragment: "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
					lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
					lights_phong_pars_fragment: "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
					lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
					lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\tvec3 FssEss = specularColor * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
					lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
					lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
					lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
					logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
					logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
					logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
					logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
					map_fragment: "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
					map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
					map_particle_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
					map_particle_pars_fragment: "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
					metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
					metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
					morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
					morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform vec2 morphTargetsTextureSize;\n\t\tvec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {\n\t\t\tfloat texelIndex = float( vertexIndex * stride + offset );\n\t\t\tfloat y = floor( texelIndex / morphTargetsTextureSize.x );\n\t\t\tfloat x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tvec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );\n\t\t\treturn texture( morphTargetsTexture, morphUV ).xyz;\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
					morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\t#ifndef USE_MORPHNORMALS\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];\n\t\t\t#else\n\t\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];\n\t\t\t#endif\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
					normal_fragment_begin: "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
					normal_fragment_maps: "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
					normal_pars_fragment: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
					normal_pars_vertex: "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
					normal_vertex: "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
					normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
					clearcoat_normal_fragment_begin: "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
					clearcoat_normal_fragment_maps: "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
					clearcoat_pars_fragment: "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",
					output_fragment: "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
					packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
					premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
					project_vertex: "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
					dithering_fragment: "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
					dithering_pars_fragment: "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
					roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
					roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
					shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
					shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
					shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
					shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
					skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
					skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
					skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
					skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
					specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
					specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
					tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
					tonemapping_pars_fragment: "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
					transmission_fragment: "#ifdef USE_TRANSMISSION\n\tfloat transmissionAlpha = 1.0;\n\tfloat transmissionFactor = transmission;\n\tfloat thicknessFactor = thickness;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\ttransmissionFactor *= texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tthicknessFactor *= texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission = getIBLVolumeRefraction(\n\t\tn, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n\t\tattenuationColor, attenuationDistance );\n\ttotalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n\ttransmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif",
					transmission_pars_fragment: "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( attenuationDistance == 0.0 ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
					uv_pars_fragment: "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",
					uv_pars_vertex: "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",
					uv_vertex: "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
					uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
					uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
					uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",
					worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
					background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
					background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor = texture2D( t2D, vUv );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
					cube_frag: "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
					depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
					distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
					distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
					equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
					equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
					linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
					meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
					meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
					meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshnormal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
					meshnormal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
					meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshphysical_vert: "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
					meshphysical_frag: "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					meshtoon_vert: "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					meshtoon_frag: "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
					points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
					points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
					shadow_vert: "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
					shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
					sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
					sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <output_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}"
				},
				Mi = {
					common: {
						diffuse: {
							value: new Qt(16777215)
						},
						opacity: {
							value: 1
						},
						map: {
							value: null
						},
						uvTransform: {
							value: new Ut
						},
						uv2Transform: {
							value: new Ut
						},
						alphaMap: {
							value: null
						},
						alphaTest: {
							value: 0
						}
					},
					specularmap: {
						specularMap: {
							value: null
						}
					},
					envmap: {
						envMap: {
							value: null
						},
						flipEnvMap: {
							value: -1
						},
						reflectivity: {
							value: 1
						},
						ior: {
							value: 1.5
						},
						refractionRatio: {
							value: .98
						}
					},
					aomap: {
						aoMap: {
							value: null
						},
						aoMapIntensity: {
							value: 1
						}
					},
					lightmap: {
						lightMap: {
							value: null
						},
						lightMapIntensity: {
							value: 1
						}
					},
					emissivemap: {
						emissiveMap: {
							value: null
						}
					},
					bumpmap: {
						bumpMap: {
							value: null
						},
						bumpScale: {
							value: 1
						}
					},
					normalmap: {
						normalMap: {
							value: null
						},
						normalScale: {
							value: new Nt(1, 1)
						}
					},
					displacementmap: {
						displacementMap: {
							value: null
						},
						displacementScale: {
							value: 1
						},
						displacementBias: {
							value: 0
						}
					},
					roughnessmap: {
						roughnessMap: {
							value: null
						}
					},
					metalnessmap: {
						metalnessMap: {
							value: null
						}
					},
					gradientmap: {
						gradientMap: {
							value: null
						}
					},
					fog: {
						fogDensity: {
							value: 25e-5
						},
						fogNear: {
							value: 1
						},
						fogFar: {
							value: 2e3
						},
						fogColor: {
							value: new Qt(16777215)
						}
					},
					lights: {
						ambientLightColor: {
							value: []
						},
						lightProbe: {
							value: []
						},
						directionalLights: {
							value: [],
							properties: {
								direction: {},
								color: {}
							}
						},
						directionalLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},
						directionalShadowMap: {
							value: []
						},
						directionalShadowMatrix: {
							value: []
						},
						spotLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								direction: {},
								distance: {},
								coneCos: {},
								penumbraCos: {},
								decay: {}
							}
						},
						spotLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {}
							}
						},
						spotShadowMap: {
							value: []
						},
						spotShadowMatrix: {
							value: []
						},
						pointLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								decay: {},
								distance: {}
							}
						},
						pointLightShadows: {
							value: [],
							properties: {
								shadowBias: {},
								shadowNormalBias: {},
								shadowRadius: {},
								shadowMapSize: {},
								shadowCameraNear: {},
								shadowCameraFar: {}
							}
						},
						pointShadowMap: {
							value: []
						},
						pointShadowMatrix: {
							value: []
						},
						hemisphereLights: {
							value: [],
							properties: {
								direction: {},
								skyColor: {},
								groundColor: {}
							}
						},
						rectAreaLights: {
							value: [],
							properties: {
								color: {},
								position: {},
								width: {},
								height: {}
							}
						},
						ltc_1: {
							value: null
						},
						ltc_2: {
							value: null
						}
					},
					points: {
						diffuse: {
							value: new Qt(16777215)
						},
						opacity: {
							value: 1
						},
						size: {
							value: 1
						},
						scale: {
							value: 1
						},
						map: {
							value: null
						},
						alphaMap: {
							value: null
						},
						alphaTest: {
							value: 0
						},
						uvTransform: {
							value: new Ut
						}
					},
					sprite: {
						diffuse: {
							value: new Qt(16777215)
						},
						opacity: {
							value: 1
						},
						center: {
							value: new Nt(.5, .5)
						},
						rotation: {
							value: 0
						},
						map: {
							value: null
						},
						alphaMap: {
							value: null
						},
						alphaTest: {
							value: 0
						},
						uvTransform: {
							value: new Ut
						}
					}
				},
				Si = {
					basic: {
						uniforms: ii([Mi.common, Mi.specularmap, Mi.envmap, Mi.aomap, Mi.lightmap, Mi.fog]),
						vertexShader: bi.meshbasic_vert,
						fragmentShader: bi.meshbasic_frag
					},
					lambert: {
						uniforms: ii([Mi.common, Mi.specularmap, Mi.envmap, Mi.aomap, Mi.lightmap, Mi.emissivemap, Mi.fog, Mi.lights, {
							emissive: {
								value: new Qt(0)
							}
						}]),
						vertexShader: bi.meshlambert_vert,
						fragmentShader: bi.meshlambert_frag
					},
					phong: {
						uniforms: ii([Mi.common, Mi.specularmap, Mi.envmap, Mi.aomap, Mi.lightmap, Mi.emissivemap, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, Mi.fog, Mi.lights, {
							emissive: {
								value: new Qt(0)
							},
							specular: {
								value: new Qt(1118481)
							},
							shininess: {
								value: 30
							}
						}]),
						vertexShader: bi.meshphong_vert,
						fragmentShader: bi.meshphong_frag
					},
					standard: {
						uniforms: ii([Mi.common, Mi.envmap, Mi.aomap, Mi.lightmap, Mi.emissivemap, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, Mi.roughnessmap, Mi.metalnessmap, Mi.fog, Mi.lights, {
							emissive: {
								value: new Qt(0)
							},
							roughness: {
								value: 1
							},
							metalness: {
								value: 0
							},
							envMapIntensity: {
								value: 1
							}
						}]),
						vertexShader: bi.meshphysical_vert,
						fragmentShader: bi.meshphysical_frag
					},
					toon: {
						uniforms: ii([Mi.common, Mi.aomap, Mi.lightmap, Mi.emissivemap, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, Mi.gradientmap, Mi.fog, Mi.lights, {
							emissive: {
								value: new Qt(0)
							}
						}]),
						vertexShader: bi.meshtoon_vert,
						fragmentShader: bi.meshtoon_frag
					},
					matcap: {
						uniforms: ii([Mi.common, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, Mi.fog, {
							matcap: {
								value: null
							}
						}]),
						vertexShader: bi.meshmatcap_vert,
						fragmentShader: bi.meshmatcap_frag
					},
					points: {
						uniforms: ii([Mi.points, Mi.fog]),
						vertexShader: bi.points_vert,
						fragmentShader: bi.points_frag
					},
					dashed: {
						uniforms: ii([Mi.common, Mi.fog, {
							scale: {
								value: 1
							},
							dashSize: {
								value: 1
							},
							totalSize: {
								value: 2
							}
						}]),
						vertexShader: bi.linedashed_vert,
						fragmentShader: bi.linedashed_frag
					},
					depth: {
						uniforms: ii([Mi.common, Mi.displacementmap]),
						vertexShader: bi.depth_vert,
						fragmentShader: bi.depth_frag
					},
					normal: {
						uniforms: ii([Mi.common, Mi.bumpmap, Mi.normalmap, Mi.displacementmap, {
							opacity: {
								value: 1
							}
						}]),
						vertexShader: bi.meshnormal_vert,
						fragmentShader: bi.meshnormal_frag
					},
					sprite: {
						uniforms: ii([Mi.sprite, Mi.fog]),
						vertexShader: bi.sprite_vert,
						fragmentShader: bi.sprite_frag
					},
					background: {
						uniforms: {
							uvTransform: {
								value: new Ut
							},
							t2D: {
								value: null
							}
						},
						vertexShader: bi.background_vert,
						fragmentShader: bi.background_frag
					},
					cube: {
						uniforms: ii([Mi.envmap, {
							opacity: {
								value: 1
							}
						}]),
						vertexShader: bi.cube_vert,
						fragmentShader: bi.cube_frag
					},
					equirect: {
						uniforms: {
							tEquirect: {
								value: null
							}
						},
						vertexShader: bi.equirect_vert,
						fragmentShader: bi.equirect_frag
					},
					distanceRGBA: {
						uniforms: ii([Mi.common, Mi.displacementmap, {
							referencePosition: {
								value: new re
							},
							nearDistance: {
								value: 1
							},
							farDistance: {
								value: 1e3
							}
						}]),
						vertexShader: bi.distanceRGBA_vert,
						fragmentShader: bi.distanceRGBA_frag
					},
					shadow: {
						uniforms: ii([Mi.lights, Mi.fog, {
							color: {
								value: new Qt(0)
							},
							opacity: {
								value: 1
							}
						}]),
						vertexShader: bi.shadow_vert,
						fragmentShader: bi.shadow_frag
					}
				};

			function Ti(t, e, n, r, c, h) {
				const d = new Qt(0);
				let f, m, v = !0 === c ? 0 : 1,
					y = null,
					x = 0,
					_ = null;

				function w(t, e) {
					n.buffers.color.setClear(t.r, t.g, t.b, e, h)
				}
				return {
					getClearColor: function() {
						return d
					},
					setClearColor: function(t, e = 1) {
						d.set(t), v = e, w(d, v)
					},
					getClearAlpha: function() {
						return v
					},
					setClearAlpha: function(t) {
						v = t, w(d, v)
					},
					render: function(n, c) {
						let h = !1,
							A = !0 === c.isScene ? c.background : null;
						A && A.isTexture && (A = e.get(A));
						const M = t.xr,
							S = M.getSession && M.getSession();
						S && "additive" === S.environmentBlendMode && (A = null), null === A ? w(d, v) : A && A.isColor && (w(A, 1), h = !0), (t.autoClear || h) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), A && (A.isCubeTexture || A.mapping === C) ? (void 0 === m && (m = new $n(new ei(1, 1, 1), new si({
							name: "BackgroundCubeMaterial",
							uniforms: ni(Si.cube.uniforms),
							vertexShader: Si.cube.vertexShader,
							fragmentShader: Si.cube.fragmentShader,
							side: l,
							depthTest: !1,
							depthWrite: !1,
							fog: !1
						})), m.geometry.deleteAttribute("normal"), m.geometry.deleteAttribute("uv"), m.onBeforeRender = function(t, e, n) {
							this.matrixWorld.copyPosition(n.matrixWorld)
						}, Object.defineProperty(m.material, "envMap", {
							get: function() {
								return this.uniforms.envMap.value
							}
						}), r.update(m)), m.material.uniforms.envMap.value = A, m.material.uniforms.flipEnvMap.value = A.isCubeTexture && !1 === A.isRenderTargetTexture ? -1 : 1, y === A && x === A.version && _ === t.toneMapping || (m.material.needsUpdate = !0, y = A, x = A.version, _ = t.toneMapping), n.unshift(m, m.geometry, m.material, 0, 0, null)) : A && A.isTexture && (void 0 === f && (f = new $n(new Ai(2, 2), new si({
							name: "BackgroundMaterial",
							uniforms: ni(Si.background.uniforms),
							vertexShader: Si.background.vertexShader,
							fragmentShader: Si.background.fragmentShader,
							side: o,
							depthTest: !1,
							depthWrite: !1,
							fog: !1
						})), f.geometry.deleteAttribute("normal"), Object.defineProperty(f.material, "map", {
							get: function() {
								return this.uniforms.t2D.value
							}
						}), r.update(f)), f.material.uniforms.t2D.value = A, !0 === A.matrixAutoUpdate && A.updateMatrix(), f.material.uniforms.uvTransform.value.copy(A.matrix), y === A && x === A.version && _ === t.toneMapping || (f.material.needsUpdate = !0, y = A, x = A.version, _ = t.toneMapping), n.unshift(f, f.geometry, f.material, 0, 0, null))
					}
				}
			}

			function Ei(t, e, n, r) {
				const o = t.getParameter(34921),
					l = r.isWebGL2 ? null : e.get("OES_vertex_array_object"),
					c = r.isWebGL2 || null !== l,
					h = {},
					d = y(null);
				let f = d;

				function m(e) {
					return r.isWebGL2 ? t.bindVertexArray(e) : l.bindVertexArrayOES(e)
				}

				function v(e) {
					return r.isWebGL2 ? t.deleteVertexArray(e) : l.deleteVertexArrayOES(e)
				}

				function y(t) {
					const e = [],
						n = [],
						r = [];
					for (let i = 0; i < o; i++) e[i] = 0, n[i] = 0, r[i] = 0;
					return {
						geometry: null,
						program: null,
						wireframe: !1,
						newAttributes: e,
						enabledAttributes: n,
						attributeDivisors: r,
						object: t,
						attributes: {},
						index: null
					}
				}

				function x() {
					const t = f.newAttributes;
					for (let i = 0, e = t.length; i < e; i++) t[i] = 0
				}

				function _(t) {
					w(t, 0)
				}

				function w(n, o) {
					const l = f.newAttributes,
						c = f.enabledAttributes,
						h = f.attributeDivisors;
					if (l[n] = 1, 0 === c[n] && (t.enableVertexAttribArray(n), c[n] = 1), h[n] !== o) {
						(r.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[r.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](n, o), h[n] = o
					}
				}

				function A() {
					const e = f.newAttributes,
						n = f.enabledAttributes;
					for (let i = 0, r = n.length; i < r; i++) n[i] !== e[i] && (t.disableVertexAttribArray(i), n[i] = 0)
				}

				function M(e, n, o, l, c, h) {
					!0 !== r.isWebGL2 || 5124 !== o && 5125 !== o ? t.vertexAttribPointer(e, n, o, l, c, h) : t.vertexAttribIPointer(e, n, o, c, h)
				}

				function S() {
					T(), f !== d && (f = d, m(f.object))
				}

				function T() {
					d.geometry = null, d.program = null, d.wireframe = !1
				}
				return {
					setup: function(object, o, d, v, S) {
						let T = !1;
						if (c) {
							const e = function(e, n, o) {
								const c = !0 === o.wireframe;
								let d = h[e.id];
								void 0 === d && (d = {}, h[e.id] = d);
								let f = d[n.id];
								void 0 === f && (f = {}, d[n.id] = f);
								let m = f[c];
								void 0 === m && (m = y(r.isWebGL2 ? t.createVertexArray() : l.createVertexArrayOES()), f[c] = m);
								return m
							}(v, d, o);
							f !== e && (f = e, m(f.object)), T = function(t, e) {
								const n = f.attributes,
									r = t.attributes;
								let o = 0;
								for (const t in r) {
									const e = n[t],
										l = r[t];
									if (void 0 === e) return !0;
									if (e.attribute !== l) return !0;
									if (e.data !== l.data) return !0;
									o++
								}
								return f.attributesNum !== o || f.index !== e
							}(v, S), T && function(t, e) {
								const n = {},
									r = t.attributes;
								let o = 0;
								for (const t in r) {
									const e = r[t],
										data = {};
									data.attribute = e, e.data && (data.data = e.data), n[t] = data, o++
								}
								f.attributes = n, f.attributesNum = o, f.index = e
							}(v, S)
						} else {
							const t = !0 === o.wireframe;
							f.geometry === v.id && f.program === d.id && f.wireframe === t || (f.geometry = v.id, f.program = d.id, f.wireframe = t, T = !0)
						}!0 === object.isInstancedMesh && (T = !0), null !== S && n.update(S, 34963), T && (! function(object, o, l, c) {
							if (!1 === r.isWebGL2 && (object.isInstancedMesh || c.isInstancedBufferGeometry) && null === e.get("ANGLE_instanced_arrays")) return;
							x();
							const h = c.attributes,
								d = l.getAttributes(),
								f = o.defaultAttributeValues;
							for (const e in d) {
								const r = d[e];
								if (r.location >= 0) {
									let o = h[e];
									if (void 0 === o && ("instanceMatrix" === e && object.instanceMatrix && (o = object.instanceMatrix), "instanceColor" === e && object.instanceColor && (o = object.instanceColor)), void 0 !== o) {
										const e = o.normalized,
											l = o.itemSize,
											h = n.get(o);
										if (void 0 === h) continue;
										const d = h.buffer,
											f = h.type,
											m = h.bytesPerElement;
										if (o.isInterleavedBufferAttribute) {
											const data = o.data,
												n = data.stride,
												h = o.offset;
											if (data && data.isInstancedInterleavedBuffer) {
												for (let i = 0; i < r.locationSize; i++) w(r.location + i, data.meshPerAttribute);
												!0 !== object.isInstancedMesh && void 0 === c._maxInstanceCount && (c._maxInstanceCount = data.meshPerAttribute * data.count)
											} else
												for (let i = 0; i < r.locationSize; i++) _(r.location + i);
											t.bindBuffer(34962, d);
											for (let i = 0; i < r.locationSize; i++) M(r.location + i, l / r.locationSize, f, e, n * m, (h + l / r.locationSize * i) * m)
										} else {
											if (o.isInstancedBufferAttribute) {
												for (let i = 0; i < r.locationSize; i++) w(r.location + i, o.meshPerAttribute);
												!0 !== object.isInstancedMesh && void 0 === c._maxInstanceCount && (c._maxInstanceCount = o.meshPerAttribute * o.count)
											} else
												for (let i = 0; i < r.locationSize; i++) _(r.location + i);
											t.bindBuffer(34962, d);
											for (let i = 0; i < r.locationSize; i++) M(r.location + i, l / r.locationSize, f, e, l * m, l / r.locationSize * i * m)
										}
									} else if (void 0 !== f) {
										const n = f[e];
										if (void 0 !== n) switch (n.length) {
											case 2:
												t.vertexAttrib2fv(r.location, n);
												break;
											case 3:
												t.vertexAttrib3fv(r.location, n);
												break;
											case 4:
												t.vertexAttrib4fv(r.location, n);
												break;
											default:
												t.vertexAttrib1fv(r.location, n)
										}
									}
								}
							}
							A()
						}(object, o, d, v), null !== S && t.bindBuffer(34963, n.get(S).buffer))
					},
					reset: S,
					resetDefaultState: T,
					dispose: function() {
						S();
						for (const t in h) {
							const e = h[t];
							for (const t in e) {
								const n = e[t];
								for (const t in n) v(n[t].object), delete n[t];
								delete e[t]
							}
							delete h[t]
						}
					},
					releaseStatesOfGeometry: function(t) {
						if (void 0 === h[t.id]) return;
						const e = h[t.id];
						for (const t in e) {
							const n = e[t];
							for (const t in n) v(n[t].object), delete n[t];
							delete e[t]
						}
						delete h[t.id]
					},
					releaseStatesOfProgram: function(t) {
						for (const e in h) {
							const n = h[e];
							if (void 0 === n[t.id]) continue;
							const r = n[t.id];
							for (const t in r) v(r[t].object), delete r[t];
							delete n[t.id]
						}
					},
					initAttributes: x,
					enableAttribute: _,
					disableUnusedAttributes: A
				}
			}

			function Ci(t, e, n, r) {
				const o = r.isWebGL2;
				let l;
				this.setMode = function(t) {
					l = t
				}, this.render = function(e, r) {
					t.drawArrays(l, e, r), n.update(r, l, 1)
				}, this.renderInstances = function(r, c, h) {
					if (0 === h) return;
					let d, f;
					if (o) d = t, f = "drawArraysInstanced";
					else if (d = e.get("ANGLE_instanced_arrays"), f = "drawArraysInstancedANGLE", null === d) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
					d[f](l, r, c, h), n.update(c, l, h)
				}
			}

			function Ri(t, e, n) {
				let r;

				function o(e) {
					if ("highp" === e) {
						if (t.getShaderPrecisionFormat(35633, 36338).precision > 0 && t.getShaderPrecisionFormat(35632, 36338).precision > 0) return "highp";
						e = "mediump"
					}
					return "mediump" === e && t.getShaderPrecisionFormat(35633, 36337).precision > 0 && t.getShaderPrecisionFormat(35632, 36337).precision > 0 ? "mediump" : "lowp"
				}
				const l = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext || "undefined" != typeof WebGL2ComputeRenderingContext && t instanceof WebGL2ComputeRenderingContext;
				let c = void 0 !== n.precision ? n.precision : "highp";
				const h = o(c);
				h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."), c = h);
				const d = l || e.has("WEBGL_draw_buffers"),
					f = !0 === n.logarithmicDepthBuffer,
					m = t.getParameter(34930),
					v = t.getParameter(35660),
					y = t.getParameter(3379),
					x = t.getParameter(34076),
					_ = t.getParameter(34921),
					w = t.getParameter(36347),
					A = t.getParameter(36348),
					M = t.getParameter(36349),
					S = v > 0,
					T = l || e.has("OES_texture_float");
				return {
					isWebGL2: l,
					drawBuffers: d,
					getMaxAnisotropy: function() {
						if (void 0 !== r) return r;
						if (!0 === e.has("EXT_texture_filter_anisotropic")) {
							const n = e.get("EXT_texture_filter_anisotropic");
							r = t.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
						} else r = 0;
						return r
					},
					getMaxPrecision: o,
					precision: c,
					logarithmicDepthBuffer: f,
					maxTextures: m,
					maxVertexTextures: v,
					maxTextureSize: y,
					maxCubemapSize: x,
					maxAttributes: _,
					maxVertexUniforms: w,
					maxVaryings: A,
					maxFragmentUniforms: M,
					vertexTextures: S,
					floatFragmentTextures: T,
					floatVertexTextures: S && T,
					maxSamples: l ? t.getParameter(36183) : 0
				}
			}

			function Di(t) {
				const e = this;
				let n = null,
					r = 0,
					o = !1,
					l = !1;
				const c = new gi,
					h = new Ut,
					d = {
						value: null,
						needsUpdate: !1
					};

				function f() {
					d.value !== n && (d.value = n, d.needsUpdate = r > 0), e.numPlanes = r, e.numIntersection = 0
				}

				function m(t, n, r, o) {
					const l = null !== t ? t.length : 0;
					let f = null;
					if (0 !== l) {
						if (f = d.value, !0 !== o || null === f) {
							const e = r + 4 * l,
								o = n.matrixWorldInverse;
							h.getNormalMatrix(o), (null === f || f.length < e) && (f = new Float32Array(e));
							for (let i = 0, e = r; i !== l; ++i, e += 4) c.copy(t[i]).applyMatrix4(o, h), c.normal.toArray(f, e), f[e + 3] = c.constant
						}
						d.value = f, d.needsUpdate = !0
					}
					return e.numPlanes = l, e.numIntersection = 0, f
				}
				this.uniform = d, this.numPlanes = 0, this.numIntersection = 0, this.init = function(t, e, l) {
					const c = 0 !== t.length || e || 0 !== r || o;
					return o = e, n = m(t, l, 0), r = t.length, c
				}, this.beginShadows = function() {
					l = !0, m(null)
				}, this.endShadows = function() {
					l = !1, f()
				}, this.setState = function(e, c, h) {
					const v = e.clippingPlanes,
						y = e.clipIntersection,
						x = e.clipShadows,
						_ = t.get(e);
					if (!o || null === v || 0 === v.length || l && !x) l ? m(null) : f();
					else {
						const t = l ? 0 : r,
							e = 4 * t;
						let o = _.clippingState || null;
						d.value = o, o = m(v, c, e, h);
						for (let i = 0; i !== e; ++i) o[i] = n[i];
						_.clippingState = o, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += t
					}
				}
			}

			function Li(t) {
				let e = new WeakMap;

				function n(t, e) {
					return e === T ? t.mapping = M : e === E && (t.mapping = S), t
				}

				function r(t) {
					const n = t.target;
					n.removeEventListener("dispose", r);
					const o = e.get(n);
					void 0 !== o && (e.delete(n), o.dispose())
				}
				return {
					get: function(o) {
						if (o && o.isTexture && !1 === o.isRenderTargetTexture) {
							const l = o.mapping;
							if (l === T || l === E) {
								if (e.has(o)) {
									return n(e.get(o).texture, o.mapping)
								} {
									const image = o.image;
									if (image && image.height > 0) {
										const l = new di(image.height / 2);
										return l.fromEquirectangularTexture(t, o), e.set(o, l), o.addEventListener("dispose", r), n(l.texture, o.mapping)
									}
									return null
								}
							}
						}
						return o
					},
					dispose: function() {
						e = new WeakMap
					}
				}
			}
			Si.physical = {
				uniforms: ii([Si.standard.uniforms, {
					clearcoat: {
						value: 0
					},
					clearcoatMap: {
						value: null
					},
					clearcoatRoughness: {
						value: 0
					},
					clearcoatRoughnessMap: {
						value: null
					},
					clearcoatNormalScale: {
						value: new Nt(1, 1)
					},
					clearcoatNormalMap: {
						value: null
					},
					sheen: {
						value: 0
					},
					sheenColor: {
						value: new Qt(0)
					},
					sheenColorMap: {
						value: null
					},
					sheenRoughness: {
						value: 1
					},
					sheenRoughnessMap: {
						value: null
					},
					transmission: {
						value: 0
					},
					transmissionMap: {
						value: null
					},
					transmissionSamplerSize: {
						value: new Nt
					},
					transmissionSamplerMap: {
						value: null
					},
					thickness: {
						value: 0
					},
					thicknessMap: {
						value: null
					},
					attenuationDistance: {
						value: 0
					},
					attenuationColor: {
						value: new Qt(0)
					},
					specularIntensity: {
						value: 1
					},
					specularIntensityMap: {
						value: null
					},
					specularColor: {
						value: new Qt(1, 1, 1)
					},
					specularColorMap: {
						value: null
					}
				}]),
				vertexShader: bi.meshphysical_vert,
				fragmentShader: bi.meshphysical_frag
			};
			class Pi extends ai {
				constructor(t = -1, e = 1, n = 1, r = -1, o = .1, l = 2e3) {
					super(), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = t, this.right = e, this.top = n, this.bottom = r, this.near = o, this.far = l, this.updateProjectionMatrix()
				}
				copy(source, t) {
					return super.copy(source, t), this.left = source.left, this.right = source.right, this.top = source.top, this.bottom = source.bottom, this.near = source.near, this.far = source.far, this.zoom = source.zoom, this.view = null === source.view ? null : Object.assign({}, source.view), this
				}
				setViewOffset(t, e, n, r, o, l) {
					null === this.view && (this.view = {
						enabled: !0,
						fullWidth: 1,
						fullHeight: 1,
						offsetX: 0,
						offsetY: 0,
						width: 1,
						height: 1
					}), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = n, this.view.offsetY = r, this.view.width = o, this.view.height = l, this.updateProjectionMatrix()
				}
				clearViewOffset() {
					null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
				}
				updateProjectionMatrix() {
					const t = (this.right - this.left) / (2 * this.zoom),
						e = (this.top - this.bottom) / (2 * this.zoom),
						n = (this.right + this.left) / 2,
						r = (this.top + this.bottom) / 2;
					let o = n - t,
						l = n + t,
						c = r + e,
						h = r - e;
					if (null !== this.view && this.view.enabled) {
						const t = (this.right - this.left) / this.view.fullWidth / this.zoom,
							e = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
						o += t * this.view.offsetX, l = o + t * this.view.width, c -= e * this.view.offsetY, h = c - e * this.view.height
					}
					this.projectionMatrix.makeOrthographic(o, l, c, h, this.near, this.far), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
				}
				toJSON(meta) {
					const data = super.toJSON(meta);
					return data.object.zoom = this.zoom, data.object.left = this.left, data.object.right = this.right, data.object.top = this.top, data.object.bottom = this.bottom, data.object.near = this.near, data.object.far = this.far, null !== this.view && (data.object.view = Object.assign({}, this.view)), data
				}
			}
			Pi.prototype.isOrthographicCamera = !0;
			class Ii extends si {
				constructor(t) {
					super(t), this.type = "RawShaderMaterial"
				}
			}
			Ii.prototype.isRawShaderMaterial = !0;
			const Bi = Math.pow(2, 8),
				Oi = [.125, .215, .35, .446, .526, .582],
				Fi = 5 + Oi.length,
				Hi = 20,
				Ni = new Pi,
				{
					_lodPlanes: Ui,
					_sizeLods: zi,
					_sigmas: ki
				} = Qi(),
				Gi = new Qt;
			let Vi = null;
			const Wi = (1 + Math.sqrt(5)) / 2,
				ji = 1 / Wi,
				Xi = [new re(1, 1, 1), new re(-1, 1, 1), new re(1, 1, -1), new re(-1, 1, -1), new re(0, Wi, ji), new re(0, Wi, -ji), new re(ji, 0, Wi), new re(-ji, 0, Wi), new re(Wi, ji, 0), new re(-Wi, ji, 0)];
			class Yi {
				constructor(t) {
					this._renderer = t, this._pingPongRenderTarget = null, this._blurMaterial = function(t) {
						const e = new Float32Array(t),
							n = new re(0, 1, 0);
						return new Ii({
							name: "SphericalGaussianBlur",
							defines: {
								n: t
							},
							uniforms: {
								envMap: {
									value: null
								},
								samples: {
									value: 1
								},
								weights: {
									value: e
								},
								latitudinal: {
									value: !1
								},
								dTheta: {
									value: 0
								},
								mipInt: {
									value: 0
								},
								poleAxis: {
									value: n
								}
							},
							vertexShader: $i(),
							fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
							blending: h,
							depthTest: !1,
							depthWrite: !1
						})
					}(Hi), this._equirectShader = null, this._cubemapShader = null, this._compileMaterial(this._blurMaterial)
				}
				fromScene(t, e = 0, n = .1, r = 100) {
					Vi = this._renderer.getRenderTarget();
					const o = this._allocateTargets();
					return this._sceneToCubeUV(t, n, r, o), e > 0 && this._blur(o, 0, 0, e), this._applyPMREM(o), this._cleanup(o), o
				}
				fromEquirectangular(t, e = null) {
					return this._fromTexture(t, e)
				}
				fromCubemap(t, e = null) {
					return this._fromTexture(t, e)
				}
				compileCubemapShader() {
					null === this._cubemapShader && (this._cubemapShader = Zi(), this._compileMaterial(this._cubemapShader))
				}
				compileEquirectangularShader() {
					null === this._equirectShader && (this._equirectShader = Ki(), this._compileMaterial(this._equirectShader))
				}
				dispose() {
					this._blurMaterial.dispose(), null !== this._pingPongRenderTarget && this._pingPongRenderTarget.dispose(), null !== this._cubemapShader && this._cubemapShader.dispose(), null !== this._equirectShader && this._equirectShader.dispose();
					for (let i = 0; i < Ui.length; i++) Ui[i].dispose()
				}
				_cleanup(t) {
					this._renderer.setRenderTarget(Vi), t.scissorTest = !1, Ji(t, 0, 0, t.width, t.height)
				}
				_fromTexture(t, e) {
					Vi = this._renderer.getRenderTarget();
					const n = e || this._allocateTargets(t);
					return this._textureToCubeUV(t, n), this._applyPMREM(n), this._cleanup(n), n
				}
				_allocateTargets(t) {
					const e = {
							magFilter: F,
							minFilter: F,
							generateMipmaps: !1,
							type: W,
							format: Y,
							encoding: mt,
							depthBuffer: !1
						},
						n = qi(e);
					return n.depthBuffer = !t, null === this._pingPongRenderTarget && (this._pingPongRenderTarget = qi(e)), n
				}
				_compileMaterial(t) {
					const e = new $n(Ui[0], t);
					this._renderer.compile(e, Ni)
				}
				_sceneToCubeUV(t, e, n, r) {
					const o = new oi(90, 1, e, n),
						c = [1, -1, 1, 1, 1, 1],
						h = [1, 1, 1, -1, -1, -1],
						d = this._renderer,
						f = d.autoClear,
						m = d.toneMapping;
					d.getClearColor(Gi), d.toneMapping = 0, d.autoClear = !1;
					const v = new wn({
							name: "PMREM.Background",
							side: l,
							depthWrite: !1,
							depthTest: !1
						}),
						y = new $n(new ei, v);
					let x = !1;
					const _ = t.background;
					_ ? _.isColor && (v.color.copy(_), t.background = null, x = !0) : (v.color.copy(Gi), x = !0);
					for (let i = 0; i < 6; i++) {
						const col = i % 3;
						0 === col ? (o.up.set(0, c[i], 0), o.lookAt(h[i], 0, 0)) : 1 === col ? (o.up.set(0, 0, c[i]), o.lookAt(0, h[i], 0)) : (o.up.set(0, c[i], 0), o.lookAt(0, 0, h[i])), Ji(r, col * Bi, i > 2 ? Bi : 0, Bi, Bi), d.setRenderTarget(r), x && d.render(y, o), d.render(t, o)
					}
					y.geometry.dispose(), y.material.dispose(), d.toneMapping = m, d.autoClear = f, t.background = _
				}
				_textureToCubeUV(t, e) {
					const n = this._renderer,
						r = t.mapping === M || t.mapping === S;
					r ? (null === this._cubemapShader && (this._cubemapShader = Zi()), this._cubemapShader.uniforms.flipEnvMap.value = !1 === t.isRenderTargetTexture ? -1 : 1) : null === this._equirectShader && (this._equirectShader = Ki());
					const o = r ? this._cubemapShader : this._equirectShader,
						l = new $n(Ui[0], o),
						c = o.uniforms;
					c.envMap.value = t, r || c.texelSize.value.set(1 / t.image.width, 1 / t.image.height), Ji(e, 0, 0, 3 * Bi, 2 * Bi), n.setRenderTarget(e), n.render(l, Ni)
				}
				_applyPMREM(t) {
					const e = this._renderer,
						n = e.autoClear;
					e.autoClear = !1;
					for (let i = 1; i < Fi; i++) {
						const e = Math.sqrt(ki[i] * ki[i] - ki[i - 1] * ki[i - 1]),
							n = Xi[(i - 1) % Xi.length];
						this._blur(t, i - 1, i, e, n)
					}
					e.autoClear = n
				}
				_blur(t, e, n, r, o) {
					const l = this._pingPongRenderTarget;
					this._halfBlur(t, l, e, n, r, "latitudinal", o), this._halfBlur(l, t, n, n, r, "longitudinal", o)
				}
				_halfBlur(t, e, n, r, o, l, c) {
					const h = this._renderer,
						d = this._blurMaterial;
					"latitudinal" !== l && "longitudinal" !== l && console.error("blur direction must be either latitudinal or longitudinal!");
					const f = new $n(Ui[r], d),
						m = d.uniforms,
						v = zi[n] - 1,
						y = isFinite(o) ? Math.PI / (2 * v) : 2 * Math.PI / 39,
						x = o / y,
						_ = isFinite(o) ? 1 + Math.floor(3 * x) : Hi;
					_ > Hi && console.warn(`sigmaRadians, ${o}, is too large and will clip, as it requested ${_} samples when the maximum is set to 20`);
					const w = [];
					let A = 0;
					for (let i = 0; i < Hi; ++i) {
						const t = i / x,
							e = Math.exp(-t * t / 2);
						w.push(e), 0 === i ? A += e : i < _ && (A += 2 * e)
					}
					for (let i = 0; i < w.length; i++) w[i] = w[i] / A;
					m.envMap.value = t.texture, m.samples.value = _, m.weights.value = w, m.latitudinal.value = "latitudinal" === l, c && (m.poleAxis.value = c), m.dTheta.value = y, m.mipInt.value = 8 - n;
					const M = zi[r];
					Ji(e, 3 * Math.max(0, Bi - 2 * M), (0 === r ? 0 : 2 * Bi) + 2 * M * (r > 4 ? r - 8 + 4 : 0), 3 * M, 2 * M), h.setRenderTarget(e), h.render(f, Ni)
				}
			}

			function Qi() {
				const t = [],
					e = [],
					n = [];
				let r = 8;
				for (let i = 0; i < Fi; i++) {
					const o = Math.pow(2, r);
					e.push(o);
					let l = 1 / o;
					i > 4 ? l = Oi[i - 8 + 4 - 1] : 0 === i && (l = 0), n.push(l);
					const c = 1 / (o - 1),
						h = -c / 2,
						d = 1 + c / 2,
						f = [h, h, d, h, d, d, h, h, d, d, h, d],
						m = 6,
						v = 6,
						y = 3,
						x = 2,
						_ = 1,
						w = new Float32Array(y * v * m),
						A = new Float32Array(x * v * m),
						M = new Float32Array(_ * v * m);
					for (let t = 0; t < m; t++) {
						const e = t % 3 * 2 / 3 - 1,
							n = t > 2 ? 0 : -1,
							r = [e, n, 0, e + 2 / 3, n, 0, e + 2 / 3, n + 1, 0, e, n, 0, e + 2 / 3, n + 1, 0, e, n + 1, 0];
						w.set(r, y * v * t), A.set(f, x * v * t);
						const o = [t, t, t, t, t, t];
						M.set(o, _ * v * t)
					}
					const S = new On;
					S.setAttribute("position", new Mn(w, y)), S.setAttribute("uv", new Mn(A, x)), S.setAttribute("faceIndex", new Mn(M, _)), t.push(S), r > 4 && r--
				}
				return {
					_lodPlanes: t,
					_sizeLods: e,
					_sigmas: n
				}
			}

			function qi(t) {
				const e = new ee(3 * Bi, 3 * Bi, t);
				return e.texture.mapping = C, e.texture.name = "PMREM.cubeUv", e.scissorTest = !0, e
			}

			function Ji(t, e, n, r, o) {
				t.viewport.set(e, n, r, o), t.scissor.set(e, n, r, o)
			}

			function Ki() {
				const t = new Nt(1, 1);
				return new Ii({
					name: "EquirectangularToCubeUV",
					uniforms: {
						envMap: {
							value: null
						},
						texelSize: {
							value: t
						}
					},
					vertexShader: $i(),
					fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
					blending: h,
					depthTest: !1,
					depthWrite: !1
				})
			}

			function Zi() {
				return new Ii({
					name: "CubemapToCubeUV",
					uniforms: {
						envMap: {
							value: null
						},
						flipEnvMap: {
							value: -1
						}
					},
					vertexShader: $i(),
					fragmentShader: "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
					blending: h,
					depthTest: !1,
					depthWrite: !1
				})
			}

			function $i() {
				return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t"
			}

			function er(t) {
				let e = new WeakMap,
					n = null;

				function r(t) {
					const n = t.target;
					n.removeEventListener("dispose", r);
					const o = e.get(n);
					void 0 !== o && (e.delete(n), o.dispose())
				}
				return {
					get: function(o) {
						if (o && o.isTexture) {
							const l = o.mapping,
								c = l === T || l === E,
								h = l === M || l === S;
							if (c || h) {
								if (o.isRenderTargetTexture && !0 === o.needsPMREMUpdate) {
									o.needsPMREMUpdate = !1;
									let r = e.get(o);
									return null === n && (n = new Yi(t)), r = c ? n.fromEquirectangular(o, r) : n.fromCubemap(o, r), e.set(o, r), r.texture
								}
								if (e.has(o)) return e.get(o).texture; {
									const image = o.image;
									if (c && image && image.height > 0 || h && image && function(image) {
											let t = 0;
											const e = 6;
											for (let i = 0; i < e; i++) void 0 !== image[i] && t++;
											return t === e
										}(image)) {
										null === n && (n = new Yi(t));
										const l = c ? n.fromEquirectangular(o) : n.fromCubemap(o);
										return e.set(o, l), o.addEventListener("dispose", r), l.texture
									}
									return null
								}
							}
						}
						return o
					},
					dispose: function() {
						e = new WeakMap, null !== n && (n.dispose(), n = null)
					}
				}
			}

			function nr(t) {
				const e = {};

				function n(n) {
					if (void 0 !== e[n]) return e[n];
					let r;
					switch (n) {
						case "WEBGL_depth_texture":
							r = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
							break;
						case "EXT_texture_filter_anisotropic":
							r = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
							break;
						case "WEBGL_compressed_texture_s3tc":
							r = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
							break;
						case "WEBGL_compressed_texture_pvrtc":
							r = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
							break;
						default:
							r = t.getExtension(n)
					}
					return e[n] = r, r
				}
				return {
					has: function(t) {
						return null !== n(t)
					},
					init: function(t) {
						t.isWebGL2 ? n("EXT_color_buffer_float") : (n("WEBGL_depth_texture"), n("OES_texture_float"), n("OES_texture_half_float"), n("OES_texture_half_float_linear"), n("OES_standard_derivatives"), n("OES_element_index_uint"), n("OES_vertex_array_object"), n("ANGLE_instanced_arrays")), n("OES_texture_float_linear"), n("EXT_color_buffer_half_float"), n("WEBGL_multisampled_render_to_texture")
					},
					get: function(t) {
						const e = n(t);
						return null === e && console.warn("THREE.WebGLRenderer: " + t + " extension not supported."), e
					}
				}
			}

			function ir(t, e, n, r) {
				const o = {},
					l = new WeakMap;

				function c(t) {
					const h = t.target;
					null !== h.index && e.remove(h.index);
					for (const t in h.attributes) e.remove(h.attributes[t]);
					h.removeEventListener("dispose", c), delete o[h.id];
					const d = l.get(h);
					d && (e.remove(d), l.delete(h)), r.releaseStatesOfGeometry(h), !0 === h.isInstancedBufferGeometry && delete h._maxInstanceCount, n.memory.geometries--
				}

				function h(t) {
					const n = [],
						r = t.index,
						o = t.attributes.position;
					let c = 0;
					if (null !== r) {
						const t = r.array;
						c = r.version;
						for (let i = 0, e = t.length; i < e; i += 3) {
							const a = t[i + 0],
								b = t[i + 1],
								e = t[i + 2];
							n.push(a, b, b, e, e, a)
						}
					} else {
						const t = o.array;
						c = o.version;
						for (let i = 0, e = t.length / 3 - 1; i < e; i += 3) {
							const a = i + 0,
								b = i + 1,
								t = i + 2;
							n.push(a, b, b, t, t, a)
						}
					}
					const h = new(zt(n) ? Tn : Sn)(n, 1);
					h.version = c;
					const d = l.get(t);
					d && e.remove(d), l.set(t, h)
				}
				return {
					get: function(object, t) {
						return !0 === o[t.id] || (t.addEventListener("dispose", c), o[t.id] = !0, n.memory.geometries++), t
					},
					update: function(t) {
						const n = t.attributes;
						for (const t in n) e.update(n[t], 34962);
						const r = t.morphAttributes;
						for (const t in r) {
							const n = r[t];
							for (let i = 0, t = n.length; i < t; i++) e.update(n[i], 34962)
						}
					},
					getWireframeAttribute: function(t) {
						const e = l.get(t);
						if (e) {
							const n = t.index;
							null !== n && e.version < n.version && h(t)
						} else h(t);
						return l.get(t)
					}
				}
			}

			function rr(t, e, n, r) {
				const o = r.isWebGL2;
				let l, c, h;
				this.setMode = function(t) {
					l = t
				}, this.setIndex = function(t) {
					c = t.type, h = t.bytesPerElement
				}, this.render = function(e, r) {
					t.drawElements(l, r, c, e * h), n.update(r, l, 1)
				}, this.renderInstances = function(r, d, f) {
					if (0 === f) return;
					let m, v;
					if (o) m = t, v = "drawElementsInstanced";
					else if (m = e.get("ANGLE_instanced_arrays"), v = "drawElementsInstancedANGLE", null === m) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
					m[v](l, d, c, r * h, f), n.update(d, l, f)
				}
			}

			function sr(t) {
				const e = {
					frame: 0,
					calls: 0,
					triangles: 0,
					points: 0,
					lines: 0
				};
				return {
					memory: {
						geometries: 0,
						textures: 0
					},
					render: e,
					programs: null,
					autoReset: !0,
					reset: function() {
						e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
					},
					update: function(t, n, r) {
						switch (e.calls++, n) {
							case 4:
								e.triangles += r * (t / 3);
								break;
							case 1:
								e.lines += r * (t / 2);
								break;
							case 3:
								e.lines += r * (t - 1);
								break;
							case 2:
								e.lines += r * t;
								break;
							case 0:
								e.points += r * t;
								break;
							default:
								console.error("THREE.WebGLInfo: Unknown draw mode:", n)
						}
					}
				}
			}
			class ar extends Zt {
				constructor(data = null, t = 1, e = 1, n = 1) {
					super(null), this.image = {
						data: data,
						width: t,
						height: e,
						depth: n
					}, this.magFilter = I, this.minFilter = I, this.wrapR = L, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}
			}

			function or(a, b) {
				return a[0] - b[0]
			}

			function lr(a, b) {
				return Math.abs(b[1]) - Math.abs(a[1])
			}

			function cr(t, e) {
				let n = 1;
				const r = e.isInterleavedBufferAttribute ? e.data.array : e.array;
				r instanceof Int8Array ? n = 127 : r instanceof Int16Array ? n = 32767 : r instanceof Int32Array ? n = 2147483647 : console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ", r), t.divideScalar(n)
			}

			function ur(t, e, n) {
				const r = {},
					o = new Float32Array(8),
					l = new WeakMap,
					c = new re,
					h = [];
				for (let i = 0; i < 8; i++) h[i] = [i, 0];
				return {
					update: function(object, d, f, m) {
						const v = object.morphTargetInfluences;
						if (!0 === e.isWebGL2) {
							const r = d.morphAttributes.position.length;
							let o = l.get(d);
							if (void 0 === o || o.count !== r) {
								void 0 !== o && o.texture.dispose();
								const t = void 0 !== d.morphAttributes.normal,
									n = d.morphAttributes.position,
									h = d.morphAttributes.normal || [],
									f = !0 === t ? 2 : 1;
								let m = d.attributes.position.count * f,
									v = 1;
								m > e.maxTextureSize && (v = Math.ceil(m / e.maxTextureSize), m = e.maxTextureSize);
								const y = new Float32Array(m * v * 4 * r),
									x = new ar(y, m, v, r);
								x.format = Y, x.type = V, x.needsUpdate = !0;
								const _ = 4 * f;
								for (let i = 0; i < r; i++) {
									const e = n[i],
										r = h[i],
										o = m * v * 4 * i;
									for (let n = 0; n < e.count; n++) {
										c.fromBufferAttribute(e, n), !0 === e.normalized && cr(c, e);
										const l = n * _;
										y[o + l + 0] = c.x, y[o + l + 1] = c.y, y[o + l + 2] = c.z, y[o + l + 3] = 0, !0 === t && (c.fromBufferAttribute(r, n), !0 === r.normalized && cr(c, r), y[o + l + 4] = c.x, y[o + l + 5] = c.y, y[o + l + 6] = c.z, y[o + l + 7] = 0)
									}
								}
								o = {
									count: r,
									texture: x,
									size: new Nt(m, v)
								}, l.set(d, o), d.addEventListener("dispose", (function t() {
									x.dispose(), l.delete(d), d.removeEventListener("dispose", t)
								}))
							}
							let h = 0;
							for (let i = 0; i < v.length; i++) h += v[i];
							const f = d.morphTargetsRelative ? 1 : 1 - h;
							m.getUniforms().setValue(t, "morphTargetBaseInfluence", f), m.getUniforms().setValue(t, "morphTargetInfluences", v), m.getUniforms().setValue(t, "morphTargetsTexture", o.texture, n), m.getUniforms().setValue(t, "morphTargetsTextureSize", o.size)
						} else {
							const e = void 0 === v ? 0 : v.length;
							let n = r[d.id];
							if (void 0 === n || n.length !== e) {
								n = [];
								for (let i = 0; i < e; i++) n[i] = [i, 0];
								r[d.id] = n
							}
							for (let i = 0; i < e; i++) {
								const t = n[i];
								t[0] = i, t[1] = v[i]
							}
							n.sort(lr);
							for (let i = 0; i < 8; i++) i < e && n[i][1] ? (h[i][0] = n[i][0], h[i][1] = n[i][1]) : (h[i][0] = Number.MAX_SAFE_INTEGER, h[i][1] = 0);
							h.sort(or);
							const l = d.morphAttributes.position,
								c = d.morphAttributes.normal;
							let f = 0;
							for (let i = 0; i < 8; i++) {
								const t = h[i],
									e = t[0],
									n = t[1];
								e !== Number.MAX_SAFE_INTEGER && n ? (l && d.getAttribute("morphTarget" + i) !== l[e] && d.setAttribute("morphTarget" + i, l[e]), c && d.getAttribute("morphNormal" + i) !== c[e] && d.setAttribute("morphNormal" + i, c[e]), o[i] = n, f += n) : (l && !0 === d.hasAttribute("morphTarget" + i) && d.deleteAttribute("morphTarget" + i), c && !0 === d.hasAttribute("morphNormal" + i) && d.deleteAttribute("morphNormal" + i), o[i] = 0)
							}
							const y = d.morphTargetsRelative ? 1 : 1 - f;
							m.getUniforms().setValue(t, "morphTargetBaseInfluence", y), m.getUniforms().setValue(t, "morphTargetInfluences", o)
						}
					}
				}
			}

			function dr(t, e, n, r) {
				let o = new WeakMap;

				function l(t) {
					const e = t.target;
					e.removeEventListener("dispose", l), n.remove(e.instanceMatrix), null !== e.instanceColor && n.remove(e.instanceColor)
				}
				return {
					update: function(object) {
						const t = r.render.frame,
							c = object.geometry,
							h = e.get(object, c);
						return o.get(h) !== t && (e.update(h), o.set(h, t)), object.isInstancedMesh && (!1 === object.hasEventListener("dispose", l) && object.addEventListener("dispose", l), n.update(object.instanceMatrix, 34962), null !== object.instanceColor && n.update(object.instanceColor, 34962)), h
					},
					dispose: function() {
						o = new WeakMap
					}
				}
			}
			ar.prototype.isDataTexture2DArray = !0;
			class pr extends Zt {
				constructor(data = null, t = 1, e = 1, n = 1) {
					super(null), this.image = {
						data: data,
						width: t,
						height: e,
						depth: n
					}, this.magFilter = I, this.minFilter = I, this.wrapR = L, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}
			}
			pr.prototype.isDataTexture3D = !0;
			const fr = new Zt,
				mr = new ar,
				gr = new pr,
				vr = new ui,
				yr = [],
				xr = [],
				_r = new Float32Array(16),
				wr = new Float32Array(9),
				Ar = new Float32Array(4);

			function Mr(t, e, n) {
				const r = t[0];
				if (r <= 0 || r > 0) return t;
				const o = e * n;
				let l = yr[o];
				if (void 0 === l && (l = new Float32Array(o), yr[o] = l), 0 !== e) {
					r.toArray(l, 0);
					for (let i = 1, r = 0; i !== e; ++i) r += n, t[i].toArray(l, r)
				}
				return l
			}

			function Sr(a, b) {
				if (a.length !== b.length) return !1;
				for (let i = 0, t = a.length; i < t; i++)
					if (a[i] !== b[i]) return !1;
				return !0
			}

			function Tr(a, b) {
				for (let i = 0, t = b.length; i < t; i++) a[i] = b[i]
			}

			function Er(t, e) {
				let n = xr[e];
				void 0 === n && (n = new Int32Array(e), xr[e] = n);
				for (let i = 0; i !== e; ++i) n[i] = t.allocateTextureUnit();
				return n
			}

			function Cr(t, e) {
				const n = this.cache;
				n[0] !== e && (t.uniform1f(this.addr, e), n[0] = e)
			}

			function Rr(t, e) {
				const n = this.cache;
				if (void 0 !== e.x) n[0] === e.x && n[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), n[0] = e.x, n[1] = e.y);
				else {
					if (Sr(n, e)) return;
					t.uniform2fv(this.addr, e), Tr(n, e)
				}
			}

			function Dr(t, e) {
				const n = this.cache;
				if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), n[0] = e.x, n[1] = e.y, n[2] = e.z);
				else if (void 0 !== e.r) n[0] === e.r && n[1] === e.g && n[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), n[0] = e.r, n[1] = e.g, n[2] = e.b);
				else {
					if (Sr(n, e)) return;
					t.uniform3fv(this.addr, e), Tr(n, e)
				}
			}

			function Lr(t, e) {
				const n = this.cache;
				if (void 0 !== e.x) n[0] === e.x && n[1] === e.y && n[2] === e.z && n[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = e.w);
				else {
					if (Sr(n, e)) return;
					t.uniform4fv(this.addr, e), Tr(n, e)
				}
			}

			function Pr(t, e) {
				const n = this.cache,
					r = e.elements;
				if (void 0 === r) {
					if (Sr(n, e)) return;
					t.uniformMatrix2fv(this.addr, !1, e), Tr(n, e)
				} else {
					if (Sr(n, r)) return;
					Ar.set(r), t.uniformMatrix2fv(this.addr, !1, Ar), Tr(n, r)
				}
			}

			function Ir(t, e) {
				const n = this.cache,
					r = e.elements;
				if (void 0 === r) {
					if (Sr(n, e)) return;
					t.uniformMatrix3fv(this.addr, !1, e), Tr(n, e)
				} else {
					if (Sr(n, r)) return;
					wr.set(r), t.uniformMatrix3fv(this.addr, !1, wr), Tr(n, r)
				}
			}

			function Br(t, e) {
				const n = this.cache,
					r = e.elements;
				if (void 0 === r) {
					if (Sr(n, e)) return;
					t.uniformMatrix4fv(this.addr, !1, e), Tr(n, e)
				} else {
					if (Sr(n, r)) return;
					_r.set(r), t.uniformMatrix4fv(this.addr, !1, _r), Tr(n, r)
				}
			}

			function Or(t, e) {
				const n = this.cache;
				n[0] !== e && (t.uniform1i(this.addr, e), n[0] = e)
			}

			function Fr(t, e) {
				const n = this.cache;
				Sr(n, e) || (t.uniform2iv(this.addr, e), Tr(n, e))
			}

			function Hr(t, e) {
				const n = this.cache;
				Sr(n, e) || (t.uniform3iv(this.addr, e), Tr(n, e))
			}

			function Nr(t, e) {
				const n = this.cache;
				Sr(n, e) || (t.uniform4iv(this.addr, e), Tr(n, e))
			}

			function Ur(t, e) {
				const n = this.cache;
				n[0] !== e && (t.uniform1ui(this.addr, e), n[0] = e)
			}

			function zr(t, e) {
				const n = this.cache;
				Sr(n, e) || (t.uniform2uiv(this.addr, e), Tr(n, e))
			}

			function kr(t, e) {
				const n = this.cache;
				Sr(n, e) || (t.uniform3uiv(this.addr, e), Tr(n, e))
			}

			function Gr(t, e) {
				const n = this.cache;
				Sr(n, e) || (t.uniform4uiv(this.addr, e), Tr(n, e))
			}

			function Vr(t, e, n) {
				const r = this.cache,
					o = n.allocateTextureUnit();
				r[0] !== o && (t.uniform1i(this.addr, o), r[0] = o), n.safeSetTexture2D(e || fr, o)
			}

			function Wr(t, e, n) {
				const r = this.cache,
					o = n.allocateTextureUnit();
				r[0] !== o && (t.uniform1i(this.addr, o), r[0] = o), n.setTexture3D(e || gr, o)
			}

			function jr(t, e, n) {
				const r = this.cache,
					o = n.allocateTextureUnit();
				r[0] !== o && (t.uniform1i(this.addr, o), r[0] = o), n.safeSetTextureCube(e || vr, o)
			}

			function Xr(t, e, n) {
				const r = this.cache,
					o = n.allocateTextureUnit();
				r[0] !== o && (t.uniform1i(this.addr, o), r[0] = o), n.setTexture2DArray(e || mr, o)
			}

			function Yr(t, e) {
				t.uniform1fv(this.addr, e)
			}

			function Qr(t, e) {
				const data = Mr(e, this.size, 2);
				t.uniform2fv(this.addr, data)
			}

			function qr(t, e) {
				const data = Mr(e, this.size, 3);
				t.uniform3fv(this.addr, data)
			}

			function Jr(t, e) {
				const data = Mr(e, this.size, 4);
				t.uniform4fv(this.addr, data)
			}

			function Kr(t, e) {
				const data = Mr(e, this.size, 4);
				t.uniformMatrix2fv(this.addr, !1, data)
			}

			function Zr(t, e) {
				const data = Mr(e, this.size, 9);
				t.uniformMatrix3fv(this.addr, !1, data)
			}

			function $r(t, e) {
				const data = Mr(e, this.size, 16);
				t.uniformMatrix4fv(this.addr, !1, data)
			}

			function ts(t, e) {
				t.uniform1iv(this.addr, e)
			}

			function es(t, e) {
				t.uniform2iv(this.addr, e)
			}

			function ns(t, e) {
				t.uniform3iv(this.addr, e)
			}

			function is(t, e) {
				t.uniform4iv(this.addr, e)
			}

			function rs(t, e) {
				t.uniform1uiv(this.addr, e)
			}

			function ss(t, e) {
				t.uniform2uiv(this.addr, e)
			}

			function as(t, e) {
				t.uniform3uiv(this.addr, e)
			}

			function os(t, e) {
				t.uniform4uiv(this.addr, e)
			}

			function ls(t, e, n) {
				const r = e.length,
					o = Er(n, r);
				t.uniform1iv(this.addr, o);
				for (let i = 0; i !== r; ++i) n.safeSetTexture2D(e[i] || fr, o[i])
			}

			function cs(t, e, n) {
				const r = e.length,
					o = Er(n, r);
				t.uniform1iv(this.addr, o);
				for (let i = 0; i !== r; ++i) n.setTexture3D(e[i] || gr, o[i])
			}

			function hs(t, e, n) {
				const r = e.length,
					o = Er(n, r);
				t.uniform1iv(this.addr, o);
				for (let i = 0; i !== r; ++i) n.safeSetTextureCube(e[i] || vr, o[i])
			}

			function us(t, e, n) {
				const r = e.length,
					o = Er(n, r);
				t.uniform1iv(this.addr, o);
				for (let i = 0; i !== r; ++i) n.setTexture2DArray(e[i] || mr, o[i])
			}

			function ds(t, e, n) {
				this.id = t, this.addr = n, this.cache = [], this.setValue = function(t) {
					switch (t) {
						case 5126:
							return Cr;
						case 35664:
							return Rr;
						case 35665:
							return Dr;
						case 35666:
							return Lr;
						case 35674:
							return Pr;
						case 35675:
							return Ir;
						case 35676:
							return Br;
						case 5124:
						case 35670:
							return Or;
						case 35667:
						case 35671:
							return Fr;
						case 35668:
						case 35672:
							return Hr;
						case 35669:
						case 35673:
							return Nr;
						case 5125:
							return Ur;
						case 36294:
							return zr;
						case 36295:
							return kr;
						case 36296:
							return Gr;
						case 35678:
						case 36198:
						case 36298:
						case 36306:
						case 35682:
							return Vr;
						case 35679:
						case 36299:
						case 36307:
							return Wr;
						case 35680:
						case 36300:
						case 36308:
						case 36293:
							return jr;
						case 36289:
						case 36303:
						case 36311:
						case 36292:
							return Xr
					}
				}(e.type)
			}

			function ps(t, e, n) {
				this.id = t, this.addr = n, this.cache = [], this.size = e.size, this.setValue = function(t) {
					switch (t) {
						case 5126:
							return Yr;
						case 35664:
							return Qr;
						case 35665:
							return qr;
						case 35666:
							return Jr;
						case 35674:
							return Kr;
						case 35675:
							return Zr;
						case 35676:
							return $r;
						case 5124:
						case 35670:
							return ts;
						case 35667:
						case 35671:
							return es;
						case 35668:
						case 35672:
							return ns;
						case 35669:
						case 35673:
							return is;
						case 5125:
							return rs;
						case 36294:
							return ss;
						case 36295:
							return as;
						case 36296:
							return os;
						case 35678:
						case 36198:
						case 36298:
						case 36306:
						case 35682:
							return ls;
						case 35679:
						case 36299:
						case 36307:
							return cs;
						case 35680:
						case 36300:
						case 36308:
						case 36293:
							return hs;
						case 36289:
						case 36303:
						case 36311:
						case 36292:
							return us
					}
				}(e.type)
			}

			function fs(t) {
				this.id = t, this.seq = [], this.map = {}
			}
			ps.prototype.updateCache = function(data) {
				const t = this.cache;
				data instanceof Float32Array && t.length !== data.length && (this.cache = new Float32Array(data.length)), Tr(t, data)
			}, fs.prototype.setValue = function(t, e, n) {
				const r = this.seq;
				for (let i = 0, o = r.length; i !== o; ++i) {
					const u = r[i];
					u.setValue(t, e[u.id], n)
				}
			};
			const ms = /(\w+)(\])?(\[|\.)?/g;

			function gs(t, e) {
				t.seq.push(e), t.map[e.id] = e
			}

			function vs(t, e, n) {
				const path = t.name,
					r = path.length;
				for (ms.lastIndex = 0;;) {
					const o = ms.exec(path),
						l = ms.lastIndex;
					let c = o[1];
					const h = "]" === o[2],
						d = o[3];
					if (h && (c |= 0), void 0 === d || "[" === d && l + 2 === r) {
						gs(n, void 0 === d ? new ds(c, t, e) : new ps(c, t, e));
						break
					} {
						let t = n.map[c];
						void 0 === t && (t = new fs(c), gs(n, t)), n = t
					}
				}
			}

			function ys(t, e) {
				this.seq = [], this.map = {};
				const n = t.getProgramParameter(e, 35718);
				for (let i = 0; i < n; ++i) {
					const n = t.getActiveUniform(e, i);
					vs(n, t.getUniformLocation(e, n.name), this)
				}
			}

			function xs(t, e, n) {
				const r = t.createShader(e);
				return t.shaderSource(r, n), t.compileShader(r), r
			}
			ys.prototype.setValue = function(t, e, n, r) {
				const u = this.map[e];
				void 0 !== u && u.setValue(t, n, r)
			}, ys.prototype.setOptional = function(t, object, e) {
				const n = object[e];
				void 0 !== n && this.setValue(t, e, n)
			}, ys.upload = function(t, e, n, r) {
				for (let i = 0, o = e.length; i !== o; ++i) {
					const u = e[i],
						o = n[u.id];
					!1 !== o.needsUpdate && u.setValue(t, o.value, r)
				}
			}, ys.seqWithValue = function(t, e) {
				const n = [];
				for (let i = 0, r = t.length; i !== r; ++i) {
					const u = t[i];
					u.id in e && n.push(u)
				}
				return n
			};
			let _s = 0;

			function ws(t, e, n) {
				const r = t.getShaderParameter(e, 35713),
					o = t.getShaderInfoLog(e).trim();
				return r && "" === o ? "" : n.toUpperCase() + "\n\n" + o + "\n\n" + function(t) {
					const e = t.split("\n");
					for (let i = 0; i < e.length; i++) e[i] = i + 1 + ": " + e[i];
					return e.join("\n")
				}(t.getShaderSource(e))
			}

			function As(t, e) {
				const n = function(t) {
					switch (t) {
						case mt:
							return ["Linear", "( value )"];
						case gt:
							return ["sRGB", "( value )"];
						default:
							return console.warn("THREE.WebGLProgram: Unsupported encoding:", t), ["Linear", "( value )"]
					}
				}(e);
				return "vec4 " + t + "( vec4 value ) { return LinearTo" + n[0] + n[1] + "; }"
			}

			function bs(t, e) {
				let n;
				switch (e) {
					case 1:
						n = "Linear";
						break;
					case 2:
						n = "Reinhard";
						break;
					case 3:
						n = "OptimizedCineon";
						break;
					case 4:
						n = "ACESFilmic";
						break;
					case 5:
						n = "Custom";
						break;
					default:
						console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), n = "Linear"
				}
				return "vec3 " + t + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
			}

			function Ms(t) {
				return "" !== t
			}

			function Ss(t, e) {
				return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
			}

			function Ts(t, e) {
				return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
			}
			const Es = /^[ \t]*#include +<([\w\d./]+)>/gm;

			function Cs(t) {
				return t.replace(Es, Rs)
			}

			function Rs(t, e) {
				const n = bi[e];
				if (void 0 === n) throw new Error("Can not resolve #include <" + e + ">");
				return Cs(n)
			}
			const Ds = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
				Ls = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

			function Ps(t) {
				return t.replace(Ls, Bs).replace(Ds, Is)
			}

			function Is(t, e, n, r) {
				return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."), Bs(t, e, n, r)
			}

			function Bs(t, e, n, r) {
				let o = "";
				for (let i = parseInt(e); i < parseInt(n); i++) o += r.replace(/\[\s*i\s*\]/g, "[ " + i + " ]").replace(/UNROLLED_LOOP_INDEX/g, i);
				return o
			}

			function Os(t) {
				let e = "precision " + t.precision + " float;\nprecision " + t.precision + " int;";
				return "highp" === t.precision ? e += "\n#define HIGH_PRECISION" : "mediump" === t.precision ? e += "\n#define MEDIUM_PRECISION" : "lowp" === t.precision && (e += "\n#define LOW_PRECISION"), e
			}

			function Fs(t, e, n, r) {
				const o = t.getContext(),
					l = n.defines;
				let c = n.vertexShader,
					h = n.fragmentShader;
				const d = function(t) {
						let e = "SHADOWMAP_TYPE_BASIC";
						return 1 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF" : 2 === t.shadowMapType ? e = "SHADOWMAP_TYPE_PCF_SOFT" : 3 === t.shadowMapType && (e = "SHADOWMAP_TYPE_VSM"), e
					}(n),
					f = function(t) {
						let e = "ENVMAP_TYPE_CUBE";
						if (t.envMap) switch (t.envMapMode) {
							case M:
							case S:
								e = "ENVMAP_TYPE_CUBE";
								break;
							case C:
							case R:
								e = "ENVMAP_TYPE_CUBE_UV"
						}
						return e
					}(n),
					m = function(t) {
						let e = "ENVMAP_MODE_REFLECTION";
						if (t.envMap) switch (t.envMapMode) {
							case S:
							case R:
								e = "ENVMAP_MODE_REFRACTION"
						}
						return e
					}(n),
					v = function(t) {
						let e = "ENVMAP_BLENDING_NONE";
						if (t.envMap) switch (t.combine) {
							case 0:
								e = "ENVMAP_BLENDING_MULTIPLY";
								break;
							case 1:
								e = "ENVMAP_BLENDING_MIX";
								break;
							case 2:
								e = "ENVMAP_BLENDING_ADD"
						}
						return e
					}(n),
					y = n.isWebGL2 ? "" : function(t) {
						return [t.extensionDerivatives || t.envMapCubeUV || t.bumpMap || t.tangentSpaceNormalMap || t.clearcoatNormalMap || t.flatShading || "physical" === t.shaderID ? "#extension GL_OES_standard_derivatives : enable" : "", (t.extensionFragDepth || t.logarithmicDepthBuffer) && t.rendererExtensionFragDepth ? "#extension GL_EXT_frag_depth : enable" : "", t.extensionDrawBuffers && t.rendererExtensionDrawBuffers ? "#extension GL_EXT_draw_buffers : require" : "", (t.extensionShaderTextureLOD || t.envMap || t.transmission) && t.rendererExtensionShaderTextureLod ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Ms).join("\n")
					}(n),
					x = function(t) {
						const e = [];
						for (const n in t) {
							const r = t[n];
							!1 !== r && e.push("#define " + n + " " + r)
						}
						return e.join("\n")
					}(l),
					_ = o.createProgram();
				let w, A, T = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
				n.isRawShaderMaterial ? (w = [x].filter(Ms).join("\n"), w.length > 0 && (w += "\n"), A = [y, x].filter(Ms).join("\n"), A.length > 0 && (A += "\n")) : (w = [Os(n), "#define SHADER_NAME " + n.shaderName, x, n.instancing ? "#define USE_INSTANCING" : "", n.instancingColor ? "#define USE_INSTANCING_COLOR" : "", n.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define MAX_BONES " + n.maxBones, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + m : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.displacementMap && n.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.skinning ? "#define USE_SKINNING" : "", n.useVertexTexture ? "#define BONE_TEXTURE" : "", n.morphTargets ? "#define USE_MORPHTARGETS" : "", n.morphNormals && !1 === n.flatShading ? "#define USE_MORPHNORMALS" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_TEXTURE" : "", n.morphTargets && n.isWebGL2 ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "\tattribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "\tattribute vec3 instanceColor;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "\tattribute vec4 color;", "#elif defined( USE_COLOR )", "\tattribute vec3 color;", "#endif", "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Ms).join("\n"), A = [y, Os(n), "#define SHADER_NAME " + n.shaderName, x, n.useFog && n.fog ? "#define USE_FOG" : "", n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "", n.map ? "#define USE_MAP" : "", n.matcap ? "#define USE_MATCAP" : "", n.envMap ? "#define USE_ENVMAP" : "", n.envMap ? "#define " + f : "", n.envMap ? "#define " + m : "", n.envMap ? "#define " + v : "", n.lightMap ? "#define USE_LIGHTMAP" : "", n.aoMap ? "#define USE_AOMAP" : "", n.emissiveMap ? "#define USE_EMISSIVEMAP" : "", n.bumpMap ? "#define USE_BUMPMAP" : "", n.normalMap ? "#define USE_NORMALMAP" : "", n.normalMap && n.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", n.normalMap && n.tangentSpaceNormalMap ? "#define TANGENTSPACE_NORMALMAP" : "", n.clearcoat ? "#define USE_CLEARCOAT" : "", n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", n.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", n.specularMap ? "#define USE_SPECULARMAP" : "", n.specularIntensityMap ? "#define USE_SPECULARINTENSITYMAP" : "", n.specularColorMap ? "#define USE_SPECULARCOLORMAP" : "", n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", n.metalnessMap ? "#define USE_METALNESSMAP" : "", n.alphaMap ? "#define USE_ALPHAMAP" : "", n.alphaTest ? "#define USE_ALPHATEST" : "", n.sheen ? "#define USE_SHEEN" : "", n.sheenColorMap ? "#define USE_SHEENCOLORMAP" : "", n.sheenRoughnessMap ? "#define USE_SHEENROUGHNESSMAP" : "", n.transmission ? "#define USE_TRANSMISSION" : "", n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", n.thicknessMap ? "#define USE_THICKNESSMAP" : "", n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", n.vertexTangents ? "#define USE_TANGENT" : "", n.vertexColors || n.instancingColor ? "#define USE_COLOR" : "", n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", n.vertexUvs ? "#define USE_UV" : "", n.uvsVertexOnly ? "#define UVS_VERTEX_ONLY" : "", n.gradientMap ? "#define USE_GRADIENTMAP" : "", n.flatShading ? "#define FLAT_SHADED" : "", n.doubleSided ? "#define DOUBLE_SIDED" : "", n.flipSided ? "#define FLIP_SIDED" : "", n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", n.shadowMapEnabled ? "#define " + d : "", n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", n.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", n.logarithmicDepthBuffer && n.rendererExtensionFragDepth ? "#define USE_LOGDEPTHBUF_EXT" : "", (n.extensionShaderTextureLOD || n.envMap) && n.rendererExtensionShaderTextureLod ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", 0 !== n.toneMapping ? "#define TONE_MAPPING" : "", 0 !== n.toneMapping ? bi.tonemapping_pars_fragment : "", 0 !== n.toneMapping ? bs("toneMapping", n.toneMapping) : "", n.dithering ? "#define DITHERING" : "", n.transparent ? "" : "#define OPAQUE", bi.encodings_pars_fragment, As("linearToOutputTexel", n.outputEncoding), n.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Ms).join("\n")), c = Cs(c), c = Ss(c, n), c = Ts(c, n), h = Cs(h), h = Ss(h, n), h = Ts(h, n), c = Ps(c), h = Ps(h), n.isWebGL2 && !0 !== n.isRawShaderMaterial && (T = "#version 300 es\n", w = ["precision mediump sampler2DArray;", "#define attribute in", "#define varying out", "#define texture2D texture"].join("\n") + "\n" + w, A = ["#define varying in", n.glslVersion === bt ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", n.glslVersion === bt ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + A);
				const E = T + A + h,
					D = xs(o, 35633, T + w + c),
					L = xs(o, 35632, E);
				if (o.attachShader(_, D), o.attachShader(_, L), void 0 !== n.index0AttributeName ? o.bindAttribLocation(_, 0, n.index0AttributeName) : !0 === n.morphTargets && o.bindAttribLocation(_, 0, "position"), o.linkProgram(_), t.debug.checkShaderErrors) {
					const t = o.getProgramInfoLog(_).trim(),
						e = o.getShaderInfoLog(D).trim(),
						n = o.getShaderInfoLog(L).trim();
					let r = !0,
						l = !0;
					if (!1 === o.getProgramParameter(_, 35714)) {
						r = !1;
						const e = ws(o, D, "vertex"),
							n = ws(o, L, "fragment");
						console.error("THREE.WebGLProgram: Shader Error " + o.getError() + " - VALIDATE_STATUS " + o.getProgramParameter(_, 35715) + "\n\nProgram Info Log: " + t + "\n" + e + "\n" + n)
					} else "" !== t ? console.warn("THREE.WebGLProgram: Program Info Log:", t) : "" !== e && "" !== n || (l = !1);
					l && (this.diagnostics = {
						runnable: r,
						programLog: t,
						vertexShader: {
							log: e,
							prefix: w
						},
						fragmentShader: {
							log: n,
							prefix: A
						}
					})
				}
				let P, I;
				return o.deleteShader(D), o.deleteShader(L), this.getUniforms = function() {
					return void 0 === P && (P = new ys(o, _)), P
				}, this.getAttributes = function() {
					return void 0 === I && (I = function(t, e) {
						const n = {},
							r = t.getProgramParameter(e, 35721);
						for (let i = 0; i < r; i++) {
							const r = t.getActiveAttrib(e, i),
								o = r.name;
							let l = 1;
							35674 === r.type && (l = 2), 35675 === r.type && (l = 3), 35676 === r.type && (l = 4), n[o] = {
								type: r.type,
								location: t.getAttribLocation(e, o),
								locationSize: l
							}
						}
						return n
					}(o, _)), I
				}, this.destroy = function() {
					r.releaseStatesOfProgram(this), o.deleteProgram(_), this.program = void 0
				}, this.name = n.shaderName, this.id = _s++, this.cacheKey = e, this.usedTimes = 1, this.program = _, this.vertexShader = D, this.fragmentShader = L, this
			}
			let Hs = 0;
			class Ns {
				constructor() {
					this.shaderCache = new Map, this.materialCache = new Map
				}
				update(t) {
					const e = t.vertexShader,
						n = t.fragmentShader,
						r = this._getShaderStage(e),
						o = this._getShaderStage(n),
						l = this._getShaderCacheForMaterial(t);
					return !1 === l.has(r) && (l.add(r), r.usedTimes++), !1 === l.has(o) && (l.add(o), o.usedTimes++), this
				}
				remove(t) {
					const e = this.materialCache.get(t);
					for (const t of e) t.usedTimes--, 0 === t.usedTimes && this.shaderCache.delete(t);
					return this.materialCache.delete(t), this
				}
				getVertexShaderID(t) {
					return this._getShaderStage(t.vertexShader).id
				}
				getFragmentShaderID(t) {
					return this._getShaderStage(t.fragmentShader).id
				}
				dispose() {
					this.shaderCache.clear(), this.materialCache.clear()
				}
				_getShaderCacheForMaterial(t) {
					const e = this.materialCache;
					return !1 === e.has(t) && e.set(t, new Set), e.get(t)
				}
				_getShaderStage(code) {
					const t = this.shaderCache;
					if (!1 === t.has(code)) {
						const e = new Us;
						t.set(code, e)
					}
					return t.get(code)
				}
			}
			class Us {
				constructor() {
					this.id = Hs++, this.usedTimes = 0
				}
			}

			function zs(t, e, n, r, o, h, d) {
				const f = new Xe,
					m = new Ns,
					v = [],
					y = o.isWebGL2,
					x = o.logarithmicDepthBuffer,
					_ = o.floatVertexTextures,
					w = o.maxVertexUniforms,
					A = o.vertexTextures;
				let M = o.precision;
				const S = {
					MeshDepthMaterial: "depth",
					MeshDistanceMaterial: "distanceRGBA",
					MeshNormalMaterial: "normal",
					MeshBasicMaterial: "basic",
					MeshLambertMaterial: "lambert",
					MeshPhongMaterial: "phong",
					MeshToonMaterial: "toon",
					MeshStandardMaterial: "physical",
					MeshPhysicalMaterial: "physical",
					MeshMatcapMaterial: "matcap",
					LineBasicMaterial: "basic",
					LineDashedMaterial: "dashed",
					PointsMaterial: "points",
					ShadowMaterial: "shadow",
					SpriteMaterial: "sprite"
				};
				return {
					getParameters: function(h, f, v, T, object) {
						const E = T.fog,
							D = h.isMeshStandardMaterial ? T.environment : null,
							L = (h.isMeshStandardMaterial ? n : e).get(h.envMap || D),
							P = S[h.type],
							I = object.isSkinnedMesh ? function(object) {
								const t = object.skeleton.bones;
								if (_) return 1024; {
									const e = w,
										n = Math.floor((e - 20) / 4),
										r = Math.min(n, t.length);
									return r < t.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + t.length + " bones. This GPU supports " + r + "."), 0) : r
								}
							}(object) : 0;
						let B, O, F, H;
						if (null !== h.precision && (M = o.getMaxPrecision(h.precision), M !== h.precision && console.warn("THREE.WebGLProgram.getParameters:", h.precision, "not supported, using", M, "instead.")), P) {
							const t = Si[P];
							B = t.vertexShader, O = t.fragmentShader
						} else B = h.vertexShader, O = h.fragmentShader, m.update(h), F = m.getVertexShaderID(h), H = m.getFragmentShaderID(h);
						const N = t.getRenderTarget(),
							U = h.alphaTest > 0,
							z = h.clearcoat > 0;
						return {
							isWebGL2: y,
							shaderID: P,
							shaderName: h.type,
							vertexShader: B,
							fragmentShader: O,
							defines: h.defines,
							customVertexShaderID: F,
							customFragmentShaderID: H,
							isRawShaderMaterial: !0 === h.isRawShaderMaterial,
							glslVersion: h.glslVersion,
							precision: M,
							instancing: !0 === object.isInstancedMesh,
							instancingColor: !0 === object.isInstancedMesh && null !== object.instanceColor,
							supportsVertexTextures: A,
							outputEncoding: null === N ? t.outputEncoding : !0 === N.isXRRenderTarget ? N.texture.encoding : mt,
							map: !!h.map,
							matcap: !!h.matcap,
							envMap: !!L,
							envMapMode: L && L.mapping,
							envMapCubeUV: !!L && (L.mapping === C || L.mapping === R),
							lightMap: !!h.lightMap,
							aoMap: !!h.aoMap,
							emissiveMap: !!h.emissiveMap,
							bumpMap: !!h.bumpMap,
							normalMap: !!h.normalMap,
							objectSpaceNormalMap: 1 === h.normalMapType,
							tangentSpaceNormalMap: h.normalMapType === xt,
							decodeVideoTexture: !!h.map && !0 === h.map.isVideoTexture && h.map.encoding === gt,
							clearcoat: z,
							clearcoatMap: z && !!h.clearcoatMap,
							clearcoatRoughnessMap: z && !!h.clearcoatRoughnessMap,
							clearcoatNormalMap: z && !!h.clearcoatNormalMap,
							displacementMap: !!h.displacementMap,
							roughnessMap: !!h.roughnessMap,
							metalnessMap: !!h.metalnessMap,
							specularMap: !!h.specularMap,
							specularIntensityMap: !!h.specularIntensityMap,
							specularColorMap: !!h.specularColorMap,
							transparent: h.transparent,
							alphaMap: !!h.alphaMap,
							alphaTest: U,
							gradientMap: !!h.gradientMap,
							sheen: h.sheen > 0,
							sheenColorMap: !!h.sheenColorMap,
							sheenRoughnessMap: !!h.sheenRoughnessMap,
							transmission: h.transmission > 0,
							transmissionMap: !!h.transmissionMap,
							thicknessMap: !!h.thicknessMap,
							combine: h.combine,
							vertexTangents: !!h.normalMap && !!object.geometry && !!object.geometry.attributes.tangent,
							vertexColors: h.vertexColors,
							vertexAlphas: !0 === h.vertexColors && !!object.geometry && !!object.geometry.attributes.color && 4 === object.geometry.attributes.color.itemSize,
							vertexUvs: !!(h.map || h.bumpMap || h.normalMap || h.specularMap || h.alphaMap || h.emissiveMap || h.roughnessMap || h.metalnessMap || h.clearcoatMap || h.clearcoatRoughnessMap || h.clearcoatNormalMap || h.displacementMap || h.transmissionMap || h.thicknessMap || h.specularIntensityMap || h.specularColorMap || h.sheenColorMap || h.sheenRoughnessMap),
							uvsVertexOnly: !(h.map || h.bumpMap || h.normalMap || h.specularMap || h.alphaMap || h.emissiveMap || h.roughnessMap || h.metalnessMap || h.clearcoatNormalMap || h.transmission > 0 || h.transmissionMap || h.thicknessMap || h.specularIntensityMap || h.specularColorMap || h.sheen > 0 || h.sheenColorMap || h.sheenRoughnessMap || !h.displacementMap),
							fog: !!E,
							useFog: h.fog,
							fogExp2: E && E.isFogExp2,
							flatShading: !!h.flatShading,
							sizeAttenuation: h.sizeAttenuation,
							logarithmicDepthBuffer: x,
							skinning: !0 === object.isSkinnedMesh && I > 0,
							maxBones: I,
							useVertexTexture: _,
							morphTargets: !!object.geometry && !!object.geometry.morphAttributes.position,
							morphNormals: !!object.geometry && !!object.geometry.morphAttributes.normal,
							morphTargetsCount: object.geometry && object.geometry.morphAttributes.position ? object.geometry.morphAttributes.position.length : 0,
							numDirLights: f.directional.length,
							numPointLights: f.point.length,
							numSpotLights: f.spot.length,
							numRectAreaLights: f.rectArea.length,
							numHemiLights: f.hemi.length,
							numDirLightShadows: f.directionalShadowMap.length,
							numPointLightShadows: f.pointShadowMap.length,
							numSpotLightShadows: f.spotShadowMap.length,
							numClippingPlanes: d.numPlanes,
							numClipIntersection: d.numIntersection,
							dithering: h.dithering,
							shadowMapEnabled: t.shadowMap.enabled && v.length > 0,
							shadowMapType: t.shadowMap.type,
							toneMapping: h.toneMapped ? t.toneMapping : 0,
							physicallyCorrectLights: t.physicallyCorrectLights,
							premultipliedAlpha: h.premultipliedAlpha,
							doubleSided: h.side === c,
							flipSided: h.side === l,
							depthPacking: void 0 !== h.depthPacking && h.depthPacking,
							index0AttributeName: h.index0AttributeName,
							extensionDerivatives: h.extensions && h.extensions.derivatives,
							extensionFragDepth: h.extensions && h.extensions.fragDepth,
							extensionDrawBuffers: h.extensions && h.extensions.drawBuffers,
							extensionShaderTextureLOD: h.extensions && h.extensions.shaderTextureLOD,
							rendererExtensionFragDepth: y || r.has("EXT_frag_depth"),
							rendererExtensionDrawBuffers: y || r.has("WEBGL_draw_buffers"),
							rendererExtensionShaderTextureLod: y || r.has("EXT_shader_texture_lod"),
							customProgramCacheKey: h.customProgramCacheKey()
						}
					},
					getProgramCacheKey: function(e) {
						const n = [];
						if (e.shaderID ? n.push(e.shaderID) : (n.push(e.customVertexShaderID), n.push(e.customFragmentShaderID)), void 0 !== e.defines)
							for (const t in e.defines) n.push(t), n.push(e.defines[t]);
						return !1 === e.isRawShaderMaterial && (! function(t, e) {
							t.push(e.precision), t.push(e.outputEncoding), t.push(e.envMapMode), t.push(e.combine), t.push(e.vertexUvs), t.push(e.fogExp2), t.push(e.sizeAttenuation), t.push(e.maxBones), t.push(e.morphTargetsCount), t.push(e.numDirLights), t.push(e.numPointLights), t.push(e.numSpotLights), t.push(e.numHemiLights), t.push(e.numRectAreaLights), t.push(e.numDirLightShadows), t.push(e.numPointLightShadows), t.push(e.numSpotLightShadows), t.push(e.shadowMapType), t.push(e.toneMapping), t.push(e.numClippingPlanes), t.push(e.numClipIntersection)
						}(n, e), function(t, e) {
							f.disableAll(), e.isWebGL2 && f.enable(0);
							e.supportsVertexTextures && f.enable(1);
							e.instancing && f.enable(2);
							e.instancingColor && f.enable(3);
							e.map && f.enable(4);
							e.matcap && f.enable(5);
							e.envMap && f.enable(6);
							e.envMapCubeUV && f.enable(7);
							e.lightMap && f.enable(8);
							e.aoMap && f.enable(9);
							e.emissiveMap && f.enable(10);
							e.bumpMap && f.enable(11);
							e.normalMap && f.enable(12);
							e.objectSpaceNormalMap && f.enable(13);
							e.tangentSpaceNormalMap && f.enable(14);
							e.clearcoat && f.enable(15);
							e.clearcoatMap && f.enable(16);
							e.clearcoatRoughnessMap && f.enable(17);
							e.clearcoatNormalMap && f.enable(18);
							e.displacementMap && f.enable(19);
							e.specularMap && f.enable(20);
							e.roughnessMap && f.enable(21);
							e.metalnessMap && f.enable(22);
							e.gradientMap && f.enable(23);
							e.alphaMap && f.enable(24);
							e.alphaTest && f.enable(25);
							e.vertexColors && f.enable(26);
							e.vertexAlphas && f.enable(27);
							e.vertexUvs && f.enable(28);
							e.vertexTangents && f.enable(29);
							e.uvsVertexOnly && f.enable(30);
							e.fog && f.enable(31);
							t.push(f.mask), f.disableAll(), e.useFog && f.enable(0);
							e.flatShading && f.enable(1);
							e.logarithmicDepthBuffer && f.enable(2);
							e.skinning && f.enable(3);
							e.useVertexTexture && f.enable(4);
							e.morphTargets && f.enable(5);
							e.morphNormals && f.enable(6);
							e.premultipliedAlpha && f.enable(7);
							e.shadowMapEnabled && f.enable(8);
							e.physicallyCorrectLights && f.enable(9);
							e.doubleSided && f.enable(10);
							e.flipSided && f.enable(11);
							e.depthPacking && f.enable(12);
							e.dithering && f.enable(13);
							e.specularIntensityMap && f.enable(14);
							e.specularColorMap && f.enable(15);
							e.transmission && f.enable(16);
							e.transmissionMap && f.enable(17);
							e.thicknessMap && f.enable(18);
							e.sheen && f.enable(19);
							e.sheenColorMap && f.enable(20);
							e.sheenRoughnessMap && f.enable(21);
							e.decodeVideoTexture && f.enable(22);
							e.transparent && f.enable(23);
							t.push(f.mask)
						}(n, e), n.push(t.outputEncoding)), n.push(e.customProgramCacheKey), n.join()
					},
					getUniforms: function(t) {
						const e = S[t.type];
						let n;
						if (e) {
							const t = Si[e];
							n = ri.clone(t.uniforms)
						} else n = t.uniforms;
						return n
					},
					acquireProgram: function(e, n) {
						let r;
						for (let p = 0, t = v.length; p < t; p++) {
							const t = v[p];
							if (t.cacheKey === n) {
								r = t, ++r.usedTimes;
								break
							}
						}
						return void 0 === r && (r = new Fs(t, n, e, h), v.push(r)), r
					},
					releaseProgram: function(t) {
						if (0 == --t.usedTimes) {
							const i = v.indexOf(t);
							v[i] = v[v.length - 1], v.pop(), t.destroy()
						}
					},
					releaseShaderCache: function(t) {
						m.remove(t)
					},
					programs: v,
					dispose: function() {
						m.dispose()
					}
				}
			}

			function ks() {
				let t = new WeakMap;
				return {
					get: function(object) {
						let map = t.get(object);
						return void 0 === map && (map = {}, t.set(object, map)), map
					},
					remove: function(object) {
						t.delete(object)
					},
					update: function(object, e, n) {
						t.get(object)[e] = n
					},
					dispose: function() {
						t = new WeakMap
					}
				}
			}

			function Gs(a, b) {
				return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.material.id !== b.material.id ? a.material.id - b.material.id : a.z !== b.z ? a.z - b.z : a.id - b.id
			}

			function Vs(a, b) {
				return a.groupOrder !== b.groupOrder ? a.groupOrder - b.groupOrder : a.renderOrder !== b.renderOrder ? a.renderOrder - b.renderOrder : a.z !== b.z ? b.z - a.z : a.id - b.id
			}

			function Ws() {
				const t = [];
				let e = 0;
				const n = [],
					r = [],
					o = [];

				function l(object, n, r, o, l, c) {
					let h = t[e];
					return void 0 === h ? (h = {
						id: object.id,
						object: object,
						geometry: n,
						material: r,
						groupOrder: o,
						renderOrder: object.renderOrder,
						z: l,
						group: c
					}, t[e] = h) : (h.id = object.id, h.object = object, h.geometry = n, h.material = r, h.groupOrder = o, h.renderOrder = object.renderOrder, h.z = l, h.group = c), e++, h
				}
				return {
					opaque: n,
					transmissive: r,
					transparent: o,
					init: function() {
						e = 0, n.length = 0, r.length = 0, o.length = 0
					},
					push: function(object, t, e, c, h, d) {
						const f = l(object, t, e, c, h, d);
						e.transmission > 0 ? r.push(f) : !0 === e.transparent ? o.push(f) : n.push(f)
					},
					unshift: function(object, t, e, c, h, d) {
						const f = l(object, t, e, c, h, d);
						e.transmission > 0 ? r.unshift(f) : !0 === e.transparent ? o.unshift(f) : n.unshift(f)
					},
					finish: function() {
						for (let i = e, n = t.length; i < n; i++) {
							const e = t[i];
							if (null === e.id) break;
							e.id = null, e.object = null, e.geometry = null, e.material = null, e.group = null
						}
					},
					sort: function(t, e) {
						n.length > 1 && n.sort(t || Gs), r.length > 1 && r.sort(e || Vs), o.length > 1 && o.sort(e || Vs)
					}
				}
			}

			function js() {
				let t = new WeakMap;
				return {
					get: function(e, n) {
						let r;
						return !1 === t.has(e) ? (r = new Ws, t.set(e, [r])) : n >= t.get(e).length ? (r = new Ws, t.get(e).push(r)) : r = t.get(e)[n], r
					},
					dispose: function() {
						t = new WeakMap
					}
				}
			}

			function Xs() {
				const t = {};
				return {
					get: function(e) {
						if (void 0 !== t[e.id]) return t[e.id];
						let n;
						switch (e.type) {
							case "DirectionalLight":
								n = {
									direction: new re,
									color: new Qt
								};
								break;
							case "SpotLight":
								n = {
									position: new re,
									direction: new re,
									color: new Qt,
									distance: 0,
									coneCos: 0,
									penumbraCos: 0,
									decay: 0
								};
								break;
							case "PointLight":
								n = {
									position: new re,
									color: new Qt,
									distance: 0,
									decay: 0
								};
								break;
							case "HemisphereLight":
								n = {
									direction: new re,
									skyColor: new Qt,
									groundColor: new Qt
								};
								break;
							case "RectAreaLight":
								n = {
									color: new Qt,
									position: new re,
									halfWidth: new re,
									halfHeight: new re
								}
						}
						return t[e.id] = n, n
					}
				}
			}
			let Ys = 0;

			function Qs(t, e) {
				return (e.castShadow ? 1 : 0) - (t.castShadow ? 1 : 0)
			}

			function qs(t, e) {
				const n = new Xs,
					r = function() {
						const t = {};
						return {
							get: function(e) {
								if (void 0 !== t[e.id]) return t[e.id];
								let n;
								switch (e.type) {
									case "DirectionalLight":
									case "SpotLight":
										n = {
											shadowBias: 0,
											shadowNormalBias: 0,
											shadowRadius: 1,
											shadowMapSize: new Nt
										};
										break;
									case "PointLight":
										n = {
											shadowBias: 0,
											shadowNormalBias: 0,
											shadowRadius: 1,
											shadowMapSize: new Nt,
											shadowCameraNear: 1,
											shadowCameraFar: 1e3
										}
								}
								return t[e.id] = n, n
							}
						}
					}(),
					o = {
						version: 0,
						hash: {
							directionalLength: -1,
							pointLength: -1,
							spotLength: -1,
							rectAreaLength: -1,
							hemiLength: -1,
							numDirectionalShadows: -1,
							numPointShadows: -1,
							numSpotShadows: -1
						},
						ambient: [0, 0, 0],
						probe: [],
						directional: [],
						directionalShadow: [],
						directionalShadowMap: [],
						directionalShadowMatrix: [],
						spot: [],
						spotShadow: [],
						spotShadowMap: [],
						spotShadowMatrix: [],
						rectArea: [],
						rectAreaLTC1: null,
						rectAreaLTC2: null,
						point: [],
						pointShadow: [],
						pointShadowMap: [],
						pointShadowMatrix: [],
						hemi: []
					};
				for (let i = 0; i < 9; i++) o.probe.push(new re);
				const l = new re,
					c = new Oe,
					h = new Oe;
				return {
					setup: function(l, c) {
						let h = 0,
							g = 0,
							b = 0;
						for (let i = 0; i < 9; i++) o.probe[i].set(0, 0, 0);
						let d = 0,
							f = 0,
							m = 0,
							v = 0,
							y = 0,
							x = 0,
							_ = 0,
							w = 0;
						l.sort(Qs);
						const A = !0 !== c ? Math.PI : 1;
						for (let i = 0, t = l.length; i < t; i++) {
							const t = l[i],
								e = t.color,
								c = t.intensity,
								M = t.distance,
								S = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
							if (t.isAmbientLight) h += e.r * c * A, g += e.g * c * A, b += e.b * c * A;
							else if (t.isLightProbe)
								for (let e = 0; e < 9; e++) o.probe[e].addScaledVector(t.sh.coefficients[e], c);
							else if (t.isDirectionalLight) {
								const e = n.get(t);
								if (e.color.copy(t.color).multiplyScalar(t.intensity * A), t.castShadow) {
									const shadow = t.shadow,
										e = r.get(t);
									e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, o.directionalShadow[d] = e, o.directionalShadowMap[d] = S, o.directionalShadowMatrix[d] = t.shadow.matrix, x++
								}
								o.directional[d] = e, d++
							} else if (t.isSpotLight) {
								const l = n.get(t);
								if (l.position.setFromMatrixPosition(t.matrixWorld), l.color.copy(e).multiplyScalar(c * A), l.distance = M, l.coneCos = Math.cos(t.angle), l.penumbraCos = Math.cos(t.angle * (1 - t.penumbra)), l.decay = t.decay, t.castShadow) {
									const shadow = t.shadow,
										e = r.get(t);
									e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, o.spotShadow[m] = e, o.spotShadowMap[m] = S, o.spotShadowMatrix[m] = t.shadow.matrix, w++
								}
								o.spot[m] = l, m++
							} else if (t.isRectAreaLight) {
								const r = n.get(t);
								r.color.copy(e).multiplyScalar(c), r.halfWidth.set(.5 * t.width, 0, 0), r.halfHeight.set(0, .5 * t.height, 0), o.rectArea[v] = r, v++
							} else if (t.isPointLight) {
								const e = n.get(t);
								if (e.color.copy(t.color).multiplyScalar(t.intensity * A), e.distance = t.distance, e.decay = t.decay, t.castShadow) {
									const shadow = t.shadow,
										e = r.get(t);
									e.shadowBias = shadow.bias, e.shadowNormalBias = shadow.normalBias, e.shadowRadius = shadow.radius, e.shadowMapSize = shadow.mapSize, e.shadowCameraNear = shadow.camera.near, e.shadowCameraFar = shadow.camera.far, o.pointShadow[f] = e, o.pointShadowMap[f] = S, o.pointShadowMatrix[f] = t.shadow.matrix, _++
								}
								o.point[f] = e, f++
							} else if (t.isHemisphereLight) {
								const e = n.get(t);
								e.skyColor.copy(t.color).multiplyScalar(c * A), e.groundColor.copy(t.groundColor).multiplyScalar(c * A), o.hemi[y] = e, y++
							}
						}
						v > 0 && (e.isWebGL2 || !0 === t.has("OES_texture_float_linear") ? (o.rectAreaLTC1 = Mi.LTC_FLOAT_1, o.rectAreaLTC2 = Mi.LTC_FLOAT_2) : !0 === t.has("OES_texture_half_float_linear") ? (o.rectAreaLTC1 = Mi.LTC_HALF_1, o.rectAreaLTC2 = Mi.LTC_HALF_2) : console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")), o.ambient[0] = h, o.ambient[1] = g, o.ambient[2] = b;
						const M = o.hash;
						M.directionalLength === d && M.pointLength === f && M.spotLength === m && M.rectAreaLength === v && M.hemiLength === y && M.numDirectionalShadows === x && M.numPointShadows === _ && M.numSpotShadows === w || (o.directional.length = d, o.spot.length = m, o.rectArea.length = v, o.point.length = f, o.hemi.length = y, o.directionalShadow.length = x, o.directionalShadowMap.length = x, o.pointShadow.length = _, o.pointShadowMap.length = _, o.spotShadow.length = w, o.spotShadowMap.length = w, o.directionalShadowMatrix.length = x, o.pointShadowMatrix.length = _, o.spotShadowMatrix.length = w, M.directionalLength = d, M.pointLength = f, M.spotLength = m, M.rectAreaLength = v, M.hemiLength = y, M.numDirectionalShadows = x, M.numPointShadows = _, M.numSpotShadows = w, o.version = Ys++)
					},
					setupView: function(t, e) {
						let n = 0,
							r = 0,
							d = 0,
							f = 0,
							m = 0;
						const v = e.matrixWorldInverse;
						for (let i = 0, e = t.length; i < e; i++) {
							const e = t[i];
							if (e.isDirectionalLight) {
								const t = o.directional[n];
								t.direction.setFromMatrixPosition(e.matrixWorld), l.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(l), t.direction.transformDirection(v), n++
							} else if (e.isSpotLight) {
								const t = o.spot[d];
								t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(v), t.direction.setFromMatrixPosition(e.matrixWorld), l.setFromMatrixPosition(e.target.matrixWorld), t.direction.sub(l), t.direction.transformDirection(v), d++
							} else if (e.isRectAreaLight) {
								const t = o.rectArea[f];
								t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(v), h.identity(), c.copy(e.matrixWorld), c.premultiply(v), h.extractRotation(c), t.halfWidth.set(.5 * e.width, 0, 0), t.halfHeight.set(0, .5 * e.height, 0), t.halfWidth.applyMatrix4(h), t.halfHeight.applyMatrix4(h), f++
							} else if (e.isPointLight) {
								const t = o.point[r];
								t.position.setFromMatrixPosition(e.matrixWorld), t.position.applyMatrix4(v), r++
							} else if (e.isHemisphereLight) {
								const t = o.hemi[m];
								t.direction.setFromMatrixPosition(e.matrixWorld), t.direction.transformDirection(v), t.direction.normalize(), m++
							}
						}
					},
					state: o
				}
			}

			function Js(t, e) {
				const n = new qs(t, e),
					r = [],
					o = [];
				return {
					init: function() {
						r.length = 0, o.length = 0
					},
					state: {
						lightsArray: r,
						shadowsArray: o,
						lights: n
					},
					setupLights: function(t) {
						n.setup(r, t)
					},
					setupLightsView: function(t) {
						n.setupView(r, t)
					},
					pushLight: function(t) {
						r.push(t)
					},
					pushShadow: function(t) {
						o.push(t)
					}
				}
			}

			function Ks(t, e) {
				let n = new WeakMap;
				return {
					get: function(r, o = 0) {
						let l;
						return !1 === n.has(r) ? (l = new Js(t, e), n.set(r, [l])) : o >= n.get(r).length ? (l = new Js(t, e), n.get(r).push(l)) : l = n.get(r)[o], l
					},
					dispose: function() {
						n = new WeakMap
					}
				}
			}
			class Zs extends _n {
				constructor(t) {
					super(), this.type = "MeshDepthMaterial", this.depthPacking = vt, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.depthPacking = source.depthPacking, this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this
				}
			}
			Zs.prototype.isMeshDepthMaterial = !0;
			class $s extends _n {
				constructor(t) {
					super(), this.type = "MeshDistanceMaterial", this.referencePosition = new re, this.nearDistance = 1, this.farDistance = 1e3, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.fog = !1, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.referencePosition.copy(source.referencePosition), this.nearDistance = source.nearDistance, this.farDistance = source.farDistance, this.map = source.map, this.alphaMap = source.alphaMap, this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this
				}
			}
			$s.prototype.isMeshDistanceMaterial = !0;

			function ta(t, e, n) {
				let r = new xi;
				const d = new Nt,
					f = new Nt,
					m = new te,
					v = new Zs({
						depthPacking: yt
					}),
					y = new $s,
					x = {},
					_ = n.maxTextureSize,
					w = {
						0: l,
						1: o,
						2: c
					},
					A = new si({
						defines: {
							VSM_SAMPLES: 8
						},
						uniforms: {
							shadow_pass: {
								value: null
							},
							resolution: {
								value: new Nt
							},
							radius: {
								value: 4
							}
						},
						vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
						fragmentShader: "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"
					}),
					M = A.clone();
				M.defines.HORIZONTAL_PASS = 1;
				const S = new On;
				S.setAttribute("position", new Mn(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
				const T = new $n(S, A),
					E = this;

				function C(shadow, n) {
					const r = e.update(T);
					A.defines.VSM_SAMPLES !== shadow.blurSamples && (A.defines.VSM_SAMPLES = shadow.blurSamples, M.defines.VSM_SAMPLES = shadow.blurSamples, A.needsUpdate = !0, M.needsUpdate = !0), A.uniforms.shadow_pass.value = shadow.map.texture, A.uniforms.resolution.value = shadow.mapSize, A.uniforms.radius.value = shadow.radius, t.setRenderTarget(shadow.mapPass), t.clear(), t.renderBufferDirect(n, null, r, A, T, null), M.uniforms.shadow_pass.value = shadow.mapPass.texture, M.uniforms.resolution.value = shadow.mapSize, M.uniforms.radius.value = shadow.radius, t.setRenderTarget(shadow.map), t.clear(), t.renderBufferDirect(n, null, r, M, T, null)
				}

				function R(object, e, n, r, o, l, c) {
					let h = null;
					const d = !0 === r.isPointLight ? object.customDistanceMaterial : object.customDepthMaterial;
					if (h = void 0 !== d ? d : !0 === r.isPointLight ? y : v, t.localClippingEnabled && !0 === n.clipShadows && 0 !== n.clippingPlanes.length || n.displacementMap && 0 !== n.displacementScale || n.alphaMap && n.alphaTest > 0) {
						const t = h.uuid,
							e = n.uuid;
						let r = x[t];
						void 0 === r && (r = {}, x[t] = r);
						let o = r[e];
						void 0 === o && (o = h.clone(), r[e] = o), h = o
					}
					return h.visible = n.visible, h.wireframe = n.wireframe, h.side = 3 === c ? null !== n.shadowSide ? n.shadowSide : n.side : null !== n.shadowSide ? n.shadowSide : w[n.side], h.alphaMap = n.alphaMap, h.alphaTest = n.alphaTest, h.clipShadows = n.clipShadows, h.clippingPlanes = n.clippingPlanes, h.clipIntersection = n.clipIntersection, h.displacementMap = n.displacementMap, h.displacementScale = n.displacementScale, h.displacementBias = n.displacementBias, h.wireframeLinewidth = n.wireframeLinewidth, h.linewidth = n.linewidth, !0 === r.isPointLight && !0 === h.isMeshDistanceMaterial && (h.referencePosition.setFromMatrixPosition(r.matrixWorld), h.nearDistance = o, h.farDistance = l), h
				}

				function D(object, n, o, l, c) {
					if (!1 === object.visible) return;
					if (object.layers.test(n.layers) && (object.isMesh || object.isLine || object.isPoints) && (object.castShadow || object.receiveShadow && 3 === c) && (!object.frustumCulled || r.intersectsObject(object))) {
						object.modelViewMatrix.multiplyMatrices(o.matrixWorldInverse, object.matrixWorld);
						const n = e.update(object),
							r = object.material;
						if (Array.isArray(r)) {
							const e = n.groups;
							for (let h = 0, d = e.length; h < d; h++) {
								const d = e[h],
									f = r[d.materialIndex];
								if (f && f.visible) {
									const e = R(object, 0, f, l, o.near, o.far, c);
									t.renderBufferDirect(o, null, n, e, object, d)
								}
							}
						} else if (r.visible) {
							const e = R(object, 0, r, l, o.near, o.far, c);
							t.renderBufferDirect(o, null, n, e, object, null)
						}
					}
					const h = object.children;
					for (let i = 0, t = h.length; i < t; i++) D(h[i], n, o, l, c)
				}
				this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function(e, n, o) {
					if (!1 === E.enabled) return;
					if (!1 === E.autoUpdate && !1 === E.needsUpdate) return;
					if (0 === e.length) return;
					const l = t.getRenderTarget(),
						c = t.getActiveCubeFace(),
						v = t.getActiveMipmapLevel(),
						y = t.state;
					y.setBlending(h), y.buffers.color.setClear(1, 1, 1, 1), y.buffers.depth.setTest(!0), y.setScissorTest(!1);
					for (let i = 0, l = e.length; i < l; i++) {
						const l = e[i],
							shadow = l.shadow;
						if (void 0 === shadow) {
							console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
							continue
						}
						if (!1 === shadow.autoUpdate && !1 === shadow.needsUpdate) continue;
						d.copy(shadow.mapSize);
						const c = shadow.getFrameExtents();
						if (d.multiply(c), f.copy(shadow.mapSize), (d.x > _ || d.y > _) && (d.x > _ && (f.x = Math.floor(_ / c.x), d.x = f.x * c.x, shadow.mapSize.x = f.x), d.y > _ && (f.y = Math.floor(_ / c.y), d.y = f.y * c.y, shadow.mapSize.y = f.y)), null === shadow.map && !shadow.isPointLightShadow && 3 === this.type) {
							const t = {
								minFilter: F,
								magFilter: F,
								format: Y
							};
							shadow.map = new ee(d.x, d.y, t), shadow.map.texture.name = l.name + ".shadowMap", shadow.mapPass = new ee(d.x, d.y, t), shadow.camera.updateProjectionMatrix()
						}
						if (null === shadow.map) {
							const t = {
								minFilter: I,
								magFilter: I,
								format: Y
							};
							shadow.map = new ee(d.x, d.y, t), shadow.map.texture.name = l.name + ".shadowMap", shadow.camera.updateProjectionMatrix()
						}
						t.setRenderTarget(shadow.map), t.clear();
						const h = shadow.getViewportCount();
						for (let t = 0; t < h; t++) {
							const e = shadow.getViewport(t);
							m.set(f.x * e.x, f.y * e.y, f.x * e.z, f.y * e.w), y.viewport(m), shadow.updateMatrices(l, t), r = shadow.getFrustum(), D(n, o, shadow.camera, l, this.type)
						}
						shadow.isPointLightShadow || 3 !== this.type || C(shadow, o), shadow.needsUpdate = !1
					}
					E.needsUpdate = !1, t.setRenderTarget(l, c, v)
				}
			}

			function ea(t, e, n) {
				const r = n.isWebGL2;
				const o = new function() {
						let e = !1;
						const n = new te;
						let r = null;
						const o = new te(0, 0, 0, 0);
						return {
							setMask: function(n) {
								r === n || e || (t.colorMask(n, n, n, n), r = n)
							},
							setLocked: function(t) {
								e = t
							},
							setClear: function(e, g, b, a, r) {
								!0 === r && (e *= a, g *= a, b *= a), n.set(e, g, b, a), !1 === o.equals(n) && (t.clearColor(e, g, b, a), o.copy(n))
							},
							reset: function() {
								e = !1, r = null, o.set(-1, 0, 0, 0)
							}
						}
					},
					M = new function() {
						let e = !1,
							n = null,
							r = null,
							o = null;
						return {
							setTest: function(t) {
								t ? st(2929) : at(2929)
							},
							setMask: function(r) {
								n === r || e || (t.depthMask(r), n = r)
							},
							setFunc: function(e) {
								if (r !== e) {
									if (e) switch (e) {
										case f:
											t.depthFunc(512);
											break;
										case m:
											t.depthFunc(519);
											break;
										case v:
											t.depthFunc(513);
											break;
										case y:
											t.depthFunc(515);
											break;
										case x:
											t.depthFunc(514);
											break;
										case _:
											t.depthFunc(518);
											break;
										case w:
											t.depthFunc(516);
											break;
										case A:
											t.depthFunc(517);
											break;
										default:
											t.depthFunc(515)
									} else t.depthFunc(515);
									r = e
								}
							},
							setLocked: function(t) {
								e = t
							},
							setClear: function(e) {
								o !== e && (t.clearDepth(e), o = e)
							},
							reset: function() {
								e = !1, n = null, r = null, o = null
							}
						}
					},
					S = new function() {
						let e = !1,
							n = null,
							r = null,
							o = null,
							l = null,
							c = null,
							h = null,
							d = null,
							f = null;
						return {
							setTest: function(t) {
								e || (t ? st(2960) : at(2960))
							},
							setMask: function(r) {
								n === r || e || (t.stencilMask(r), n = r)
							},
							setFunc: function(e, n, c) {
								r === e && o === n && l === c || (t.stencilFunc(e, n, c), r = e, o = n, l = c)
							},
							setOp: function(e, n, r) {
								c === e && h === n && d === r || (t.stencilOp(e, n, r), c = e, h = n, d = r)
							},
							setLocked: function(t) {
								e = t
							},
							setClear: function(e) {
								f !== e && (t.clearStencil(e), f = e)
							},
							reset: function() {
								e = !1, n = null, r = null, o = null, l = null, c = null, h = null, d = null, f = null
							}
						}
					};
				let T = {},
					E = {},
					C = new WeakMap,
					R = [],
					D = null,
					L = !1,
					P = null,
					I = null,
					B = null,
					O = null,
					F = null,
					H = null,
					N = null,
					U = !1,
					z = null,
					k = null,
					G = null,
					V = null,
					W = null;
				const j = t.getParameter(35661);
				let X = !1,
					Y = 0;
				const Q = t.getParameter(7938); - 1 !== Q.indexOf("WebGL") ? (Y = parseFloat(/^WebGL (\d)/.exec(Q)[1]), X = Y >= 1) : -1 !== Q.indexOf("OpenGL ES") && (Y = parseFloat(/^OpenGL ES (\d)/.exec(Q)[1]), X = Y >= 2);
				let J = null,
					K = {};
				const Z = t.getParameter(3088),
					$ = t.getParameter(2978),
					tt = (new te).fromArray(Z),
					et = (new te).fromArray($);

				function nt(e, n, r) {
					const data = new Uint8Array(4),
						o = t.createTexture();
					t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728);
					for (let i = 0; i < r; i++) t.texImage2D(n + i, 0, 6408, 1, 1, 0, 6408, 5121, data);
					return o
				}
				const it = {};

				function st(e) {
					!0 !== T[e] && (t.enable(e), T[e] = !0)
				}

				function at(e) {
					!1 !== T[e] && (t.disable(e), T[e] = !1)
				}
				it[3553] = nt(3553, 3553, 1), it[34067] = nt(34067, 34069, 6), o.setClear(0, 0, 0, 1), M.setClear(1), S.setClear(0), st(2929), M.setFunc(y), ht(!1), ut(1), st(2884), ct(h);
				const ot = {
					[d]: 32774,
					101: 32778,
					102: 32779
				};
				if (r) ot[103] = 32775, ot[104] = 32776;
				else {
					const t = e.get("EXT_blend_minmax");
					null !== t && (ot[103] = t.MIN_EXT, ot[104] = t.MAX_EXT)
				}
				const lt = {
					200: 0,
					201: 1,
					202: 768,
					204: 770,
					210: 776,
					208: 774,
					206: 772,
					203: 769,
					205: 771,
					209: 775,
					207: 773
				};

				function ct(e, n, r, o, l, c, f, m) {
					if (e !== h) {
						if (!1 === L && (st(3042), L = !0), 5 === e) l = l || n, c = c || r, f = f || o, n === I && l === F || (t.blendEquationSeparate(ot[n], ot[l]), I = n, F = l), r === B && o === O && c === H && f === N || (t.blendFuncSeparate(lt[r], lt[o], lt[c], lt[f]), B = r, O = o, H = c, N = f), P = e, U = null;
						else if (e !== P || m !== U) {
							if (I === d && F === d || (t.blendEquation(32774), I = d, F = d), m) switch (e) {
								case 1:
									t.blendFuncSeparate(1, 771, 1, 771);
									break;
								case 2:
									t.blendFunc(1, 1);
									break;
								case 3:
									t.blendFuncSeparate(0, 769, 0, 1);
									break;
								case 4:
									t.blendFuncSeparate(0, 768, 0, 770);
									break;
								default:
									console.error("THREE.WebGLState: Invalid blending: ", e)
							} else switch (e) {
								case 1:
									t.blendFuncSeparate(770, 771, 1, 771);
									break;
								case 2:
									t.blendFunc(770, 1);
									break;
								case 3:
									t.blendFuncSeparate(0, 769, 0, 1);
									break;
								case 4:
									t.blendFunc(0, 768);
									break;
								default:
									console.error("THREE.WebGLState: Invalid blending: ", e)
							}
							B = null, O = null, H = null, N = null, P = e, U = m
						}
					} else !0 === L && (at(3042), L = !1)
				}

				function ht(e) {
					z !== e && (e ? t.frontFace(2304) : t.frontFace(2305), z = e)
				}

				function ut(e) {
					0 !== e ? (st(2884), e !== k && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : at(2884), k = e
				}

				function pt(e, n, r) {
					e ? (st(32823), V === n && W === r || (t.polygonOffset(n, r), V = n, W = r)) : at(32823)
				}

				function ft(e) {
					void 0 === e && (e = 33984 + j - 1), J !== e && (t.activeTexture(e), J = e)
				}
				return {
					buffers: {
						color: o,
						depth: M,
						stencil: S
					},
					enable: st,
					disable: at,
					bindFramebuffer: function(e, n) {
						return E[e] !== n && (t.bindFramebuffer(e, n), E[e] = n, r && (36009 === e && (E[36160] = n), 36160 === e && (E[36009] = n)), !0)
					},
					drawBuffers: function(r, o) {
						let l = R,
							c = !1;
						if (r)
							if (l = C.get(o), void 0 === l && (l = [], C.set(o, l)), r.isWebGLMultipleRenderTargets) {
								const t = r.texture;
								if (l.length !== t.length || 36064 !== l[0]) {
									for (let i = 0, e = t.length; i < e; i++) l[i] = 36064 + i;
									l.length = t.length, c = !0
								}
							} else 36064 !== l[0] && (l[0] = 36064, c = !0);
						else 1029 !== l[0] && (l[0] = 1029, c = !0);
						c && (n.isWebGL2 ? t.drawBuffers(l) : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(l))
					},
					useProgram: function(e) {
						return D !== e && (t.useProgram(e), D = e, !0)
					},
					setBlending: ct,
					setMaterial: function(t, e) {
						t.side === c ? at(2884) : st(2884);
						let n = t.side === l;
						e && (n = !n), ht(n), 1 === t.blending && !1 === t.transparent ? ct(h) : ct(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), M.setFunc(t.depthFunc), M.setTest(t.depthTest), M.setMask(t.depthWrite), o.setMask(t.colorWrite);
						const r = t.stencilWrite;
						S.setTest(r), r && (S.setMask(t.stencilWriteMask), S.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask), S.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)), pt(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits), !0 === t.alphaToCoverage ? st(32926) : at(32926)
					},
					setFlipSided: ht,
					setCullFace: ut,
					setLineWidth: function(e) {
						e !== G && (X && t.lineWidth(e), G = e)
					},
					setPolygonOffset: pt,
					setScissorTest: function(t) {
						t ? st(3089) : at(3089)
					},
					activeTexture: ft,
					bindTexture: function(e, n) {
						null === J && ft();
						let r = K[J];
						void 0 === r && (r = {
							type: void 0,
							texture: void 0
						}, K[J] = r), r.type === e && r.texture === n || (t.bindTexture(e, n || it[e]), r.type = e, r.texture = n)
					},
					unbindTexture: function() {
						const e = K[J];
						void 0 !== e && void 0 !== e.type && (t.bindTexture(e.type, null), e.type = void 0, e.texture = void 0)
					},
					compressedTexImage2D: function() {
						try {
							t.compressedTexImage2D.apply(t, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texImage2D: function() {
						try {
							t.texImage2D.apply(t, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texImage3D: function() {
						try {
							t.texImage3D.apply(t, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texStorage2D: function() {
						try {
							t.texStorage2D.apply(t, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texStorage3D: function() {
						try {
							t.texStorage3D.apply(t, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texSubImage2D: function() {
						try {
							t.texSubImage2D.apply(t, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					texSubImage3D: function() {
						try {
							t.texSubImage3D.apply(t, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					compressedTexSubImage2D: function() {
						try {
							t.compressedTexSubImage2D.apply(t, arguments)
						} catch (t) {
							console.error("THREE.WebGLState:", t)
						}
					},
					scissor: function(e) {
						!1 === tt.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), tt.copy(e))
					},
					viewport: function(e) {
						!1 === et.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), et.copy(e))
					},
					reset: function() {
						t.disable(3042), t.disable(2884), t.disable(2929), t.disable(32823), t.disable(3089), t.disable(2960), t.disable(32926), t.blendEquation(32774), t.blendFunc(1, 0), t.blendFuncSeparate(1, 0, 1, 0), t.colorMask(!0, !0, !0, !0), t.clearColor(0, 0, 0, 0), t.depthMask(!0), t.depthFunc(513), t.clearDepth(1), t.stencilMask(4294967295), t.stencilFunc(519, 0, 4294967295), t.stencilOp(7680, 7680, 7680), t.clearStencil(0), t.cullFace(1029), t.frontFace(2305), t.polygonOffset(0, 0), t.activeTexture(33984), t.bindFramebuffer(36160, null), !0 === r && (t.bindFramebuffer(36009, null), t.bindFramebuffer(36008, null)), t.useProgram(null), t.lineWidth(1), t.scissor(0, 0, t.canvas.width, t.canvas.height), t.viewport(0, 0, t.canvas.width, t.canvas.height), T = {}, J = null, K = {}, E = {}, C = new WeakMap, R = [], D = null, L = !1, P = null, I = null, B = null, O = null, F = null, H = null, N = null, U = !1, z = null, k = null, G = null, V = null, W = null, tt.set(0, 0, t.canvas.width, t.canvas.height), et.set(0, 0, t.canvas.width, t.canvas.height), o.reset(), M.reset(), S.reset()
					}
				}
			}

			function na(t, e, n, r, o, l, c) {
				const h = o.isWebGL2,
					d = o.maxTextures,
					f = o.maxCubemapSize,
					m = o.maxTextureSize,
					v = o.maxSamples,
					y = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : void 0,
					x = new WeakMap;
				let _, w = !1;
				try {
					w = "undefined" != typeof OffscreenCanvas && null !== new OffscreenCanvas(1, 1).getContext("2d")
				} catch (t) {}

				function A(t, e) {
					return w ? new OffscreenCanvas(t, e) : kt("canvas")
				}

				function M(image, t, e, n) {
					let r = 1;
					if ((image.width > n || image.height > n) && (r = n / Math.max(image.width, image.height)), r < 1 || !0 === t) {
						if ("undefined" != typeof HTMLImageElement && image instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && image instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && image instanceof ImageBitmap) {
							const n = t ? Ft : Math.floor,
								o = n(r * image.width),
								l = n(r * image.height);
							void 0 === _ && (_ = A(o, l));
							const canvas = e ? A(o, l) : _;
							canvas.width = o, canvas.height = l;
							return canvas.getContext("2d").drawImage(image, 0, 0, o, l), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + image.width + "x" + image.height + ") to (" + o + "x" + l + ")."), canvas
						}
						return "data" in image && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + image.width + "x" + image.height + ")."), image
					}
					return image
				}

				function S(image) {
					return Bt(image.width) && Bt(image.height)
				}

				function T(t, e) {
					return t.generateMipmaps && e && t.minFilter !== I && t.minFilter !== F
				}

				function E(e) {
					t.generateMipmap(e)
				}

				function C(n, r, o, l, c = !1) {
					if (!1 === h) return r;
					if (null !== n) {
						if (void 0 !== t[n]) return t[n];
						console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + n + "'")
					}
					let d = r;
					return 6403 === r && (5126 === o && (d = 33326), 5131 === o && (d = 33325), 5121 === o && (d = 33321)), 33319 === r && (5126 === o && (d = 33328), 5131 === o && (d = 33327), 5121 === o && (d = 33323)), 6408 === r && (5126 === o && (d = 34836), 5131 === o && (d = 34842), 5121 === o && (d = l === gt && !1 === c ? 35907 : 32856), 32819 === o && (d = 32854), 32820 === o && (d = 32855)), 33325 !== d && 33326 !== d && 33327 !== d && 33328 !== d && 34842 !== d && 34836 !== d || e.get("EXT_color_buffer_float"), d
				}

				function R(t, image, e) {
					return !0 === T(t, e) || t.isFramebufferTexture && t.minFilter !== I && t.minFilter !== F ? Math.log2(Math.max(image.width, image.height)) + 1 : void 0 !== t.mipmaps && t.mipmaps.length > 0 ? t.mipmaps.length : t.isCompressedTexture && Array.isArray(t.image) ? image.mipmaps.length : 1
				}

				function U(t) {
					return t === I || t === B || t === O ? 9728 : 9729
				}

				function X(e) {
					const n = e.target;
					n.removeEventListener("dispose", X),
						function(e) {
							const n = r.get(e);
							if (void 0 === n.__webglInit) return;
							t.deleteTexture(n.__webglTexture), r.remove(e)
						}(n), n.isVideoTexture && x.delete(n), c.memory.textures--
				}

				function Q(e) {
					const n = e.target;
					n.removeEventListener("dispose", Q),
						function(e) {
							const n = e.texture,
								o = r.get(e),
								l = r.get(n);
							if (!e) return;
							void 0 !== l.__webglTexture && (t.deleteTexture(l.__webglTexture), c.memory.textures--);
							e.depthTexture && e.depthTexture.dispose();
							if (e.isWebGLCubeRenderTarget)
								for (let i = 0; i < 6; i++) t.deleteFramebuffer(o.__webglFramebuffer[i]), o.__webglDepthbuffer && t.deleteRenderbuffer(o.__webglDepthbuffer[i]);
							else t.deleteFramebuffer(o.__webglFramebuffer), o.__webglDepthbuffer && t.deleteRenderbuffer(o.__webglDepthbuffer), o.__webglMultisampledFramebuffer && t.deleteFramebuffer(o.__webglMultisampledFramebuffer), o.__webglColorRenderbuffer && t.deleteRenderbuffer(o.__webglColorRenderbuffer), o.__webglDepthRenderbuffer && t.deleteRenderbuffer(o.__webglDepthRenderbuffer);
							if (e.isWebGLMultipleRenderTargets)
								for (let i = 0, e = n.length; i < e; i++) {
									const e = r.get(n[i]);
									e.__webglTexture && (t.deleteTexture(e.__webglTexture), c.memory.textures--), r.remove(n[i])
								}
							r.remove(n), r.remove(e)
						}(n)
				}
				let Z = 0;

				function $(t, slot) {
					const e = r.get(t);
					if (t.isVideoTexture && function(t) {
							const e = c.render.frame;
							x.get(t) !== e && (x.set(t, e), t.update())
						}(t), t.version > 0 && e.__version !== t.version) {
						const image = t.image;
						if (void 0 === image) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");
						else {
							if (!1 !== image.complete) return void at(e, t, slot);
							console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
						}
					}
					n.activeTexture(33984 + slot), n.bindTexture(3553, e.__webglTexture)
				}

				function tt(e, slot) {
					const o = r.get(e);
					e.version > 0 && o.__version !== e.version ? function(e, r, slot) {
						if (6 !== r.image.length) return;
						st(e, r), n.activeTexture(33984 + slot), n.bindTexture(34067, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
						const o = r && (r.isCompressedTexture || r.image[0].isCompressedTexture),
							c = r.image[0] && r.image[0].isDataTexture,
							d = [];
						for (let i = 0; i < 6; i++) d[i] = o || c ? c ? r.image[i].image : r.image[i] : M(r.image[i], !1, !0, f), d[i] = ut(r, d[i]);
						const image = d[0],
							m = S(image) || h,
							v = l.convert(r.format, r.encoding),
							y = l.convert(r.type),
							x = C(r.internalFormat, v, y, r.encoding),
							_ = h && !0 !== r.isVideoTexture,
							w = void 0 === e.__version;
						let A, D = R(r, image, m);
						if (it(34067, r, m), o) {
							_ && w && n.texStorage2D(34067, D, x, image.width, image.height);
							for (let i = 0; i < 6; i++) {
								A = d[i].mipmaps;
								for (let t = 0; t < A.length; t++) {
									const e = A[t];
									r.format !== Y ? null !== v ? _ ? n.compressedTexSubImage2D(34069 + i, t, 0, 0, e.width, e.height, v, e.data) : n.compressedTexImage2D(34069 + i, t, x, e.width, e.height, 0, e.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : _ ? n.texSubImage2D(34069 + i, t, 0, 0, e.width, e.height, v, y, e.data) : n.texImage2D(34069 + i, t, x, e.width, e.height, 0, v, y, e.data)
								}
							}
						} else {
							A = r.mipmaps, _ && w && (A.length > 0 && D++, n.texStorage2D(34067, D, x, d[0].width, d[0].height));
							for (let i = 0; i < 6; i++)
								if (c) {
									_ ? n.texSubImage2D(34069 + i, 0, 0, 0, d[i].width, d[i].height, v, y, d[i].data) : n.texImage2D(34069 + i, 0, x, d[i].width, d[i].height, 0, v, y, d[i].data);
									for (let t = 0; t < A.length; t++) {
										const e = A[t].image[i].image;
										_ ? n.texSubImage2D(34069 + i, t + 1, 0, 0, e.width, e.height, v, y, e.data) : n.texImage2D(34069 + i, t + 1, x, e.width, e.height, 0, v, y, e.data)
									}
								} else {
									_ ? n.texSubImage2D(34069 + i, 0, 0, 0, v, y, d[i]) : n.texImage2D(34069 + i, 0, x, v, y, d[i]);
									for (let t = 0; t < A.length; t++) {
										const e = A[t];
										_ ? n.texSubImage2D(34069 + i, t + 1, 0, 0, v, y, e.image[i]) : n.texImage2D(34069 + i, t + 1, x, v, y, e.image[i])
									}
								}
						}
						T(r, m) && E(34067);
						e.__version = r.version, r.onUpdate && r.onUpdate(r)
					}(o, e, slot) : (n.activeTexture(33984 + slot), n.bindTexture(34067, o.__webglTexture))
				}
				const et = {
						[D]: 10497,
						[L]: 33071,
						[P]: 33648
					},
					nt = {
						[I]: 9728,
						[B]: 9984,
						[O]: 9986,
						[F]: 9729,
						[H]: 9985,
						[N]: 9987
					};

				function it(n, l, c) {
					if (c ? (t.texParameteri(n, 10242, et[l.wrapS]), t.texParameteri(n, 10243, et[l.wrapT]), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, et[l.wrapR]), t.texParameteri(n, 10240, nt[l.magFilter]), t.texParameteri(n, 10241, nt[l.minFilter])) : (t.texParameteri(n, 10242, 33071), t.texParameteri(n, 10243, 33071), 32879 !== n && 35866 !== n || t.texParameteri(n, 32882, 33071), l.wrapS === L && l.wrapT === L || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(n, 10240, U(l.magFilter)), t.texParameteri(n, 10241, U(l.minFilter)), l.minFilter !== I && l.minFilter !== F && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !0 === e.has("EXT_texture_filter_anisotropic")) {
						const c = e.get("EXT_texture_filter_anisotropic");
						if (l.type === V && !1 === e.has("OES_texture_float_linear")) return;
						if (!1 === h && l.type === W && !1 === e.has("OES_texture_half_float_linear")) return;
						(l.anisotropy > 1 || r.get(l).__currentAnisotropy) && (t.texParameterf(n, c.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(l.anisotropy, o.getMaxAnisotropy())), r.get(l).__currentAnisotropy = l.anisotropy)
					}
				}

				function st(e, n) {
					void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", X), e.__webglTexture = t.createTexture(), c.memory.textures++)
				}

				function at(e, r, slot) {
					let o = 3553;
					r.isDataTexture2DArray && (o = 35866), r.isDataTexture3D && (o = 32879), st(e, r), n.activeTexture(33984 + slot), n.bindTexture(o, e.__webglTexture), t.pixelStorei(37440, r.flipY), t.pixelStorei(37441, r.premultiplyAlpha), t.pixelStorei(3317, r.unpackAlignment), t.pixelStorei(37443, 0);
					const c = function(t) {
						return !h && (t.wrapS !== L || t.wrapT !== L || t.minFilter !== I && t.minFilter !== F)
					}(r) && !1 === S(r.image);
					let image = M(r.image, c, !1, m);
					image = ut(r, image);
					const d = S(image) || h,
						f = l.convert(r.format, r.encoding);
					let v, y = l.convert(r.type),
						x = C(r.internalFormat, f, y, r.encoding, r.isVideoTexture);
					it(o, r, d);
					const _ = r.mipmaps,
						w = h && !0 !== r.isVideoTexture,
						A = void 0 === e.__version,
						D = R(r, image, d);
					if (r.isDepthTexture) x = 6402, h ? x = r.type === V ? 36012 : r.type === G ? 33190 : r.type === j ? 35056 : 33189 : r.type === V && console.error("WebGLRenderer: Floating point depth texture requires WebGL2."), r.format === J && 6402 === x && r.type !== k && r.type !== G && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), r.type = k, y = l.convert(r.type)), r.format === K && 6402 === x && (x = 34041, r.type !== j && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), r.type = j, y = l.convert(r.type))), w && A ? n.texStorage2D(3553, 1, x, image.width, image.height) : n.texImage2D(3553, 0, x, image.width, image.height, 0, f, y, null);
					else if (r.isDataTexture)
						if (_.length > 0 && d) {
							w && A && n.texStorage2D(3553, D, x, _[0].width, _[0].height);
							for (let i = 0, t = _.length; i < t; i++) v = _[i], w ? n.texSubImage2D(3553, 0, 0, 0, v.width, v.height, f, y, v.data) : n.texImage2D(3553, i, x, v.width, v.height, 0, f, y, v.data);
							r.generateMipmaps = !1
						} else w ? (A && n.texStorage2D(3553, D, x, image.width, image.height), n.texSubImage2D(3553, 0, 0, 0, image.width, image.height, f, y, image.data)) : n.texImage2D(3553, 0, x, image.width, image.height, 0, f, y, image.data);
					else if (r.isCompressedTexture) {
						w && A && n.texStorage2D(3553, D, x, _[0].width, _[0].height);
						for (let i = 0, t = _.length; i < t; i++) v = _[i], r.format !== Y ? null !== f ? w ? n.compressedTexSubImage2D(3553, i, 0, 0, v.width, v.height, f, v.data) : n.compressedTexImage2D(3553, i, x, v.width, v.height, 0, v.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : w ? n.texSubImage2D(3553, i, 0, 0, v.width, v.height, f, y, v.data) : n.texImage2D(3553, i, x, v.width, v.height, 0, f, y, v.data)
					} else if (r.isDataTexture2DArray) w ? (A && n.texStorage3D(35866, D, x, image.width, image.height, image.depth), n.texSubImage3D(35866, 0, 0, 0, 0, image.width, image.height, image.depth, f, y, image.data)) : n.texImage3D(35866, 0, x, image.width, image.height, image.depth, 0, f, y, image.data);
					else if (r.isDataTexture3D) w ? (A && n.texStorage3D(32879, D, x, image.width, image.height, image.depth), n.texSubImage3D(32879, 0, 0, 0, 0, image.width, image.height, image.depth, f, y, image.data)) : n.texImage3D(32879, 0, x, image.width, image.height, image.depth, 0, f, y, image.data);
					else if (r.isFramebufferTexture) w && A ? n.texStorage2D(3553, D, x, image.width, image.height) : n.texImage2D(3553, 0, x, image.width, image.height, 0, f, y, null);
					else if (_.length > 0 && d) {
						w && A && n.texStorage2D(3553, D, x, _[0].width, _[0].height);
						for (let i = 0, t = _.length; i < t; i++) v = _[i], w ? n.texSubImage2D(3553, i, 0, 0, f, y, v) : n.texImage2D(3553, i, x, f, y, v);
						r.generateMipmaps = !1
					} else w ? (A && n.texStorage2D(3553, D, x, image.width, image.height), n.texSubImage2D(3553, 0, 0, 0, f, y, image)) : n.texImage2D(3553, 0, x, f, y, image);
					T(r, d) && E(o), e.__version = r.version, r.onUpdate && r.onUpdate(r)
				}

				function ot(e, o, c, h, d) {
					const f = l.convert(c.format, c.encoding),
						m = l.convert(c.type),
						v = C(c.internalFormat, f, m, c.encoding);
					r.get(o).__hasExternalTextures || (32879 === d || 35866 === d ? n.texImage3D(d, 0, v, o.width, o.height, o.depth, 0, f, m, null) : n.texImage2D(d, 0, v, o.width, o.height, 0, f, m, null)), n.bindFramebuffer(36160, e), o.useRenderToTexture ? y.framebufferTexture2DMultisampleEXT(36160, h, d, r.get(c).__webglTexture, 0, ht(o)) : t.framebufferTexture2D(36160, h, d, r.get(c).__webglTexture, 0), n.bindFramebuffer(36160, null)
				}

				function lt(e, n, r) {
					if (t.bindRenderbuffer(36161, e), n.depthBuffer && !n.stencilBuffer) {
						let o = 33189;
						if (r || n.useRenderToTexture) {
							const e = n.depthTexture;
							e && e.isDepthTexture && (e.type === V ? o = 36012 : e.type === G && (o = 33190));
							const r = ht(n);
							n.useRenderToTexture ? y.renderbufferStorageMultisampleEXT(36161, r, o, n.width, n.height) : t.renderbufferStorageMultisample(36161, r, o, n.width, n.height)
						} else t.renderbufferStorage(36161, o, n.width, n.height);
						t.framebufferRenderbuffer(36160, 36096, 36161, e)
					} else if (n.depthBuffer && n.stencilBuffer) {
						const o = ht(n);
						r && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, o, 35056, n.width, n.height) : n.useRenderToTexture ? y.renderbufferStorageMultisampleEXT(36161, o, 35056, n.width, n.height) : t.renderbufferStorage(36161, 34041, n.width, n.height), t.framebufferRenderbuffer(36160, 33306, 36161, e)
					} else {
						const e = !0 === n.isWebGLMultipleRenderTargets ? n.texture[0] : n.texture,
							o = l.convert(e.format, e.encoding),
							c = l.convert(e.type),
							h = C(e.internalFormat, o, c, e.encoding),
							d = ht(n);
						r && n.useRenderbuffer ? t.renderbufferStorageMultisample(36161, d, h, n.width, n.height) : n.useRenderToTexture ? y.renderbufferStorageMultisampleEXT(36161, d, h, n.width, n.height) : t.renderbufferStorage(36161, h, n.width, n.height)
					}
					t.bindRenderbuffer(36161, null)
				}

				function ct(e) {
					const o = r.get(e),
						l = !0 === e.isWebGLCubeRenderTarget;
					if (e.depthTexture && !o.__autoAllocateDepthBuffer) {
						if (l) throw new Error("target.depthTexture not supported in Cube render targets");
						! function(e, o) {
							if (o && o.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
							if (n.bindFramebuffer(36160, e), !o.depthTexture || !o.depthTexture.isDepthTexture) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
							r.get(o.depthTexture).__webglTexture && o.depthTexture.image.width === o.width && o.depthTexture.image.height === o.height || (o.depthTexture.image.width = o.width, o.depthTexture.image.height = o.height, o.depthTexture.needsUpdate = !0), $(o.depthTexture, 0);
							const l = r.get(o.depthTexture).__webglTexture,
								c = ht(o);
							if (o.depthTexture.format === J) o.useRenderToTexture ? y.framebufferTexture2DMultisampleEXT(36160, 36096, 3553, l, 0, c) : t.framebufferTexture2D(36160, 36096, 3553, l, 0);
							else {
								if (o.depthTexture.format !== K) throw new Error("Unknown depthTexture format");
								o.useRenderToTexture ? y.framebufferTexture2DMultisampleEXT(36160, 33306, 3553, l, 0, c) : t.framebufferTexture2D(36160, 33306, 3553, l, 0)
							}
						}(o.__webglFramebuffer, e)
					} else if (l) {
						o.__webglDepthbuffer = [];
						for (let i = 0; i < 6; i++) n.bindFramebuffer(36160, o.__webglFramebuffer[i]), o.__webglDepthbuffer[i] = t.createRenderbuffer(), lt(o.__webglDepthbuffer[i], e, !1)
					} else n.bindFramebuffer(36160, o.__webglFramebuffer), o.__webglDepthbuffer = t.createRenderbuffer(), lt(o.__webglDepthbuffer, e, !1);
					n.bindFramebuffer(36160, null)
				}

				function ht(t) {
					return h && (t.useRenderbuffer || t.useRenderToTexture) ? Math.min(v, t.samples) : 0
				}

				function ut(t, image) {
					const n = t.encoding,
						r = t.format,
						o = t.type;
					return !0 === t.isCompressedTexture || !0 === t.isVideoTexture || t.format === Mt || n !== mt && (n === gt ? !1 === h ? !0 === e.has("EXT_sRGB") && r === Y ? (t.format = Mt, t.minFilter = F, t.generateMipmaps = !1) : image = Jt.sRGBToLinear(image) : r === Y && o === z || console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture encoding:", n)), image
				}
				let pt = !1,
					ft = !1;
				this.allocateTextureUnit = function() {
					const t = Z;
					return t >= d && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + d), Z += 1, t
				}, this.resetTextureUnits = function() {
					Z = 0
				}, this.setTexture2D = $, this.setTexture2DArray = function(t, slot) {
					const e = r.get(t);
					t.version > 0 && e.__version !== t.version ? at(e, t, slot) : (n.activeTexture(33984 + slot), n.bindTexture(35866, e.__webglTexture))
				}, this.setTexture3D = function(t, slot) {
					const e = r.get(t);
					t.version > 0 && e.__version !== t.version ? at(e, t, slot) : (n.activeTexture(33984 + slot), n.bindTexture(32879, e.__webglTexture))
				}, this.setTextureCube = tt, this.rebindTextures = function(t, e, n) {
					const o = r.get(t);
					void 0 !== e && ot(o.__webglFramebuffer, t, t.texture, 36064, 3553), void 0 !== n && ct(t)
				}, this.setupRenderTarget = function(e) {
					const d = e.texture,
						f = r.get(e),
						m = r.get(d);
					e.addEventListener("dispose", Q), !0 !== e.isWebGLMultipleRenderTargets && (void 0 === m.__webglTexture && (m.__webglTexture = t.createTexture()), m.__version = d.version, c.memory.textures++);
					const v = !0 === e.isWebGLCubeRenderTarget,
						y = !0 === e.isWebGLMultipleRenderTargets,
						x = d.isDataTexture3D || d.isDataTexture2DArray,
						_ = S(e) || h;
					if (v) {
						f.__webglFramebuffer = [];
						for (let i = 0; i < 6; i++) f.__webglFramebuffer[i] = t.createFramebuffer()
					} else if (f.__webglFramebuffer = t.createFramebuffer(), y)
						if (o.drawBuffers) {
							const n = e.texture;
							for (let i = 0, e = n.length; i < e; i++) {
								const e = r.get(n[i]);
								void 0 === e.__webglTexture && (e.__webglTexture = t.createTexture(), c.memory.textures++)
							}
						} else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");
					else if (e.useRenderbuffer)
						if (h) {
							f.__webglMultisampledFramebuffer = t.createFramebuffer(), f.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, f.__webglColorRenderbuffer);
							const r = l.convert(d.format, d.encoding),
								o = l.convert(d.type),
								c = C(d.internalFormat, r, o, d.encoding),
								h = ht(e);
							t.renderbufferStorageMultisample(36161, h, c, e.width, e.height), n.bindFramebuffer(36160, f.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, f.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (f.__webglDepthRenderbuffer = t.createRenderbuffer(), lt(f.__webglDepthRenderbuffer, e, !0)), n.bindFramebuffer(36160, null)
						} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
					if (v) {
						n.bindTexture(34067, m.__webglTexture), it(34067, d, _);
						for (let i = 0; i < 6; i++) ot(f.__webglFramebuffer[i], e, d, 36064, 34069 + i);
						T(d, _) && E(34067), n.unbindTexture()
					} else if (y) {
						const t = e.texture;
						for (let i = 0, o = t.length; i < o; i++) {
							const o = t[i],
								l = r.get(o);
							n.bindTexture(3553, l.__webglTexture), it(3553, o, _), ot(f.__webglFramebuffer, e, o, 36064 + i, 3553), T(o, _) && E(3553)
						}
						n.unbindTexture()
					} else {
						let t = 3553;
						if (x)
							if (h) {
								t = d.isDataTexture3D ? 32879 : 35866
							} else console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.");
						n.bindTexture(t, m.__webglTexture), it(t, d, _), ot(f.__webglFramebuffer, e, d, 36064, t), T(d, _) && E(t), n.unbindTexture()
					}
					e.depthBuffer && ct(e)
				}, this.updateRenderTargetMipmap = function(t) {
					const e = S(t) || h,
						o = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
					for (let i = 0, l = o.length; i < l; i++) {
						const l = o[i];
						if (T(l, e)) {
							const e = t.isWebGLCubeRenderTarget ? 34067 : 3553,
								o = r.get(l).__webglTexture;
							n.bindTexture(e, o), E(e), n.unbindTexture()
						}
					}
				}, this.updateMultisampleRenderTarget = function(e) {
					if (e.useRenderbuffer)
						if (h) {
							const o = e.width,
								l = e.height;
							let mask = 16384;
							const c = [36064],
								h = e.stencilBuffer ? 33306 : 36096;
							e.depthBuffer && c.push(h), e.ignoreDepthForMultisampleCopy || (e.depthBuffer && (mask |= 256), e.stencilBuffer && (mask |= 1024));
							const d = r.get(e);
							n.bindFramebuffer(36008, d.__webglMultisampledFramebuffer), n.bindFramebuffer(36009, d.__webglFramebuffer), e.ignoreDepthForMultisampleCopy && (t.invalidateFramebuffer(36008, [h]), t.invalidateFramebuffer(36009, [h])), t.blitFramebuffer(0, 0, o, l, 0, 0, o, l, mask, 9728), t.invalidateFramebuffer(36008, c), n.bindFramebuffer(36008, null), n.bindFramebuffer(36009, d.__webglMultisampledFramebuffer)
						} else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
				}, this.setupDepthRenderbuffer = ct, this.setupFrameBufferTexture = ot, this.safeSetTexture2D = function(t, slot) {
					t && t.isWebGLRenderTarget && (!1 === pt && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), pt = !0), t = t.texture), $(t, slot)
				}, this.safeSetTextureCube = function(t, slot) {
					t && t.isWebGLCubeRenderTarget && (!1 === ft && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), ft = !0), t = t.texture), tt(t, slot)
				}
			}

			function ia(t, e, n) {
				const r = n.isWebGL2;
				return {
					convert: function(p, t = null) {
						let n;
						if (p === z) return 5121;
						if (1017 === p) return 32819;
						if (1018 === p) return 32820;
						if (1010 === p) return 5120;
						if (1011 === p) return 5122;
						if (p === k) return 5123;
						if (1013 === p) return 5124;
						if (p === G) return 5125;
						if (p === V) return 5126;
						if (p === W) return r ? 5131 : (n = e.get("OES_texture_half_float"), null !== n ? n.HALF_FLOAT_OES : null);
						if (1021 === p) return 6406;
						if (p === Y) return 6408;
						if (p === Q) return 6409;
						if (1025 === p) return 6410;
						if (p === J) return 6402;
						if (p === K) return 34041;
						if (p === Z) return 6403;
						if (p === X) return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"), 6408;
						if (p === Mt) return n = e.get("EXT_sRGB"), null !== n ? n.SRGB_ALPHA_EXT : null;
						if (1029 === p) return 36244;
						if (p === $) return 33319;
						if (1031 === p) return 33320;
						if (1033 === p) return 36249;
						if (p === tt || p === et || p === nt || p === it)
							if (t === gt) {
								if (n = e.get("WEBGL_compressed_texture_s3tc_srgb"), null === n) return null;
								if (p === tt) return n.COMPRESSED_SRGB_S3TC_DXT1_EXT;
								if (p === et) return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
								if (p === nt) return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
								if (p === it) return n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
							} else {
								if (n = e.get("WEBGL_compressed_texture_s3tc"), null === n) return null;
								if (p === tt) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
								if (p === et) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
								if (p === nt) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
								if (p === it) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
							} if (35840 === p || 35841 === p || 35842 === p || 35843 === p) {
							if (n = e.get("WEBGL_compressed_texture_pvrtc"), null === n) return null;
							if (35840 === p) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
							if (35841 === p) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
							if (35842 === p) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
							if (35843 === p) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
						}
						if (36196 === p) return n = e.get("WEBGL_compressed_texture_etc1"), null !== n ? n.COMPRESSED_RGB_ETC1_WEBGL : null;
						if (37492 === p || 37496 === p) {
							if (n = e.get("WEBGL_compressed_texture_etc"), null === n) return null;
							if (37492 === p) return t === gt ? n.COMPRESSED_SRGB8_ETC2 : n.COMPRESSED_RGB8_ETC2;
							if (37496 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : n.COMPRESSED_RGBA8_ETC2_EAC
						}
						if (37808 === p || 37809 === p || 37810 === p || 37811 === p || 37812 === p || 37813 === p || 37814 === p || 37815 === p || 37816 === p || 37817 === p || 37818 === p || 37819 === p || 37820 === p || 37821 === p) {
							if (n = e.get("WEBGL_compressed_texture_astc"), null === n) return null;
							if (37808 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : n.COMPRESSED_RGBA_ASTC_4x4_KHR;
							if (37809 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : n.COMPRESSED_RGBA_ASTC_5x4_KHR;
							if (37810 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : n.COMPRESSED_RGBA_ASTC_5x5_KHR;
							if (37811 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : n.COMPRESSED_RGBA_ASTC_6x5_KHR;
							if (37812 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : n.COMPRESSED_RGBA_ASTC_6x6_KHR;
							if (37813 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : n.COMPRESSED_RGBA_ASTC_8x5_KHR;
							if (37814 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : n.COMPRESSED_RGBA_ASTC_8x6_KHR;
							if (37815 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : n.COMPRESSED_RGBA_ASTC_8x8_KHR;
							if (37816 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : n.COMPRESSED_RGBA_ASTC_10x5_KHR;
							if (37817 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : n.COMPRESSED_RGBA_ASTC_10x6_KHR;
							if (37818 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : n.COMPRESSED_RGBA_ASTC_10x8_KHR;
							if (37819 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : n.COMPRESSED_RGBA_ASTC_10x10_KHR;
							if (37820 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : n.COMPRESSED_RGBA_ASTC_12x10_KHR;
							if (37821 === p) return t === gt ? n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : n.COMPRESSED_RGBA_ASTC_12x12_KHR
						}
						if (36492 === p) {
							if (n = e.get("EXT_texture_compression_bptc"), null === n) return null;
							if (36492 === p) return t === gt ? n.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : n.COMPRESSED_RGBA_BPTC_UNORM_EXT
						}
						return p === j ? r ? 34042 : (n = e.get("WEBGL_depth_texture"), null !== n ? n.UNSIGNED_INT_24_8_WEBGL : null) : void 0
					}
				}
			}
			class ra extends oi {
				constructor(t = []) {
					super(), this.cameras = t
				}
			}
			ra.prototype.isArrayCamera = !0;
			class sa extends on {
				constructor() {
					super(), this.type = "Group"
				}
			}
			sa.prototype.isGroup = !0;
			const aa = {
				type: "move"
			};
			class oa {
				constructor() {
					this._targetRay = null, this._grip = null, this._hand = null
				}
				getHandSpace() {
					return null === this._hand && (this._hand = new sa, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
						pinching: !1
					}), this._hand
				}
				getTargetRaySpace() {
					return null === this._targetRay && (this._targetRay = new sa, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new re, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new re), this._targetRay
				}
				getGripSpace() {
					return null === this._grip && (this._grip = new sa, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new re, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new re), this._grip
				}
				dispatchEvent(t) {
					return null !== this._targetRay && this._targetRay.dispatchEvent(t), null !== this._grip && this._grip.dispatchEvent(t), null !== this._hand && this._hand.dispatchEvent(t), this
				}
				disconnect(t) {
					return this.dispatchEvent({
						type: "disconnected",
						data: t
					}), null !== this._targetRay && (this._targetRay.visible = !1), null !== this._grip && (this._grip.visible = !1), null !== this._hand && (this._hand.visible = !1), this
				}
				update(t, e, n) {
					let r = null,
						o = null,
						l = null;
					const c = this._targetRay,
						h = this._grip,
						d = this._hand;
					if (t && "visible-blurred" !== e.session.visibilityState)
						if (null !== c && (r = e.getPose(t.targetRaySpace, n), null !== r && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), r.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = !1, r.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = !1, this.dispatchEvent(aa))), d && t.hand) {
							l = !0;
							for (const r of t.hand.values()) {
								const t = e.getJointPose(r, n);
								if (void 0 === d.joints[r.jointName]) {
									const t = new sa;
									t.matrixAutoUpdate = !1, t.visible = !1, d.joints[r.jointName] = t, d.add(t)
								}
								const o = d.joints[r.jointName];
								null !== t && (o.matrix.fromArray(t.transform.matrix), o.matrix.decompose(o.position, o.rotation, o.scale), o.jointRadius = t.radius), o.visible = null !== t
							}
							const r = d.joints["index-finger-tip"],
								o = d.joints["thumb-tip"],
								c = r.position.distanceTo(o.position),
								h = .02,
								f = .005;
							d.inputState.pinching && c > h + f ? (d.inputState.pinching = !1, this.dispatchEvent({
								type: "pinchend",
								handedness: t.handedness,
								target: this
							})) : !d.inputState.pinching && c <= h - f && (d.inputState.pinching = !0, this.dispatchEvent({
								type: "pinchstart",
								handedness: t.handedness,
								target: this
							}))
						} else null !== h && t.gripSpace && (o = e.getPose(t.gripSpace, n), null !== o && (h.matrix.fromArray(o.transform.matrix), h.matrix.decompose(h.position, h.rotation, h.scale), o.linearVelocity ? (h.hasLinearVelocity = !0, h.linearVelocity.copy(o.linearVelocity)) : h.hasLinearVelocity = !1, o.angularVelocity ? (h.hasAngularVelocity = !0, h.angularVelocity.copy(o.angularVelocity)) : h.hasAngularVelocity = !1));
					return null !== c && (c.visible = null !== r), null !== h && (h.visible = null !== o), null !== d && (d.visible = null !== l), this
				}
			}
			class la extends Zt {
				constructor(t, e, n, r, o, l, c, h, d, f) {
					if ((f = void 0 !== f ? f : J) !== J && f !== K) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
					void 0 === n && f === J && (n = k), void 0 === n && f === K && (n = j), super(null, r, o, l, c, h, f, n, d), this.image = {
						width: t,
						height: e
					}, this.magFilter = void 0 !== c ? c : I, this.minFilter = void 0 !== h ? h : I, this.flipY = !1, this.generateMipmaps = !1
				}
			}
			la.prototype.isDepthTexture = !0;
			class ca extends St {
				constructor(t, e) {
					super();
					const n = this;
					let r = null,
						o = 1,
						l = null,
						c = "local-floor";
					const h = t.extensions.has("WEBGL_multisampled_render_to_texture");
					let d = null,
						f = null,
						m = null,
						v = null,
						y = !1,
						x = null;
					const _ = e.getContextAttributes();
					let w = null,
						A = null;
					const M = [],
						S = new Map,
						T = new oi;
					T.layers.enable(1), T.viewport = new te;
					const E = new oi;
					E.layers.enable(2), E.viewport = new te;
					const C = [T, E],
						R = new ra;
					R.layers.enable(1), R.layers.enable(2);
					let D = null,
						L = null;

					function P(t) {
						const e = S.get(t.inputSource);
						e && e.dispatchEvent({
							type: t.type,
							data: t.inputSource
						})
					}

					function I() {
						S.forEach((function(t, e) {
							t.disconnect(e)
						})), S.clear(), D = null, L = null, t.setRenderTarget(w), v = null, m = null, f = null, r = null, A = null, U.stop(), n.isPresenting = !1, n.dispatchEvent({
							type: "sessionend"
						})
					}

					function B(t) {
						const e = r.inputSources;
						for (let i = 0; i < M.length; i++) S.set(e[i], M[i]);
						for (let i = 0; i < t.removed.length; i++) {
							const e = t.removed[i],
								n = S.get(e);
							n && (n.dispatchEvent({
								type: "disconnected",
								data: e
							}), S.delete(e))
						}
						for (let i = 0; i < t.added.length; i++) {
							const e = t.added[i],
								n = S.get(e);
							n && n.dispatchEvent({
								type: "connected",
								data: e
							})
						}
					}
					this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function(t) {
						let e = M[t];
						return void 0 === e && (e = new oa, M[t] = e), e.getTargetRaySpace()
					}, this.getControllerGrip = function(t) {
						let e = M[t];
						return void 0 === e && (e = new oa, M[t] = e), e.getGripSpace()
					}, this.getHand = function(t) {
						let e = M[t];
						return void 0 === e && (e = new oa, M[t] = e), e.getHandSpace()
					}, this.setFramebufferScaleFactor = function(t) {
						o = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
					}, this.setReferenceSpaceType = function(t) {
						c = t, !0 === n.isPresenting && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
					}, this.getReferenceSpace = function() {
						return l
					}, this.getBaseLayer = function() {
						return null !== m ? m : v
					}, this.getBinding = function() {
						return f
					}, this.getFrame = function() {
						return x
					}, this.getSession = function() {
						return r
					}, this.setSession = async function(d) {
						if (r = d, null !== r) {
							if (w = t.getRenderTarget(), r.addEventListener("select", P), r.addEventListener("selectstart", P), r.addEventListener("selectend", P), r.addEventListener("squeeze", P), r.addEventListener("squeezestart", P), r.addEventListener("squeezeend", P), r.addEventListener("end", I), r.addEventListener("inputsourceschange", B), !0 !== _.xrCompatible && await e.makeXRCompatible(), void 0 === r.renderState.layers || !1 === t.capabilities.isWebGL2) {
								const n = {
									antialias: void 0 !== r.renderState.layers || _.antialias,
									alpha: _.alpha,
									depth: _.depth,
									stencil: _.stencil,
									framebufferScaleFactor: o
								};
								v = new XRWebGLLayer(r, e, n), r.updateRenderState({
									baseLayer: v
								}), A = new ee(v.framebufferWidth, v.framebufferHeight, {
									format: Y,
									type: z,
									encoding: t.outputEncoding
								})
							} else {
								y = _.antialias;
								let n = null,
									l = null,
									c = null;
								_.depth && (c = _.stencil ? 35056 : 33190, n = _.stencil ? K : J, l = _.stencil ? j : k);
								const d = {
									colorFormat: t.outputEncoding === gt ? 35907 : 32856,
									depthFormat: c,
									scaleFactor: o
								};
								f = new XRWebGLBinding(r, e), m = f.createProjectionLayer(d), r.updateRenderState({
									layers: [m]
								}), A = y ? new ne(m.textureWidth, m.textureHeight, {
									format: Y,
									type: z,
									depthTexture: new la(m.textureWidth, m.textureHeight, l, void 0, void 0, void 0, void 0, void 0, void 0, n),
									stencilBuffer: _.stencil,
									ignoreDepth: m.ignoreDepthValues,
									useRenderToTexture: h,
									encoding: t.outputEncoding
								}) : new ee(m.textureWidth, m.textureHeight, {
									format: Y,
									type: z,
									depthTexture: new la(m.textureWidth, m.textureHeight, l, void 0, void 0, void 0, void 0, void 0, void 0, n),
									stencilBuffer: _.stencil,
									ignoreDepth: m.ignoreDepthValues,
									encoding: t.outputEncoding
								})
							}
							A.isXRRenderTarget = !0, this.setFoveation(1), l = await r.requestReferenceSpace(c), U.setContext(r), U.start(), n.isPresenting = !0, n.dispatchEvent({
								type: "sessionstart"
							})
						}
					};
					const O = new re,
						F = new re;

					function H(t, e) {
						null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.copy(t.matrixWorld).invert()
					}
					this.updateCamera = function(t) {
						if (null === r) return;
						R.near = E.near = T.near = t.near, R.far = E.far = T.far = t.far, D === R.near && L === R.far || (r.updateRenderState({
							depthNear: R.near,
							depthFar: R.far
						}), D = R.near, L = R.far);
						const e = t.parent,
							n = R.cameras;
						H(R, e);
						for (let i = 0; i < n.length; i++) H(n[i], e);
						R.matrixWorld.decompose(R.position, R.quaternion, R.scale), t.position.copy(R.position), t.quaternion.copy(R.quaternion), t.scale.copy(R.scale), t.matrix.copy(R.matrix), t.matrixWorld.copy(R.matrixWorld);
						const o = t.children;
						for (let i = 0, t = o.length; i < t; i++) o[i].updateMatrixWorld(!0);
						2 === n.length ? function(t, e, n) {
							O.setFromMatrixPosition(e.matrixWorld), F.setFromMatrixPosition(n.matrixWorld);
							const r = O.distanceTo(F),
								o = e.projectionMatrix.elements,
								l = n.projectionMatrix.elements,
								c = o[14] / (o[10] - 1),
								h = o[14] / (o[10] + 1),
								d = (o[9] + 1) / o[5],
								f = (o[9] - 1) / o[5],
								m = (o[8] - 1) / o[0],
								v = (l[8] + 1) / l[0],
								y = c * m,
								x = c * v,
								_ = r / (-m + v),
								w = _ * -m;
							e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(w), t.translateZ(_), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.copy(t.matrixWorld).invert();
							const A = c + _,
								M = h + _,
								S = y - w,
								T = x + (r - w),
								E = d * h / M * A,
								C = f * h / M * A;
							t.projectionMatrix.makePerspective(S, T, E, C, A, M)
						}(R, T, E) : R.projectionMatrix.copy(T.projectionMatrix)
					}, this.getCamera = function() {
						return R
					}, this.getFoveation = function() {
						return null !== m ? m.fixedFoveation : null !== v ? v.fixedFoveation : void 0
					}, this.setFoveation = function(t) {
						null !== m && (m.fixedFoveation = t), null !== v && void 0 !== v.fixedFoveation && (v.fixedFoveation = t)
					};
					let N = null;
					const U = new _i;
					U.setAnimationLoop((function(time, e) {
						if (d = e.getViewerPose(l), x = e, null !== d) {
							const e = d.views;
							null !== v && (t.setRenderTargetFramebuffer(A, v.framebuffer), t.setRenderTarget(A));
							let n = !1;
							e.length !== R.cameras.length && (R.cameras.length = 0, n = !0);
							for (let i = 0; i < e.length; i++) {
								const view = e[i];
								let r = null;
								if (null !== v) r = v.getViewport(view);
								else {
									const e = f.getViewSubImage(m, view);
									r = e.viewport, 0 === i && (t.setRenderTargetTextures(A, e.colorTexture, m.ignoreDepthValues ? void 0 : e.depthStencilTexture), t.setRenderTarget(A))
								}
								const o = C[i];
								o.matrix.fromArray(view.transform.matrix), o.projectionMatrix.fromArray(view.projectionMatrix), o.viewport.set(r.x, r.y, r.width, r.height), 0 === i && R.matrix.copy(o.matrix), !0 === n && R.cameras.push(o)
							}
						}
						const n = r.inputSources;
						for (let i = 0; i < M.length; i++) {
							const t = M[i],
								r = n[i];
							t.update(r, e, l)
						}
						N && N(time, e), x = null
					})), this.setAnimationLoop = function(t) {
						N = t
					}, this.dispose = function() {}
				}
			}

			function ha(t) {
				function e(e, n) {
					e.opacity.value = n.opacity, n.color && e.diffuse.value.copy(n.color), n.emissive && e.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity), n.map && (e.map.value = n.map), n.alphaMap && (e.alphaMap.value = n.alphaMap), n.specularMap && (e.specularMap.value = n.specularMap), n.alphaTest > 0 && (e.alphaTest.value = n.alphaTest);
					const r = t.get(n).envMap;
					let o, l;
					r && (e.envMap.value = r, e.flipEnvMap.value = r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1, e.reflectivity.value = n.reflectivity, e.ior.value = n.ior, e.refractionRatio.value = n.refractionRatio), n.lightMap && (e.lightMap.value = n.lightMap, e.lightMapIntensity.value = n.lightMapIntensity), n.aoMap && (e.aoMap.value = n.aoMap, e.aoMapIntensity.value = n.aoMapIntensity), n.map ? o = n.map : n.specularMap ? o = n.specularMap : n.displacementMap ? o = n.displacementMap : n.normalMap ? o = n.normalMap : n.bumpMap ? o = n.bumpMap : n.roughnessMap ? o = n.roughnessMap : n.metalnessMap ? o = n.metalnessMap : n.alphaMap ? o = n.alphaMap : n.emissiveMap ? o = n.emissiveMap : n.clearcoatMap ? o = n.clearcoatMap : n.clearcoatNormalMap ? o = n.clearcoatNormalMap : n.clearcoatRoughnessMap ? o = n.clearcoatRoughnessMap : n.specularIntensityMap ? o = n.specularIntensityMap : n.specularColorMap ? o = n.specularColorMap : n.transmissionMap ? o = n.transmissionMap : n.thicknessMap ? o = n.thicknessMap : n.sheenColorMap ? o = n.sheenColorMap : n.sheenRoughnessMap && (o = n.sheenRoughnessMap), void 0 !== o && (o.isWebGLRenderTarget && (o = o.texture), !0 === o.matrixAutoUpdate && o.updateMatrix(), e.uvTransform.value.copy(o.matrix)), n.aoMap ? l = n.aoMap : n.lightMap && (l = n.lightMap), void 0 !== l && (l.isWebGLRenderTarget && (l = l.texture), !0 === l.matrixAutoUpdate && l.updateMatrix(), e.uv2Transform.value.copy(l.matrix))
				}

				function n(e, n) {
					e.roughness.value = n.roughness, e.metalness.value = n.metalness, n.roughnessMap && (e.roughnessMap.value = n.roughnessMap), n.metalnessMap && (e.metalnessMap.value = n.metalnessMap), n.emissiveMap && (e.emissiveMap.value = n.emissiveMap), n.bumpMap && (e.bumpMap.value = n.bumpMap, e.bumpScale.value = n.bumpScale, n.side === l && (e.bumpScale.value *= -1)), n.normalMap && (e.normalMap.value = n.normalMap, e.normalScale.value.copy(n.normalScale), n.side === l && e.normalScale.value.negate()), n.displacementMap && (e.displacementMap.value = n.displacementMap, e.displacementScale.value = n.displacementScale, e.displacementBias.value = n.displacementBias);
					t.get(n).envMap && (e.envMapIntensity.value = n.envMapIntensity)
				}
				return {
					refreshFogUniforms: function(t, e) {
						t.fogColor.value.copy(e.color), e.isFog ? (t.fogNear.value = e.near, t.fogFar.value = e.far) : e.isFogExp2 && (t.fogDensity.value = e.density)
					},
					refreshMaterialUniforms: function(t, r, o, c, h) {
						r.isMeshBasicMaterial ? e(t, r) : r.isMeshLambertMaterial ? (e(t, r), function(t, e) {
							e.emissiveMap && (t.emissiveMap.value = e.emissiveMap)
						}(t, r)) : r.isMeshToonMaterial ? (e(t, r), function(t, e) {
							e.gradientMap && (t.gradientMap.value = e.gradientMap);
							e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
							e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === l && (t.bumpScale.value *= -1));
							e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === l && t.normalScale.value.negate());
							e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
						}(t, r)) : r.isMeshPhongMaterial ? (e(t, r), function(t, e) {
							t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap);
							e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === l && (t.bumpScale.value *= -1));
							e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === l && t.normalScale.value.negate());
							e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
						}(t, r)) : r.isMeshStandardMaterial ? (e(t, r), r.isMeshPhysicalMaterial ? function(t, e, r) {
							n(t, e), t.ior.value = e.ior, e.sheen > 0 && (t.sheenColor.value.copy(e.sheenColor).multiplyScalar(e.sheen), t.sheenRoughness.value = e.sheenRoughness, e.sheenColorMap && (t.sheenColorMap.value = e.sheenColorMap), e.sheenRoughnessMap && (t.sheenRoughnessMap.value = e.sheenRoughnessMap));
							e.clearcoat > 0 && (t.clearcoat.value = e.clearcoat, t.clearcoatRoughness.value = e.clearcoatRoughness, e.clearcoatMap && (t.clearcoatMap.value = e.clearcoatMap), e.clearcoatRoughnessMap && (t.clearcoatRoughnessMap.value = e.clearcoatRoughnessMap), e.clearcoatNormalMap && (t.clearcoatNormalScale.value.copy(e.clearcoatNormalScale), t.clearcoatNormalMap.value = e.clearcoatNormalMap, e.side === l && t.clearcoatNormalScale.value.negate()));
							e.transmission > 0 && (t.transmission.value = e.transmission, t.transmissionSamplerMap.value = r.texture, t.transmissionSamplerSize.value.set(r.width, r.height), e.transmissionMap && (t.transmissionMap.value = e.transmissionMap), t.thickness.value = e.thickness, e.thicknessMap && (t.thicknessMap.value = e.thicknessMap), t.attenuationDistance.value = e.attenuationDistance, t.attenuationColor.value.copy(e.attenuationColor));
							t.specularIntensity.value = e.specularIntensity, t.specularColor.value.copy(e.specularColor), e.specularIntensityMap && (t.specularIntensityMap.value = e.specularIntensityMap);
							e.specularColorMap && (t.specularColorMap.value = e.specularColorMap)
						}(t, r, h) : n(t, r)) : r.isMeshMatcapMaterial ? (e(t, r), function(t, e) {
							e.matcap && (t.matcap.value = e.matcap);
							e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === l && (t.bumpScale.value *= -1));
							e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === l && t.normalScale.value.negate());
							e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
						}(t, r)) : r.isMeshDepthMaterial ? (e(t, r), function(t, e) {
							e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
						}(t, r)) : r.isMeshDistanceMaterial ? (e(t, r), function(t, e) {
							e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias);
							t.referencePosition.value.copy(e.referencePosition), t.nearDistance.value = e.nearDistance, t.farDistance.value = e.farDistance
						}(t, r)) : r.isMeshNormalMaterial ? (e(t, r), function(t, e) {
							e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, e.side === l && (t.bumpScale.value *= -1));
							e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), e.side === l && t.normalScale.value.negate());
							e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
						}(t, r)) : r.isLineBasicMaterial ? (function(t, e) {
							t.diffuse.value.copy(e.color), t.opacity.value = e.opacity
						}(t, r), r.isLineDashedMaterial && function(t, e) {
							t.dashSize.value = e.dashSize, t.totalSize.value = e.dashSize + e.gapSize, t.scale.value = e.scale
						}(t, r)) : r.isPointsMaterial ? function(t, e, n, r) {
							t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.size.value = e.size * n, t.scale.value = .5 * r, e.map && (t.map.value = e.map);
							e.alphaMap && (t.alphaMap.value = e.alphaMap);
							e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
							let o;
							e.map ? o = e.map : e.alphaMap && (o = e.alphaMap);
							void 0 !== o && (!0 === o.matrixAutoUpdate && o.updateMatrix(), t.uvTransform.value.copy(o.matrix))
						}(t, r, o, c) : r.isSpriteMaterial ? function(t, e) {
							t.diffuse.value.copy(e.color), t.opacity.value = e.opacity, t.rotation.value = e.rotation, e.map && (t.map.value = e.map);
							e.alphaMap && (t.alphaMap.value = e.alphaMap);
							e.alphaTest > 0 && (t.alphaTest.value = e.alphaTest);
							let n;
							e.map ? n = e.map : e.alphaMap && (n = e.alphaMap);
							void 0 !== n && (!0 === n.matrixAutoUpdate && n.updateMatrix(), t.uvTransform.value.copy(n.matrix))
						}(t, r) : r.isShadowMaterial ? (t.color.value.copy(r.color), t.opacity.value = r.opacity) : r.isShaderMaterial && (r.uniformsNeedUpdate = !1)
					}
				}
			}

			function ua(t = {}) {
				const e = void 0 !== t.canvas ? t.canvas : function() {
						const canvas = kt("canvas");
						return canvas.style.display = "block", canvas
					}(),
					n = void 0 !== t.context ? t.context : null,
					r = void 0 !== t.alpha && t.alpha,
					h = void 0 === t.depth || t.depth,
					d = void 0 === t.stencil || t.stencil,
					f = void 0 !== t.antialias && t.antialias,
					m = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
					v = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
					y = void 0 !== t.powerPreference ? t.powerPreference : "default",
					x = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat;
				let _ = null,
					w = null;
				const A = [],
					M = [];
				this.domElement = e, this.debug = {
					checkShaderErrors: !0
				}, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.outputEncoding = mt, this.physicallyCorrectLights = !1, this.toneMapping = 0, this.toneMappingExposure = 1;
				const S = this;
				let T = !1,
					E = 0,
					C = 0,
					R = null,
					D = -1,
					P = null;
				const B = new te,
					O = new te;
				let F = null,
					H = e.width,
					U = e.height,
					k = 1,
					G = null,
					j = null;
				const X = new te(0, 0, H, U),
					Q = new te(0, 0, H, U);
				let J = !1;
				const K = new xi;
				let Z = !1,
					$ = !1,
					tt = null;
				const et = new Oe,
					nt = new re,
					it = {
						background: null,
						fog: null,
						environment: null,
						overrideMaterial: null,
						isScene: !0
					};

				function st() {
					return null === R ? k : 1
				}
				let at, ot, lt, ct, ht, ut, pt, ft, gt, vt, yt, xt, _t, wt, At, bt, Mt, St, Tt, Et, Ct, Rt, Dt, Lt = n;

				function Pt(t, n) {
					for (let i = 0; i < t.length; i++) {
						const r = t[i],
							o = e.getContext(r, n);
						if (null !== o) return o
					}
					return null
				}
				try {
					const t = {
						alpha: !0,
						depth: h,
						stencil: d,
						antialias: f,
						premultipliedAlpha: m,
						preserveDrawingBuffer: v,
						powerPreference: y,
						failIfMajorPerformanceCaveat: x
					};
					if ("setAttribute" in e && e.setAttribute("data-engine", "three.js r137"), e.addEventListener("webglcontextlost", Ot, !1), e.addEventListener("webglcontextrestored", Ft, !1), null === Lt) {
						const e = ["webgl2", "webgl", "experimental-webgl"];
						if (!0 === S.isWebGL1Renderer && e.shift(), Lt = Pt(e, t), null === Lt) throw Pt(e) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
					}
					void 0 === Lt.getShaderPrecisionFormat && (Lt.getShaderPrecisionFormat = function() {
						return {
							rangeMin: 1,
							rangeMax: 1,
							precision: 1
						}
					})
				} catch (t) {
					throw console.error("THREE.WebGLRenderer: " + t.message), t
				}

				function It() {
					at = new nr(Lt), ot = new Ri(Lt, at, t), at.init(ot), Rt = new ia(Lt, at, ot), lt = new ea(Lt, at, ot), ct = new sr(Lt), ht = new ks, ut = new na(Lt, at, lt, ht, ot, Rt, ct), pt = new Li(S), ft = new er(S), gt = new wi(Lt, ot), Dt = new Ei(Lt, at, gt, ot), vt = new ir(Lt, gt, ct, Dt), yt = new dr(Lt, vt, gt, ct), Tt = new ur(Lt, ot, ut), bt = new Di(ht), xt = new zs(S, pt, ft, at, ot, Dt, bt), _t = new ha(ht), wt = new js, At = new Ks(at, ot), St = new Ti(S, pt, lt, yt, r, m), Mt = new ta(S, yt, ot), Et = new Ci(Lt, at, ct, ot), Ct = new rr(Lt, at, ct, ot), ct.programs = xt.programs, S.capabilities = ot, S.extensions = at, S.properties = ht, S.renderLists = wt, S.shadowMap = Mt, S.state = lt, S.info = ct
				}
				It();
				const Bt = new ca(S, Lt);

				function Ot(t) {
					t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), T = !0
				}

				function Ft() {
					console.log("THREE.WebGLRenderer: Context Restored."), T = !1;
					const t = ct.autoReset,
						e = Mt.enabled,
						n = Mt.autoUpdate,
						r = Mt.needsUpdate,
						o = Mt.type;
					It(), ct.autoReset = t, Mt.enabled = e, Mt.autoUpdate = n, Mt.needsUpdate = r, Mt.type = o
				}

				function Ht(t) {
					const e = t.target;
					e.removeEventListener("dispose", Ht),
						function(t) {
							(function(t) {
								const e = ht.get(t).programs;
								void 0 !== e && (e.forEach((function(t) {
									xt.releaseProgram(t)
								})), t.isShaderMaterial && xt.releaseShaderCache(t))
							})(t), ht.remove(t)
						}(e)
				}
				this.xr = Bt, this.getContext = function() {
					return Lt
				}, this.getContextAttributes = function() {
					return Lt.getContextAttributes()
				}, this.forceContextLoss = function() {
					const t = at.get("WEBGL_lose_context");
					t && t.loseContext()
				}, this.forceContextRestore = function() {
					const t = at.get("WEBGL_lose_context");
					t && t.restoreContext()
				}, this.getPixelRatio = function() {
					return k
				}, this.setPixelRatio = function(t) {
					void 0 !== t && (k = t, this.setSize(H, U, !1))
				}, this.getSize = function(t) {
					return t.set(H, U)
				}, this.setSize = function(t, n, r) {
					Bt.isPresenting ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (H = t, U = n, e.width = Math.floor(t * k), e.height = Math.floor(n * k), !1 !== r && (e.style.width = t + "px", e.style.height = n + "px"), this.setViewport(0, 0, t, n))
				}, this.getDrawingBufferSize = function(t) {
					return t.set(H * k, U * k).floor()
				}, this.setDrawingBufferSize = function(t, n, r) {
					H = t, U = n, k = r, e.width = Math.floor(t * r), e.height = Math.floor(n * r), this.setViewport(0, 0, t, n)
				}, this.getCurrentViewport = function(t) {
					return t.copy(B)
				}, this.getViewport = function(t) {
					return t.copy(X)
				}, this.setViewport = function(t, e, n, r) {
					t.isVector4 ? X.set(t.x, t.y, t.z, t.w) : X.set(t, e, n, r), lt.viewport(B.copy(X).multiplyScalar(k).floor())
				}, this.getScissor = function(t) {
					return t.copy(Q)
				}, this.setScissor = function(t, e, n, r) {
					t.isVector4 ? Q.set(t.x, t.y, t.z, t.w) : Q.set(t, e, n, r), lt.scissor(O.copy(Q).multiplyScalar(k).floor())
				}, this.getScissorTest = function() {
					return J
				}, this.setScissorTest = function(t) {
					lt.setScissorTest(J = t)
				}, this.setOpaqueSort = function(t) {
					G = t
				}, this.setTransparentSort = function(t) {
					j = t
				}, this.getClearColor = function(t) {
					return t.copy(St.getClearColor())
				}, this.setClearColor = function() {
					St.setClearColor.apply(St, arguments)
				}, this.getClearAlpha = function() {
					return St.getClearAlpha()
				}, this.setClearAlpha = function() {
					St.setClearAlpha.apply(St, arguments)
				}, this.clear = function(t, e, n) {
					let r = 0;
					(void 0 === t || t) && (r |= 16384), (void 0 === e || e) && (r |= 256), (void 0 === n || n) && (r |= 1024), Lt.clear(r)
				}, this.clearColor = function() {
					this.clear(!0, !1, !1)
				}, this.clearDepth = function() {
					this.clear(!1, !0, !1)
				}, this.clearStencil = function() {
					this.clear(!1, !1, !0)
				}, this.dispose = function() {
					e.removeEventListener("webglcontextlost", Ot, !1), e.removeEventListener("webglcontextrestored", Ft, !1), wt.dispose(), At.dispose(), ht.dispose(), pt.dispose(), ft.dispose(), yt.dispose(), Dt.dispose(), xt.dispose(), Bt.dispose(), Bt.removeEventListener("sessionstart", Ut), Bt.removeEventListener("sessionend", zt), tt && (tt.dispose(), tt = null), Gt.stop()
				}, this.renderBufferDirect = function(t, e, n, r, object, o) {
					null === e && (e = it);
					const l = object.isMesh && object.matrixWorld.determinant() < 0,
						c = function(t, e, n, r, object) {
							!0 !== e.isScene && (e = it);
							ut.resetTextureUnits();
							const o = e.fog,
								l = r.isMeshStandardMaterial ? e.environment : null,
								c = null === R ? S.outputEncoding : !0 === R.isXRRenderTarget ? R.texture.encoding : mt,
								h = (r.isMeshStandardMaterial ? ft : pt).get(r.envMap || l),
								d = !0 === r.vertexColors && !!n.attributes.color && 4 === n.attributes.color.itemSize,
								f = !!r.normalMap && !!n.attributes.tangent,
								m = !!n.morphAttributes.position,
								v = !!n.morphAttributes.normal,
								y = n.morphAttributes.position ? n.morphAttributes.position.length : 0,
								x = r.toneMapped ? S.toneMapping : 0,
								_ = ht.get(r),
								A = w.state.lights;
							if (!0 === Z && (!0 === $ || t !== P)) {
								const e = t === P && r.id === D;
								bt.setState(r, t, e)
							}
							let M = !1;
							r.version === _.__version ? _.needsLights && _.lightsStateVersion !== A.state.version || _.outputEncoding !== c || object.isInstancedMesh && !1 === _.instancing ? M = !0 : object.isInstancedMesh || !0 !== _.instancing ? object.isSkinnedMesh && !1 === _.skinning ? M = !0 : object.isSkinnedMesh || !0 !== _.skinning ? _.envMap !== h || r.fog && _.fog !== o ? M = !0 : void 0 === _.numClippingPlanes || _.numClippingPlanes === bt.numPlanes && _.numIntersection === bt.numIntersection ? (_.vertexAlphas !== d || _.vertexTangents !== f || _.morphTargets !== m || _.morphNormals !== v || _.toneMapping !== x || !0 === ot.isWebGL2 && _.morphTargetsCount !== y) && (M = !0) : M = !0 : M = !0 : M = !0 : (M = !0, _.__version = r.version);
							let T = _.currentProgram;
							!0 === M && (T = Yt(r, e, object));
							let E = !1,
								C = !1,
								L = !1;
							const I = T.getUniforms(),
								B = _.uniforms;
							lt.useProgram(T.program) && (E = !0, C = !0, L = !0);
							r.id !== D && (D = r.id, C = !0);
							if (E || P !== t) {
								if (I.setValue(Lt, "projectionMatrix", t.projectionMatrix), ot.logarithmicDepthBuffer && I.setValue(Lt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), P !== t && (P = t, C = !0, L = !0), r.isShaderMaterial || r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshStandardMaterial || r.envMap) {
									const e = I.map.cameraPosition;
									void 0 !== e && e.setValue(Lt, nt.setFromMatrixPosition(t.matrixWorld))
								}(r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial) && I.setValue(Lt, "isOrthographic", !0 === t.isOrthographicCamera), (r.isMeshPhongMaterial || r.isMeshToonMaterial || r.isMeshLambertMaterial || r.isMeshBasicMaterial || r.isMeshStandardMaterial || r.isShaderMaterial || r.isShadowMaterial || object.isSkinnedMesh) && I.setValue(Lt, "viewMatrix", t.matrixWorldInverse)
							}
							if (object.isSkinnedMesh) {
								I.setOptional(Lt, object, "bindMatrix"), I.setOptional(Lt, object, "bindMatrixInverse");
								const t = object.skeleton;
								t && (ot.floatVertexTextures ? (null === t.boneTexture && t.computeBoneTexture(), I.setValue(Lt, "boneTexture", t.boneTexture, ut), I.setValue(Lt, "boneTextureSize", t.boneTextureSize)) : I.setOptional(Lt, t, "boneMatrices"))
							}!n || void 0 === n.morphAttributes.position && void 0 === n.morphAttributes.normal || Tt.update(object, n, r, T);
							(C || _.receiveShadow !== object.receiveShadow) && (_.receiveShadow = object.receiveShadow, I.setValue(Lt, "receiveShadow", object.receiveShadow));
							C && (I.setValue(Lt, "toneMappingExposure", S.toneMappingExposure), _.needsLights && (F = L, (O = B).ambientLightColor.needsUpdate = F, O.lightProbe.needsUpdate = F, O.directionalLights.needsUpdate = F, O.directionalLightShadows.needsUpdate = F, O.pointLights.needsUpdate = F, O.pointLightShadows.needsUpdate = F, O.spotLights.needsUpdate = F, O.spotLightShadows.needsUpdate = F, O.rectAreaLights.needsUpdate = F, O.hemisphereLights.needsUpdate = F), o && r.fog && _t.refreshFogUniforms(B, o), _t.refreshMaterialUniforms(B, r, k, U, tt), ys.upload(Lt, _.uniformsList, B, ut));
							var O, F;
							r.isShaderMaterial && !0 === r.uniformsNeedUpdate && (ys.upload(Lt, _.uniformsList, B, ut), r.uniformsNeedUpdate = !1);
							r.isSpriteMaterial && I.setValue(Lt, "center", object.center);
							return I.setValue(Lt, "modelViewMatrix", object.modelViewMatrix), I.setValue(Lt, "normalMatrix", object.normalMatrix), I.setValue(Lt, "modelMatrix", object.matrixWorld), T
						}(t, e, n, r, object);
					lt.setMaterial(r, l);
					let h = n.index;
					const d = n.attributes.position;
					if (null === h) {
						if (void 0 === d || 0 === d.count) return
					} else if (0 === h.count) return;
					let f, m = 1;
					!0 === r.wireframe && (h = vt.getWireframeAttribute(n), m = 2), Dt.setup(object, r, c, n, h);
					let v = Et;
					null !== h && (f = gt.get(h), v = Ct, v.setIndex(f));
					const y = null !== h ? h.count : d.count,
						x = n.drawRange.start * m,
						_ = n.drawRange.count * m,
						A = null !== o ? o.start * m : 0,
						M = null !== o ? o.count * m : 1 / 0,
						T = Math.max(x, A),
						E = Math.min(y, x + _, A + M) - 1,
						C = Math.max(0, E - T + 1);
					if (0 !== C) {
						if (object.isMesh) !0 === r.wireframe ? (lt.setLineWidth(r.wireframeLinewidth * st()), v.setMode(1)) : v.setMode(4);
						else if (object.isLine) {
							let t = r.linewidth;
							void 0 === t && (t = 1), lt.setLineWidth(t * st()), object.isLineSegments ? v.setMode(1) : object.isLineLoop ? v.setMode(2) : v.setMode(3)
						} else object.isPoints ? v.setMode(0) : object.isSprite && v.setMode(4);
						if (object.isInstancedMesh) v.renderInstances(T, C, object.count);
						else if (n.isInstancedBufferGeometry) {
							const t = Math.min(n.instanceCount, n._maxInstanceCount);
							v.renderInstances(T, C, t)
						} else v.render(T, C)
					}
				}, this.compile = function(t, e) {
					w = At.get(t), w.init(), M.push(w), t.traverseVisible((function(object) {
						object.isLight && object.layers.test(e.layers) && (w.pushLight(object), object.castShadow && w.pushShadow(object))
					})), w.setupLights(S.physicallyCorrectLights), t.traverse((function(object) {
						const e = object.material;
						if (e)
							if (Array.isArray(e))
								for (let i = 0; i < e.length; i++) {
									Yt(e[i], t, object)
								} else Yt(e, t, object)
					})), M.pop(), w = null
				};
				let Nt = null;

				function Ut() {
					Gt.stop()
				}

				function zt() {
					Gt.start()
				}
				const Gt = new _i;

				function Vt(object, t, e, n) {
					if (!1 === object.visible) return;
					if (object.layers.test(t.layers))
						if (object.isGroup) e = object.renderOrder;
						else if (object.isLOD) !0 === object.autoUpdate && object.update(t);
					else if (object.isLight) w.pushLight(object), object.castShadow && w.pushShadow(object);
					else if (object.isSprite) {
						if (!object.frustumCulled || K.intersectsSprite(object)) {
							n && nt.setFromMatrixPosition(object.matrixWorld).applyMatrix4(et);
							const t = yt.update(object),
								r = object.material;
							r.visible && _.push(object, t, r, e, nt.z, null)
						}
					} else if ((object.isMesh || object.isLine || object.isPoints) && (object.isSkinnedMesh && object.skeleton.frame !== ct.render.frame && (object.skeleton.update(), object.skeleton.frame = ct.render.frame), !object.frustumCulled || K.intersectsObject(object))) {
						n && nt.setFromMatrixPosition(object.matrixWorld).applyMatrix4(et);
						const t = yt.update(object),
							r = object.material;
						if (Array.isArray(r)) {
							const n = t.groups;
							for (let i = 0, o = n.length; i < o; i++) {
								const o = n[i],
									l = r[o.materialIndex];
								l && l.visible && _.push(object, t, l, e, nt.z, o)
							}
						} else r.visible && _.push(object, t, r, e, nt.z, null)
					}
					const r = object.children;
					for (let i = 0, o = r.length; i < o; i++) Vt(r[i], t, e, n)
				}

				function Wt(t, e, n, r) {
					const o = t.opaque,
						l = t.transmissive,
						c = t.transparent;
					w.setupLightsView(n), l.length > 0 && function(t, e, n) {
						if (null === tt) {
							const t = !0 === f && !0 === ot.isWebGL2;
							tt = new(t ? ne : ee)(1024, 1024, {
								generateMipmaps: !0,
								type: null !== Rt.convert(W) ? W : z,
								minFilter: N,
								magFilter: I,
								wrapS: L,
								wrapT: L,
								useRenderToTexture: at.has("WEBGL_multisampled_render_to_texture")
							})
						}
						const r = S.getRenderTarget();
						S.setRenderTarget(tt), S.clear();
						const o = S.toneMapping;
						S.toneMapping = 0, jt(t, e, n), S.toneMapping = o, ut.updateMultisampleRenderTarget(tt), ut.updateRenderTargetMipmap(tt), S.setRenderTarget(r)
					}(o, e, n), r && lt.viewport(B.copy(r)), o.length > 0 && jt(o, e, n), l.length > 0 && jt(l, e, n), c.length > 0 && jt(c, e, n)
				}

				function jt(t, e, n) {
					const r = !0 === e.isScene ? e.overrideMaterial : null;
					for (let i = 0, o = t.length; i < o; i++) {
						const o = t[i],
							object = o.object,
							l = o.geometry,
							c = null === r ? o.material : r,
							h = o.group;
						object.layers.test(n.layers) && Xt(object, e, n, l, c, h)
					}
				}

				function Xt(object, t, e, n, r, h) {
					object.onBeforeRender(S, t, e, n, r, h), object.modelViewMatrix.multiplyMatrices(e.matrixWorldInverse, object.matrixWorld), object.normalMatrix.getNormalMatrix(object.modelViewMatrix), r.onBeforeRender(S, t, e, n, object, h), !0 === r.transparent && r.side === c ? (r.side = l, r.needsUpdate = !0, S.renderBufferDirect(e, t, n, r, object, h), r.side = o, r.needsUpdate = !0, S.renderBufferDirect(e, t, n, r, object, h), r.side = c) : S.renderBufferDirect(e, t, n, r, object, h), object.onAfterRender(S, t, e, n, r, h)
				}

				function Yt(t, e, object) {
					!0 !== e.isScene && (e = it);
					const n = ht.get(t),
						r = w.state.lights,
						o = w.state.shadowsArray,
						l = r.state.version,
						c = xt.getParameters(t, r.state, o, e, object),
						h = xt.getProgramCacheKey(c);
					let d = n.programs;
					n.environment = t.isMeshStandardMaterial ? e.environment : null, n.fog = e.fog, n.envMap = (t.isMeshStandardMaterial ? ft : pt).get(t.envMap || n.environment), void 0 === d && (t.addEventListener("dispose", Ht), d = new Map, n.programs = d);
					let f = d.get(h);
					if (void 0 !== f) {
						if (n.currentProgram === f && n.lightsStateVersion === l) return Qt(t, c), f
					} else c.uniforms = xt.getUniforms(t), t.onBuild(object, c, S), t.onBeforeCompile(c, S), f = xt.acquireProgram(c, h), d.set(h, f), n.uniforms = c.uniforms;
					const m = n.uniforms;
					(t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (m.clippingPlanes = bt.uniform), Qt(t, c), n.needsLights = function(t) {
						return t.isMeshLambertMaterial || t.isMeshToonMaterial || t.isMeshPhongMaterial || t.isMeshStandardMaterial || t.isShadowMaterial || t.isShaderMaterial && !0 === t.lights
					}(t), n.lightsStateVersion = l, n.needsLights && (m.ambientLightColor.value = r.state.ambient, m.lightProbe.value = r.state.probe, m.directionalLights.value = r.state.directional, m.directionalLightShadows.value = r.state.directionalShadow, m.spotLights.value = r.state.spot, m.spotLightShadows.value = r.state.spotShadow, m.rectAreaLights.value = r.state.rectArea, m.ltc_1.value = r.state.rectAreaLTC1, m.ltc_2.value = r.state.rectAreaLTC2, m.pointLights.value = r.state.point, m.pointLightShadows.value = r.state.pointShadow, m.hemisphereLights.value = r.state.hemi, m.directionalShadowMap.value = r.state.directionalShadowMap, m.directionalShadowMatrix.value = r.state.directionalShadowMatrix, m.spotShadowMap.value = r.state.spotShadowMap, m.spotShadowMatrix.value = r.state.spotShadowMatrix, m.pointShadowMap.value = r.state.pointShadowMap, m.pointShadowMatrix.value = r.state.pointShadowMatrix);
					const v = f.getUniforms(),
						y = ys.seqWithValue(v.seq, m);
					return n.currentProgram = f, n.uniformsList = y, f
				}

				function Qt(t, e) {
					const n = ht.get(t);
					n.outputEncoding = e.outputEncoding, n.instancing = e.instancing, n.skinning = e.skinning, n.morphTargets = e.morphTargets, n.morphNormals = e.morphNormals, n.morphTargetsCount = e.morphTargetsCount, n.numClippingPlanes = e.numClippingPlanes, n.numIntersection = e.numClipIntersection, n.vertexAlphas = e.vertexAlphas, n.vertexTangents = e.vertexTangents, n.toneMapping = e.toneMapping
				}
				Gt.setAnimationLoop((function(time) {
					Nt && Nt(time)
				})), "undefined" != typeof window && Gt.setContext(window), this.setAnimationLoop = function(t) {
					Nt = t, Bt.setAnimationLoop(t), null === t ? Gt.stop() : Gt.start()
				}, Bt.addEventListener("sessionstart", Ut), Bt.addEventListener("sessionend", zt), this.render = function(t, e) {
					if (void 0 !== e && !0 !== e.isCamera) return void console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
					if (!0 === T) return;
					!0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), !0 === Bt.enabled && !0 === Bt.isPresenting && (!0 === Bt.cameraAutoUpdate && Bt.updateCamera(e), e = Bt.getCamera()), !0 === t.isScene && t.onBeforeRender(S, t, e, R), w = At.get(t, M.length), w.init(), M.push(w), et.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), K.setFromProjectionMatrix(et), $ = this.localClippingEnabled, Z = bt.init(this.clippingPlanes, $, e), _ = wt.get(t, A.length), _.init(), A.push(_), Vt(t, e, 0, S.sortObjects), _.finish(), !0 === S.sortObjects && _.sort(G, j), !0 === Z && bt.beginShadows();
					const n = w.state.shadowsArray;
					if (Mt.render(n, t, e), !0 === Z && bt.endShadows(), !0 === this.info.autoReset && this.info.reset(), St.render(_, t), w.setupLights(S.physicallyCorrectLights), e.isArrayCamera) {
						const n = e.cameras;
						for (let i = 0, e = n.length; i < e; i++) {
							const e = n[i];
							Wt(_, t, e, e.viewport)
						}
					} else Wt(_, t, e);
					null !== R && (ut.updateMultisampleRenderTarget(R), ut.updateRenderTargetMipmap(R)), !0 === t.isScene && t.onAfterRender(S, t, e), lt.buffers.depth.setTest(!0), lt.buffers.depth.setMask(!0), lt.buffers.color.setMask(!0), lt.setPolygonOffset(!1), Dt.resetDefaultState(), D = -1, P = null, M.pop(), w = M.length > 0 ? M[M.length - 1] : null, A.pop(), _ = A.length > 0 ? A[A.length - 1] : null
				}, this.getActiveCubeFace = function() {
					return E
				}, this.getActiveMipmapLevel = function() {
					return C
				}, this.getRenderTarget = function() {
					return R
				}, this.setRenderTargetTextures = function(t, e, n) {
					ht.get(t.texture).__webglTexture = e, ht.get(t.depthTexture).__webglTexture = n;
					const r = ht.get(t);
					r.__hasExternalTextures = !0, r.__hasExternalTextures && (r.__autoAllocateDepthBuffer = void 0 === n, r.__autoAllocateDepthBuffer || t.useRenderToTexture && (console.warn("render-to-texture extension was disabled because an external texture was provided"), t.useRenderToTexture = !1, t.useRenderbuffer = !0))
				}, this.setRenderTargetFramebuffer = function(t, e) {
					const n = ht.get(t);
					n.__webglFramebuffer = e, n.__useDefaultFramebuffer = void 0 === e
				}, this.setRenderTarget = function(t, e = 0, n = 0) {
					R = t, E = e, C = n;
					let r = !0;
					if (t) {
						const e = ht.get(t);
						void 0 !== e.__useDefaultFramebuffer ? (lt.bindFramebuffer(36160, null), r = !1) : void 0 === e.__webglFramebuffer ? ut.setupRenderTarget(t) : e.__hasExternalTextures && ut.rebindTextures(t, ht.get(t.texture).__webglTexture, ht.get(t.depthTexture).__webglTexture)
					}
					let o = null,
						l = !1,
						c = !1;
					if (t) {
						const n = t.texture;
						(n.isDataTexture3D || n.isDataTexture2DArray) && (c = !0);
						const r = ht.get(t).__webglFramebuffer;
						t.isWebGLCubeRenderTarget ? (o = r[e], l = !0) : o = t.useRenderbuffer ? ht.get(t).__webglMultisampledFramebuffer : r, B.copy(t.viewport), O.copy(t.scissor), F = t.scissorTest
					} else B.copy(X).multiplyScalar(k).floor(), O.copy(Q).multiplyScalar(k).floor(), F = J;
					if (lt.bindFramebuffer(36160, o) && ot.drawBuffers && r && lt.drawBuffers(t, o), lt.viewport(B), lt.scissor(O), lt.setScissorTest(F), l) {
						const r = ht.get(t.texture);
						Lt.framebufferTexture2D(36160, 36064, 34069 + e, r.__webglTexture, n)
					} else if (c) {
						const r = ht.get(t.texture),
							o = e || 0;
						Lt.framebufferTextureLayer(36160, 36064, r.__webglTexture, n || 0, o)
					}
					D = -1
				}, this.readRenderTargetPixels = function(t, e, n, r, o, l, c) {
					if (!t || !t.isWebGLRenderTarget) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
					let h = ht.get(t).__webglFramebuffer;
					if (t.isWebGLCubeRenderTarget && void 0 !== c && (h = h[c]), h) {
						lt.bindFramebuffer(36160, h);
						try {
							const c = t.texture,
								h = c.format,
								d = c.type;
							if (h !== Y && Rt.convert(h) !== Lt.getParameter(35739)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
							const f = d === W && (at.has("EXT_color_buffer_half_float") || ot.isWebGL2 && at.has("EXT_color_buffer_float"));
							if (!(d === z || Rt.convert(d) === Lt.getParameter(35738) || d === V && (ot.isWebGL2 || at.has("OES_texture_float") || at.has("WEBGL_color_buffer_float")) || f)) return void console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
							36053 === Lt.checkFramebufferStatus(36160) ? e >= 0 && e <= t.width - r && n >= 0 && n <= t.height - o && Lt.readPixels(e, n, r, o, Rt.convert(h), Rt.convert(d), l) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")
						} finally {
							const t = null !== R ? ht.get(R).__webglFramebuffer : null;
							lt.bindFramebuffer(36160, t)
						}
					}
				}, this.copyFramebufferToTexture = function(t, e, n = 0) {
					if (!0 !== e.isFramebufferTexture) return void console.error("THREE.WebGLRenderer: copyFramebufferToTexture() can only be used with FramebufferTexture.");
					const r = Math.pow(2, -n),
						o = Math.floor(e.image.width * r),
						l = Math.floor(e.image.height * r);
					ut.setTexture2D(e, 0), Lt.copyTexSubImage2D(3553, n, 0, 0, t.x, t.y, o, l), lt.unbindTexture()
				}, this.copyTextureToTexture = function(t, e, n, r = 0) {
					const o = e.image.width,
						l = e.image.height,
						c = Rt.convert(n.format),
						h = Rt.convert(n.type);
					ut.setTexture2D(n, 0), Lt.pixelStorei(37440, n.flipY), Lt.pixelStorei(37441, n.premultiplyAlpha), Lt.pixelStorei(3317, n.unpackAlignment), e.isDataTexture ? Lt.texSubImage2D(3553, r, t.x, t.y, o, l, c, h, e.image.data) : e.isCompressedTexture ? Lt.compressedTexSubImage2D(3553, r, t.x, t.y, e.mipmaps[0].width, e.mipmaps[0].height, c, e.mipmaps[0].data) : Lt.texSubImage2D(3553, r, t.x, t.y, c, h, e.image), 0 === r && n.generateMipmaps && Lt.generateMipmap(3553), lt.unbindTexture()
				}, this.copyTextureToTexture3D = function(t, e, n, r, o = 0) {
					if (S.isWebGL1Renderer) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");
					const l = t.max.x - t.min.x + 1,
						c = t.max.y - t.min.y + 1,
						h = t.max.z - t.min.z + 1,
						d = Rt.convert(r.format),
						f = Rt.convert(r.type);
					let m;
					if (r.isDataTexture3D) ut.setTexture3D(r, 0), m = 32879;
					else {
						if (!r.isDataTexture2DArray) return void console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
						ut.setTexture2DArray(r, 0), m = 35866
					}
					Lt.pixelStorei(37440, r.flipY), Lt.pixelStorei(37441, r.premultiplyAlpha), Lt.pixelStorei(3317, r.unpackAlignment);
					const v = Lt.getParameter(3314),
						y = Lt.getParameter(32878),
						x = Lt.getParameter(3316),
						_ = Lt.getParameter(3315),
						w = Lt.getParameter(32877),
						image = n.isCompressedTexture ? n.mipmaps[0] : n.image;
					Lt.pixelStorei(3314, image.width), Lt.pixelStorei(32878, image.height), Lt.pixelStorei(3316, t.min.x), Lt.pixelStorei(3315, t.min.y), Lt.pixelStorei(32877, t.min.z), n.isDataTexture || n.isDataTexture3D ? Lt.texSubImage3D(m, o, e.x, e.y, e.z, l, c, h, d, f, image.data) : n.isCompressedTexture ? (console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."), Lt.compressedTexSubImage3D(m, o, e.x, e.y, e.z, l, c, h, d, image.data)) : Lt.texSubImage3D(m, o, e.x, e.y, e.z, l, c, h, d, f, image), Lt.pixelStorei(3314, v), Lt.pixelStorei(32878, y), Lt.pixelStorei(3316, x), Lt.pixelStorei(3315, _), Lt.pixelStorei(32877, w), 0 === o && r.generateMipmaps && Lt.generateMipmap(m), lt.unbindTexture()
				}, this.initTexture = function(t) {
					ut.setTexture2D(t, 0), lt.unbindTexture()
				}, this.resetState = function() {
					E = 0, C = 0, R = null, lt.reset(), Dt.reset()
				}, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
					detail: this
				}))
			}
			ua.prototype.isWebGLRenderer = !0;
			(class extends ua {}).prototype.isWebGL1Renderer = !0;
			class da {
				constructor(t, e = 25e-5) {
					this.name = "", this.color = new Qt(t), this.density = e
				}
				clone() {
					return new da(this.color, this.density)
				}
				toJSON() {
					return {
						type: "FogExp2",
						color: this.color.getHex(),
						density: this.density
					}
				}
			}
			da.prototype.isFogExp2 = !0;
			class pa {
				constructor(t, e = 1, n = 1e3) {
					this.name = "", this.color = new Qt(t), this.near = e, this.far = n
				}
				clone() {
					return new pa(this.color, this.near, this.far)
				}
				toJSON() {
					return {
						type: "Fog",
						color: this.color.getHex(),
						near: this.near,
						far: this.far
					}
				}
			}
			pa.prototype.isFog = !0;
			class fa extends on {
				constructor() {
					super(), this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.overrideMaterial = null, this.autoUpdate = !0, "undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
						detail: this
					}))
				}
				copy(source, t) {
					return super.copy(source, t), null !== source.background && (this.background = source.background.clone()), null !== source.environment && (this.environment = source.environment.clone()), null !== source.fog && (this.fog = source.fog.clone()), null !== source.overrideMaterial && (this.overrideMaterial = source.overrideMaterial.clone()), this.autoUpdate = source.autoUpdate, this.matrixAutoUpdate = source.matrixAutoUpdate, this
				}
				toJSON(meta) {
					const data = super.toJSON(meta);
					return null !== this.fog && (data.object.fog = this.fog.toJSON()), data
				}
			}
			fa.prototype.isScene = !0;
			class ma {
				constructor(t, e) {
					this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.usage = wt, this.updateRange = {
						offset: 0,
						count: -1
					}, this.version = 0, this.uuid = Dt()
				}
				onUploadCallback() {}
				set needsUpdate(t) {
					!0 === t && this.version++
				}
				setUsage(t) {
					return this.usage = t, this
				}
				copy(source) {
					return this.array = new source.array.constructor(source.array), this.count = source.count, this.stride = source.stride, this.usage = source.usage, this
				}
				copyAt(t, e, n) {
					t *= this.stride, n *= e.stride;
					for (let i = 0, r = this.stride; i < r; i++) this.array[t + i] = e.array[n + i];
					return this
				}
				set(t, e = 0) {
					return this.array.set(t, e), this
				}
				clone(data) {
					void 0 === data.arrayBuffers && (data.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Dt()), void 0 === data.arrayBuffers[this.array.buffer._uuid] && (data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
					const t = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]),
						e = new this.constructor(t, this.stride);
					return e.setUsage(this.usage), e
				}
				onUpload(t) {
					return this.onUploadCallback = t, this
				}
				toJSON(data) {
					return void 0 === data.arrayBuffers && (data.arrayBuffers = {}), void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Dt()), void 0 === data.arrayBuffers[this.array.buffer._uuid] && (data.arrayBuffers[this.array.buffer._uuid] = Array.prototype.slice.call(new Uint32Array(this.array.buffer))), {
						uuid: this.uuid,
						buffer: this.array.buffer._uuid,
						type: this.array.constructor.name,
						stride: this.stride
					}
				}
			}
			ma.prototype.isInterleavedBuffer = !0;
			const ga = new re;
			class va {
				constructor(t, e, n, r = !1) {
					this.name = "", this.data = t, this.itemSize = e, this.offset = n, this.normalized = !0 === r
				}
				get count() {
					return this.data.count
				}
				get array() {
					return this.data.array
				}
				set needsUpdate(t) {
					this.data.needsUpdate = t
				}
				applyMatrix4(t) {
					for (let i = 0, e = this.data.count; i < e; i++) ga.x = this.getX(i), ga.y = this.getY(i), ga.z = this.getZ(i), ga.applyMatrix4(t), this.setXYZ(i, ga.x, ga.y, ga.z);
					return this
				}
				applyNormalMatrix(t) {
					for (let i = 0, e = this.count; i < e; i++) ga.x = this.getX(i), ga.y = this.getY(i), ga.z = this.getZ(i), ga.applyNormalMatrix(t), this.setXYZ(i, ga.x, ga.y, ga.z);
					return this
				}
				transformDirection(t) {
					for (let i = 0, e = this.count; i < e; i++) ga.x = this.getX(i), ga.y = this.getY(i), ga.z = this.getZ(i), ga.transformDirection(t), this.setXYZ(i, ga.x, ga.y, ga.z);
					return this
				}
				setX(t, e) {
					return this.data.array[t * this.data.stride + this.offset] = e, this
				}
				setY(t, e) {
					return this.data.array[t * this.data.stride + this.offset + 1] = e, this
				}
				setZ(t, e) {
					return this.data.array[t * this.data.stride + this.offset + 2] = e, this
				}
				setW(t, e) {
					return this.data.array[t * this.data.stride + this.offset + 3] = e, this
				}
				getX(t) {
					return this.data.array[t * this.data.stride + this.offset]
				}
				getY(t) {
					return this.data.array[t * this.data.stride + this.offset + 1]
				}
				getZ(t) {
					return this.data.array[t * this.data.stride + this.offset + 2]
				}
				getW(t) {
					return this.data.array[t * this.data.stride + this.offset + 3]
				}
				setXY(t, e, n) {
					return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this
				}
				setXYZ(t, e, n, r) {
					return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this
				}
				setXYZW(t, e, n, r, o) {
					return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = n, this.data.array[t + 2] = r, this.data.array[t + 3] = o, this
				}
				clone(data) {
					if (void 0 === data) {
						console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");
						const t = [];
						for (let i = 0; i < this.count; i++) {
							const e = i * this.data.stride + this.offset;
							for (let n = 0; n < this.itemSize; n++) t.push(this.data.array[e + n])
						}
						return new Mn(new this.array.constructor(t), this.itemSize, this.normalized)
					}
					return void 0 === data.interleavedBuffers && (data.interleavedBuffers = {}), void 0 === data.interleavedBuffers[this.data.uuid] && (data.interleavedBuffers[this.data.uuid] = this.data.clone(data)), new va(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
				}
				toJSON(data) {
					if (void 0 === data) {
						console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");
						const t = [];
						for (let i = 0; i < this.count; i++) {
							const e = i * this.data.stride + this.offset;
							for (let n = 0; n < this.itemSize; n++) t.push(this.data.array[e + n])
						}
						return {
							itemSize: this.itemSize,
							type: this.array.constructor.name,
							array: t,
							normalized: this.normalized
						}
					}
					return void 0 === data.interleavedBuffers && (data.interleavedBuffers = {}), void 0 === data.interleavedBuffers[this.data.uuid] && (data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data)), {
						isInterleavedBufferAttribute: !0,
						itemSize: this.itemSize,
						data: this.data.uuid,
						offset: this.offset,
						normalized: this.normalized
					}
				}
			}
			va.prototype.isInterleavedBufferAttribute = !0;
			class ya extends _n {
				constructor(t) {
					super(), this.type = "SpriteMaterial", this.color = new Qt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.rotation = source.rotation, this.sizeAttenuation = source.sizeAttenuation, this
				}
			}
			let xa;
			ya.prototype.isSpriteMaterial = !0;
			const _a = new re,
				wa = new re,
				Aa = new re,
				ba = new Nt,
				Ma = new Nt,
				Sa = new Oe,
				Ta = new re,
				Ea = new re,
				Ca = new re,
				Ra = new Nt,
				Da = new Nt,
				La = new Nt;
			class Pa extends on {
				constructor(t) {
					if (super(), this.type = "Sprite", void 0 === xa) {
						xa = new On;
						const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
							e = new ma(t, 5);
						xa.setIndex([0, 1, 2, 0, 2, 3]), xa.setAttribute("position", new va(e, 3, 0, !1)), xa.setAttribute("uv", new va(e, 2, 3, !1))
					}
					this.geometry = xa, this.material = void 0 !== t ? t : new ya, this.center = new Nt(.5, .5)
				}
				raycast(t, e) {
					null === t.camera && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), wa.setFromMatrixScale(this.matrixWorld), Sa.copy(t.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(t.camera.matrixWorldInverse, this.matrixWorld), Aa.setFromMatrixPosition(this.modelViewMatrix), t.camera.isPerspectiveCamera && !1 === this.material.sizeAttenuation && wa.multiplyScalar(-Aa.z);
					const n = this.material.rotation;
					let r, o;
					0 !== n && (o = Math.cos(n), r = Math.sin(n));
					const l = this.center;
					Ia(Ta.set(-.5, -.5, 0), Aa, l, wa, r, o), Ia(Ea.set(.5, -.5, 0), Aa, l, wa, r, o), Ia(Ca.set(.5, .5, 0), Aa, l, wa, r, o), Ra.set(0, 0), Da.set(1, 0), La.set(1, 1);
					let c = t.ray.intersectTriangle(Ta, Ea, Ca, !1, _a);
					if (null === c && (Ia(Ea.set(-.5, .5, 0), Aa, l, wa, r, o), Da.set(0, 1), c = t.ray.intersectTriangle(Ta, Ca, Ea, !1, _a), null === c)) return;
					const h = t.ray.origin.distanceTo(_a);
					h < t.near || h > t.far || e.push({
						distance: h,
						point: _a.clone(),
						uv: yn.getUV(_a, Ta, Ea, Ca, Ra, Da, La, new Nt),
						face: null,
						object: this
					})
				}
				copy(source) {
					return super.copy(source), void 0 !== source.center && this.center.copy(source.center), this.material = source.material, this
				}
			}

			function Ia(t, e, n, r, o, l) {
				ba.subVectors(t, n).addScalar(.5).multiply(r), void 0 !== o ? (Ma.x = l * ba.x - o * ba.y, Ma.y = o * ba.x + l * ba.y) : Ma.copy(ba), t.copy(e), t.x += Ma.x, t.y += Ma.y, t.applyMatrix4(Sa)
			}
			Pa.prototype.isSprite = !0;
			const Ba = new re,
				Oa = new te,
				Fa = new te,
				Ha = new re,
				Na = new Oe;
			class Ua extends $n {
				constructor(t, e) {
					super(t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new Oe, this.bindMatrixInverse = new Oe
				}
				copy(source) {
					return super.copy(source), this.bindMode = source.bindMode, this.bindMatrix.copy(source.bindMatrix), this.bindMatrixInverse.copy(source.bindMatrixInverse), this.skeleton = source.skeleton, this
				}
				bind(t, e) {
					this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.copy(e).invert()
				}
				pose() {
					this.skeleton.pose()
				}
				normalizeSkinWeights() {
					const t = new te,
						e = this.geometry.attributes.skinWeight;
					for (let i = 0, n = e.count; i < n; i++) {
						t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
						const n = 1 / t.manhattanLength();
						n !== 1 / 0 ? t.multiplyScalar(n) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
					}
				}
				updateMatrixWorld(t) {
					super.updateMatrixWorld(t), "attached" === this.bindMode ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : "detached" === this.bindMode ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
				}
				boneTransform(t, e) {
					const n = this.skeleton,
						r = this.geometry;
					Oa.fromBufferAttribute(r.attributes.skinIndex, t), Fa.fromBufferAttribute(r.attributes.skinWeight, t), Ba.copy(e).applyMatrix4(this.bindMatrix), e.set(0, 0, 0);
					for (let i = 0; i < 4; i++) {
						const t = Fa.getComponent(i);
						if (0 !== t) {
							const r = Oa.getComponent(i);
							Na.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]), e.addScaledVector(Ha.copy(Ba).applyMatrix4(Na), t)
						}
					}
					return e.applyMatrix4(this.bindMatrixInverse)
				}
			}
			Ua.prototype.isSkinnedMesh = !0;
			class za extends on {
				constructor() {
					super(), this.type = "Bone"
				}
			}
			za.prototype.isBone = !0;
			class ka extends Zt {
				constructor(data = null, t = 1, e = 1, n, r, o, l, c, h = I, d = I, f, m) {
					super(null, o, l, c, h, d, n, r, f, m), this.image = {
						data: data,
						width: t,
						height: e
					}, this.magFilter = h, this.minFilter = d, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
				}
			}
			ka.prototype.isDataTexture = !0;
			const Ga = new Oe,
				Va = new Oe;
			class Wa {
				constructor(t = [], e = []) {
					this.uuid = Dt(), this.bones = t.slice(0), this.boneInverses = e, this.boneMatrices = null, this.boneTexture = null, this.boneTextureSize = 0, this.frame = -1, this.init()
				}
				init() {
					const t = this.bones,
						e = this.boneInverses;
					if (this.boneMatrices = new Float32Array(16 * t.length), 0 === e.length) this.calculateInverses();
					else if (t.length !== e.length) {
						console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
						for (let i = 0, t = this.bones.length; i < t; i++) this.boneInverses.push(new Oe)
					}
				}
				calculateInverses() {
					this.boneInverses.length = 0;
					for (let i = 0, t = this.bones.length; i < t; i++) {
						const t = new Oe;
						this.bones[i] && t.copy(this.bones[i].matrixWorld).invert(), this.boneInverses.push(t)
					}
				}
				pose() {
					for (let i = 0, t = this.bones.length; i < t; i++) {
						const t = this.bones[i];
						t && t.matrixWorld.copy(this.boneInverses[i]).invert()
					}
					for (let i = 0, t = this.bones.length; i < t; i++) {
						const t = this.bones[i];
						t && (t.parent && t.parent.isBone ? (t.matrix.copy(t.parent.matrixWorld).invert(), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
					}
				}
				update() {
					const t = this.bones,
						e = this.boneInverses,
						n = this.boneMatrices,
						r = this.boneTexture;
					for (let i = 0, r = t.length; i < r; i++) {
						const r = t[i] ? t[i].matrixWorld : Va;
						Ga.multiplyMatrices(r, e[i]), Ga.toArray(n, 16 * i)
					}
					null !== r && (r.needsUpdate = !0)
				}
				clone() {
					return new Wa(this.bones, this.boneInverses)
				}
				computeBoneTexture() {
					let t = Math.sqrt(4 * this.bones.length);
					t = Ot(t), t = Math.max(t, 4);
					const e = new Float32Array(t * t * 4);
					e.set(this.boneMatrices);
					const n = new ka(e, t, t, Y, V);
					return n.needsUpdate = !0, this.boneMatrices = e, this.boneTexture = n, this.boneTextureSize = t, this
				}
				getBoneByName(t) {
					for (let i = 0, e = this.bones.length; i < e; i++) {
						const e = this.bones[i];
						if (e.name === t) return e
					}
				}
				dispose() {
					null !== this.boneTexture && (this.boneTexture.dispose(), this.boneTexture = null)
				}
				fromJSON(t, e) {
					this.uuid = t.uuid;
					for (let i = 0, n = t.bones.length; i < n; i++) {
						const n = t.bones[i];
						let r = e[n];
						void 0 === r && (console.warn("THREE.Skeleton: No bone found with UUID:", n), r = new za), this.bones.push(r), this.boneInverses.push((new Oe).fromArray(t.boneInverses[i]))
					}
					return this.init(), this
				}
				toJSON() {
					const data = {
						metadata: {
							version: 4.5,
							type: "Skeleton",
							generator: "Skeleton.toJSON"
						},
						bones: [],
						boneInverses: []
					};
					data.uuid = this.uuid;
					const t = this.bones,
						e = this.boneInverses;
					for (let i = 0, n = t.length; i < n; i++) {
						const n = t[i];
						data.bones.push(n.uuid);
						const r = e[i];
						data.boneInverses.push(r.toArray())
					}
					return data
				}
			}
			class ja extends Mn {
				constructor(t, e, n, r = 1) {
					"number" == typeof n && (r = n, n = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), super(t, e, n), this.meshPerAttribute = r
				}
				copy(source) {
					return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this
				}
				toJSON() {
					const data = super.toJSON();
					return data.meshPerAttribute = this.meshPerAttribute, data.isInstancedBufferAttribute = !0, data
				}
			}
			ja.prototype.isInstancedBufferAttribute = !0;
			const Xa = new Oe,
				Ya = new Oe,
				Qa = [],
				qa = new $n;
			class Ja extends $n {
				constructor(t, e, n) {
					super(t, e), this.instanceMatrix = new ja(new Float32Array(16 * n), 16), this.instanceColor = null, this.count = n, this.frustumCulled = !1
				}
				copy(source) {
					return super.copy(source), this.instanceMatrix.copy(source.instanceMatrix), null !== source.instanceColor && (this.instanceColor = source.instanceColor.clone()), this.count = source.count, this
				}
				getColorAt(t, e) {
					e.fromArray(this.instanceColor.array, 3 * t)
				}
				getMatrixAt(t, e) {
					e.fromArray(this.instanceMatrix.array, 16 * t)
				}
				raycast(t, e) {
					const n = this.matrixWorld,
						r = this.count;
					if (qa.geometry = this.geometry, qa.material = this.material, void 0 !== qa.material)
						for (let o = 0; o < r; o++) {
							this.getMatrixAt(o, Xa), Ya.multiplyMatrices(n, Xa), qa.matrixWorld = Ya, qa.raycast(t, Qa);
							for (let i = 0, t = Qa.length; i < t; i++) {
								const t = Qa[i];
								t.instanceId = o, t.object = this, e.push(t)
							}
							Qa.length = 0
						}
				}
				setColorAt(t, e) {
					null === this.instanceColor && (this.instanceColor = new ja(new Float32Array(3 * this.instanceMatrix.count), 3)), e.toArray(this.instanceColor.array, 3 * t)
				}
				setMatrixAt(t, e) {
					e.toArray(this.instanceMatrix.array, 16 * t)
				}
				updateMorphTargets() {}
				dispose() {
					this.dispatchEvent({
						type: "dispose"
					})
				}
			}
			Ja.prototype.isInstancedMesh = !0;
			class Ka extends _n {
				constructor(t) {
					super(), this.type = "LineBasicMaterial", this.color = new Qt(16777215), this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this.linewidth = source.linewidth, this.linecap = source.linecap, this.linejoin = source.linejoin, this
				}
			}
			Ka.prototype.isLineBasicMaterial = !0;
			const Za = new re,
				$a = new re,
				to = new Oe,
				eo = new Be,
				no = new Te;
			class io extends on {
				constructor(t = new On, e = new Ka) {
					super(), this.type = "Line", this.geometry = t, this.material = e, this.updateMorphTargets()
				}
				copy(source) {
					return super.copy(source), this.material = source.material, this.geometry = source.geometry, this
				}
				computeLineDistances() {
					const t = this.geometry;
					if (t.isBufferGeometry)
						if (null === t.index) {
							const e = t.attributes.position,
								n = [0];
							for (let i = 1, t = e.count; i < t; i++) Za.fromBufferAttribute(e, i - 1), $a.fromBufferAttribute(e, i), n[i] = n[i - 1], n[i] += Za.distanceTo($a);
							t.setAttribute("lineDistance", new En(n, 1))
						} else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
					else t.isGeometry && console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
					return this
				}
				raycast(t, e) {
					const n = this.geometry,
						r = this.matrixWorld,
						o = t.params.Line.threshold,
						l = n.drawRange;
					if (null === n.boundingSphere && n.computeBoundingSphere(), no.copy(n.boundingSphere), no.applyMatrix4(r), no.radius += o, !1 === t.ray.intersectsSphere(no)) return;
					to.copy(r).invert(), eo.copy(t.ray).applyMatrix4(to);
					const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
						h = c * c,
						d = new re,
						f = new re,
						m = new re,
						v = new re,
						y = this.isLineSegments ? 2 : 1;
					if (n.isBufferGeometry) {
						const r = n.index,
							o = n.attributes.position;
						if (null !== r) {
							for (let i = Math.max(0, l.start), n = Math.min(r.count, l.start + l.count) - 1; i < n; i += y) {
								const a = r.getX(i),
									b = r.getX(i + 1);
								d.fromBufferAttribute(o, a), f.fromBufferAttribute(o, b);
								if (eo.distanceSqToSegment(d, f, v, m) > h) continue;
								v.applyMatrix4(this.matrixWorld);
								const n = t.ray.origin.distanceTo(v);
								n < t.near || n > t.far || e.push({
									distance: n,
									point: m.clone().applyMatrix4(this.matrixWorld),
									index: i,
									face: null,
									faceIndex: null,
									object: this
								})
							}
						} else {
							for (let i = Math.max(0, l.start), n = Math.min(o.count, l.start + l.count) - 1; i < n; i += y) {
								d.fromBufferAttribute(o, i), f.fromBufferAttribute(o, i + 1);
								if (eo.distanceSqToSegment(d, f, v, m) > h) continue;
								v.applyMatrix4(this.matrixWorld);
								const n = t.ray.origin.distanceTo(v);
								n < t.near || n > t.far || e.push({
									distance: n,
									point: m.clone().applyMatrix4(this.matrixWorld),
									index: i,
									face: null,
									faceIndex: null,
									object: this
								})
							}
						}
					} else n.isGeometry && console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				}
				updateMorphTargets() {
					const t = this.geometry;
					if (t.isBufferGeometry) {
						const e = t.morphAttributes,
							n = Object.keys(e);
						if (n.length > 0) {
							const t = e[n[0]];
							if (void 0 !== t) {
								this.morphTargetInfluences = [], this.morphTargetDictionary = {};
								for (let e = 0, n = t.length; e < n; e++) {
									const n = t[e].name || String(e);
									this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
								}
							}
						}
					} else {
						const e = t.morphTargets;
						void 0 !== e && e.length > 0 && console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
					}
				}
			}
			io.prototype.isLine = !0;
			const ro = new re,
				so = new re;
			class ao extends io {
				constructor(t, e) {
					super(t, e), this.type = "LineSegments"
				}
				computeLineDistances() {
					const t = this.geometry;
					if (t.isBufferGeometry)
						if (null === t.index) {
							const e = t.attributes.position,
								n = [];
							for (let i = 0, t = e.count; i < t; i += 2) ro.fromBufferAttribute(e, i), so.fromBufferAttribute(e, i + 1), n[i] = 0 === i ? 0 : n[i - 1], n[i + 1] = n[i] + ro.distanceTo(so);
							t.setAttribute("lineDistance", new En(n, 1))
						} else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
					else t.isGeometry && console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");
					return this
				}
			}
			ao.prototype.isLineSegments = !0;
			class oo extends io {
				constructor(t, e) {
					super(t, e), this.type = "LineLoop"
				}
			}
			oo.prototype.isLineLoop = !0;
			class lo extends _n {
				constructor(t) {
					super(), this.type = "PointsMaterial", this.color = new Qt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this.map = source.map, this.alphaMap = source.alphaMap, this.size = source.size, this.sizeAttenuation = source.sizeAttenuation, this
				}
			}
			lo.prototype.isPointsMaterial = !0;
			const co = new Oe,
				ho = new Be,
				uo = new Te,
				po = new re;
			class fo extends on {
				constructor(t = new On, e = new lo) {
					super(), this.type = "Points", this.geometry = t, this.material = e, this.updateMorphTargets()
				}
				copy(source) {
					return super.copy(source), this.material = source.material, this.geometry = source.geometry, this
				}
				raycast(t, e) {
					const n = this.geometry,
						r = this.matrixWorld,
						o = t.params.Points.threshold,
						l = n.drawRange;
					if (null === n.boundingSphere && n.computeBoundingSphere(), uo.copy(n.boundingSphere), uo.applyMatrix4(r), uo.radius += o, !1 === t.ray.intersectsSphere(uo)) return;
					co.copy(r).invert(), ho.copy(t.ray).applyMatrix4(co);
					const c = o / ((this.scale.x + this.scale.y + this.scale.z) / 3),
						h = c * c;
					if (n.isBufferGeometry) {
						const o = n.index,
							c = n.attributes.position;
						if (null !== o) {
							for (let i = Math.max(0, l.start), n = Math.min(o.count, l.start + l.count); i < n; i++) {
								const a = o.getX(i);
								po.fromBufferAttribute(c, a), mo(po, a, h, r, t, e, this)
							}
						} else {
							for (let i = Math.max(0, l.start), n = Math.min(c.count, l.start + l.count); i < n; i++) po.fromBufferAttribute(c, i), mo(po, i, h, r, t, e, this)
						}
					} else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
				}
				updateMorphTargets() {
					const t = this.geometry;
					if (t.isBufferGeometry) {
						const e = t.morphAttributes,
							n = Object.keys(e);
						if (n.length > 0) {
							const t = e[n[0]];
							if (void 0 !== t) {
								this.morphTargetInfluences = [], this.morphTargetDictionary = {};
								for (let e = 0, n = t.length; e < n; e++) {
									const n = t[e].name || String(e);
									this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = e
								}
							}
						}
					} else {
						const e = t.morphTargets;
						void 0 !== e && e.length > 0 && console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")
					}
				}
			}

			function mo(t, e, n, r, o, l, object) {
				const c = ho.distanceSqToPoint(t);
				if (c < n) {
					const n = new re;
					ho.closestPointToPoint(t, n), n.applyMatrix4(r);
					const h = o.ray.origin.distanceTo(n);
					if (h < o.near || h > o.far) return;
					l.push({
						distance: h,
						distanceToRay: Math.sqrt(c),
						point: n,
						index: e,
						face: null,
						object: object
					})
				}
			}
			fo.prototype.isPoints = !0;
			(class extends Zt {
				constructor(video, t, e, n, r, o, l, c, h) {
					super(video, t, e, n, r, o, l, c, h), this.minFilter = void 0 !== o ? o : F, this.magFilter = void 0 !== r ? r : F, this.generateMipmaps = !1;
					const d = this;
					"requestVideoFrameCallback" in video && video.requestVideoFrameCallback((function t() {
						d.needsUpdate = !0, video.requestVideoFrameCallback(t)
					}))
				}
				clone() {
					return new this.constructor(this.image).copy(this)
				}
				update() {
					const video = this.image;
					!1 === "requestVideoFrameCallback" in video && video.readyState >= video.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
				}
			}).prototype.isVideoTexture = !0;
			(class extends Zt {
				constructor(t, e, n) {
					super({
						width: t,
						height: e
					}), this.format = n, this.magFilter = I, this.minFilter = I, this.generateMipmaps = !1, this.needsUpdate = !0
				}
			}).prototype.isFramebufferTexture = !0;
			class go extends Zt {
				constructor(t, e, n, r, o, l, c, h, d, f, m, v) {
					super(null, l, c, h, d, f, r, o, m, v), this.image = {
						width: e,
						height: n
					}, this.mipmaps = t, this.flipY = !1, this.generateMipmaps = !1
				}
			}
			go.prototype.isCompressedTexture = !0;
			(class extends Zt {
				constructor(canvas, t, e, n, r, o, l, c, h) {
					super(canvas, t, e, n, r, o, l, c, h), this.needsUpdate = !0
				}
			}).prototype.isCanvasTexture = !0;
			class vo extends On {
				constructor(t = 1, e = 1, n = 1, r = 8, o = 1, l = !1, c = 0, h = 2 * Math.PI) {
					super(), this.type = "CylinderGeometry", this.parameters = {
						radiusTop: t,
						radiusBottom: e,
						height: n,
						radialSegments: r,
						heightSegments: o,
						openEnded: l,
						thetaStart: c,
						thetaLength: h
					};
					const d = this;
					r = Math.floor(r), o = Math.floor(o);
					const f = [],
						m = [],
						v = [],
						y = [];
					let x = 0;
					const _ = [],
						w = n / 2;
					let A = 0;

					function M(n) {
						const o = x,
							l = new Nt,
							_ = new re;
						let M = 0;
						const S = !0 === n ? t : e,
							T = !0 === n ? 1 : -1;
						for (let t = 1; t <= r; t++) m.push(0, w * T, 0), v.push(0, T, 0), y.push(.5, .5), x++;
						const E = x;
						for (let t = 0; t <= r; t++) {
							const e = t / r * h + c,
								n = Math.cos(e),
								o = Math.sin(e);
							_.x = S * o, _.y = w * T, _.z = S * n, m.push(_.x, _.y, _.z), v.push(0, T, 0), l.x = .5 * n + .5, l.y = .5 * o * T + .5, y.push(l.x, l.y), x++
						}
						for (let t = 0; t < r; t++) {
							const e = o + t,
								i = E + t;
							!0 === n ? f.push(i, i + 1, e) : f.push(i + 1, i, e), M += 3
						}
						d.addGroup(A, M, !0 === n ? 1 : 2), A += M
					}! function() {
						const l = new re,
							M = new re;
						let S = 0;
						const T = (e - t) / n;
						for (let d = 0; d <= o; d++) {
							const f = [],
								A = d / o,
								S = A * (e - t) + t;
							for (let t = 0; t <= r; t++) {
								const u = t / r,
									e = u * h + c,
									o = Math.sin(e),
									d = Math.cos(e);
								M.x = S * o, M.y = -A * n + w, M.z = S * d, m.push(M.x, M.y, M.z), l.set(o, T, d).normalize(), v.push(l.x, l.y, l.z), y.push(u, 1 - A), f.push(x++)
							}
							_.push(f)
						}
						for (let t = 0; t < r; t++)
							for (let e = 0; e < o; e++) {
								const a = _[e][t],
									b = _[e + 1][t],
									n = _[e + 1][t + 1],
									r = _[e][t + 1];
								f.push(a, b, r), f.push(b, n, r), S += 6
							}
						d.addGroup(A, S, 0), A += S
					}(), !1 === l && (t > 0 && M(!0), e > 0 && M(!1)), this.setIndex(f), this.setAttribute("position", new En(m, 3)), this.setAttribute("normal", new En(v, 3)), this.setAttribute("uv", new En(y, 2))
				}
				static fromJSON(data) {
					return new vo(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength)
				}
			}
			new re, new re, new re, new yn;
			class yo {
				constructor() {
					this.type = "Curve", this.arcLengthDivisions = 200
				}
				getPoint() {
					return console.warn("THREE.Curve: .getPoint() not implemented."), null
				}
				getPointAt(u, t) {
					const e = this.getUtoTmapping(u);
					return this.getPoint(e, t)
				}
				getPoints(t = 5) {
					const e = [];
					for (let n = 0; n <= t; n++) e.push(this.getPoint(n / t));
					return e
				}
				getSpacedPoints(t = 5) {
					const e = [];
					for (let n = 0; n <= t; n++) e.push(this.getPointAt(n / t));
					return e
				}
				getLength() {
					const t = this.getLengths();
					return t[t.length - 1]
				}
				getLengths(t = this.arcLengthDivisions) {
					if (this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
					this.needsUpdate = !1;
					const e = [];
					let n, r = this.getPoint(0),
						o = 0;
					e.push(0);
					for (let p = 1; p <= t; p++) n = this.getPoint(p / t), o += n.distanceTo(r), e.push(o), r = n;
					return this.cacheArcLengths = e, e
				}
				updateArcLengths() {
					this.needsUpdate = !0, this.getLengths()
				}
				getUtoTmapping(u, t) {
					const e = this.getLengths();
					let i = 0;
					const n = e.length;
					let r;
					r = t || u * e[n - 1];
					let o, l = 0,
						c = n - 1;
					for (; l <= c;)
						if (i = Math.floor(l + (c - l) / 2), o = e[i] - r, o < 0) l = i + 1;
						else {
							if (!(o > 0)) {
								c = i;
								break
							}
							c = i - 1
						} if (i = c, e[i] === r) return i / (n - 1);
					const h = e[i];
					return (i + (r - h) / (e[i + 1] - h)) / (n - 1)
				}
				getTangent(t, e) {
					const n = 1e-4;
					let r = t - n,
						o = t + n;
					r < 0 && (r = 0), o > 1 && (o = 1);
					const l = this.getPoint(r),
						c = this.getPoint(o),
						h = e || (l.isVector2 ? new Nt : new re);
					return h.copy(c).sub(l).normalize(), h
				}
				getTangentAt(u, t) {
					const e = this.getUtoTmapping(u);
					return this.getTangent(e, t)
				}
				computeFrenetFrames(t, e) {
					const n = new re,
						r = [],
						o = [],
						l = [],
						c = new re,
						h = new Oe;
					for (let i = 0; i <= t; i++) {
						const u = i / t;
						r[i] = this.getTangentAt(u, new re)
					}
					o[0] = new re, l[0] = new re;
					let d = Number.MAX_VALUE;
					const f = Math.abs(r[0].x),
						m = Math.abs(r[0].y),
						v = Math.abs(r[0].z);
					f <= d && (d = f, n.set(1, 0, 0)), m <= d && (d = m, n.set(0, 1, 0)), v <= d && n.set(0, 0, 1), c.crossVectors(r[0], n).normalize(), o[0].crossVectors(r[0], c), l[0].crossVectors(r[0], o[0]);
					for (let i = 1; i <= t; i++) {
						if (o[i] = o[i - 1].clone(), l[i] = l[i - 1].clone(), c.crossVectors(r[i - 1], r[i]), c.length() > Number.EPSILON) {
							c.normalize();
							const t = Math.acos(Lt(r[i - 1].dot(r[i]), -1, 1));
							o[i].applyMatrix4(h.makeRotationAxis(c, t))
						}
						l[i].crossVectors(r[i], o[i])
					}
					if (!0 === e) {
						let e = Math.acos(Lt(o[0].dot(o[t]), -1, 1));
						e /= t, r[0].dot(c.crossVectors(o[0], o[t])) > 0 && (e = -e);
						for (let i = 1; i <= t; i++) o[i].applyMatrix4(h.makeRotationAxis(r[i], e * i)), l[i].crossVectors(r[i], o[i])
					}
					return {
						tangents: r,
						normals: o,
						binormals: l
					}
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(source) {
					return this.arcLengthDivisions = source.arcLengthDivisions, this
				}
				toJSON() {
					const data = {
						metadata: {
							version: 4.5,
							type: "Curve",
							generator: "Curve.toJSON"
						}
					};
					return data.arcLengthDivisions = this.arcLengthDivisions, data.type = this.type, data
				}
				fromJSON(t) {
					return this.arcLengthDivisions = t.arcLengthDivisions, this
				}
			}
			class xo extends yo {
				constructor(t = 0, e = 0, n = 1, r = 1, o = 0, l = 2 * Math.PI, c = !1, h = 0) {
					super(), this.type = "EllipseCurve", this.aX = t, this.aY = e, this.xRadius = n, this.yRadius = r, this.aStartAngle = o, this.aEndAngle = l, this.aClockwise = c, this.aRotation = h
				}
				getPoint(t, e) {
					const n = e || new Nt,
						r = 2 * Math.PI;
					let o = this.aEndAngle - this.aStartAngle;
					const l = Math.abs(o) < Number.EPSILON;
					for (; o < 0;) o += r;
					for (; o > r;) o -= r;
					o < Number.EPSILON && (o = l ? 0 : r), !0 !== this.aClockwise || l || (o === r ? o = -r : o -= r);
					const c = this.aStartAngle + t * o;
					let h = this.aX + this.xRadius * Math.cos(c),
						d = this.aY + this.yRadius * Math.sin(c);
					if (0 !== this.aRotation) {
						const t = Math.cos(this.aRotation),
							e = Math.sin(this.aRotation),
							n = h - this.aX,
							r = d - this.aY;
						h = n * t - r * e + this.aX, d = n * e + r * t + this.aY
					}
					return n.set(h, d)
				}
				copy(source) {
					return super.copy(source), this.aX = source.aX, this.aY = source.aY, this.xRadius = source.xRadius, this.yRadius = source.yRadius, this.aStartAngle = source.aStartAngle, this.aEndAngle = source.aEndAngle, this.aClockwise = source.aClockwise, this.aRotation = source.aRotation, this
				}
				toJSON() {
					const data = super.toJSON();
					return data.aX = this.aX, data.aY = this.aY, data.xRadius = this.xRadius, data.yRadius = this.yRadius, data.aStartAngle = this.aStartAngle, data.aEndAngle = this.aEndAngle, data.aClockwise = this.aClockwise, data.aRotation = this.aRotation, data
				}
				fromJSON(t) {
					return super.fromJSON(t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
				}
			}
			xo.prototype.isEllipseCurve = !0;
			class _o extends xo {
				constructor(t, e, n, r, o, l) {
					super(t, e, n, n, r, o, l), this.type = "ArcCurve"
				}
			}

			function wo() {
				let t = 0,
					e = 0,
					n = 0,
					r = 0;

				function o(o, l, c, h) {
					t = o, e = c, n = -3 * o + 3 * l - 2 * c - h, r = 2 * o - 2 * l + c + h
				}
				return {
					initCatmullRom: function(t, e, n, r, l) {
						o(e, n, l * (n - t), l * (r - e))
					},
					initNonuniformCatmullRom: function(t, e, n, r, l, c, h) {
						let d = (e - t) / l - (n - t) / (l + c) + (n - e) / c,
							f = (n - e) / c - (r - e) / (c + h) + (r - n) / h;
						d *= c, f *= c, o(e, n, d, f)
					},
					calc: function(o) {
						const l = o * o;
						return t + e * o + n * l + r * (l * o)
					}
				}
			}
			_o.prototype.isArcCurve = !0;
			const Ao = new re,
				bo = new wo,
				Mo = new wo,
				So = new wo;
			class To extends yo {
				constructor(t = [], e = !1, n = "centripetal", r = .5) {
					super(), this.type = "CatmullRomCurve3", this.points = t, this.closed = e, this.curveType = n, this.tension = r
				}
				getPoint(t, e = new re) {
					const n = e,
						r = this.points,
						o = r.length,
						p = (o - (this.closed ? 0 : 1)) * t;
					let l, c, h = Math.floor(p),
						d = p - h;
					this.closed ? h += h > 0 ? 0 : (Math.floor(Math.abs(h) / o) + 1) * o : 0 === d && h === o - 1 && (h = o - 2, d = 1), this.closed || h > 0 ? l = r[(h - 1) % o] : (Ao.subVectors(r[0], r[1]).add(r[0]), l = Ao);
					const f = r[h % o],
						m = r[(h + 1) % o];
					if (this.closed || h + 2 < o ? c = r[(h + 2) % o] : (Ao.subVectors(r[o - 1], r[o - 2]).add(r[o - 1]), c = Ao), "centripetal" === this.curveType || "chordal" === this.curveType) {
						const t = "chordal" === this.curveType ? .5 : .25;
						let e = Math.pow(l.distanceToSquared(f), t),
							n = Math.pow(f.distanceToSquared(m), t),
							r = Math.pow(m.distanceToSquared(c), t);
						n < 1e-4 && (n = 1), e < 1e-4 && (e = n), r < 1e-4 && (r = n), bo.initNonuniformCatmullRom(l.x, f.x, m.x, c.x, e, n, r), Mo.initNonuniformCatmullRom(l.y, f.y, m.y, c.y, e, n, r), So.initNonuniformCatmullRom(l.z, f.z, m.z, c.z, e, n, r)
					} else "catmullrom" === this.curveType && (bo.initCatmullRom(l.x, f.x, m.x, c.x, this.tension), Mo.initCatmullRom(l.y, f.y, m.y, c.y, this.tension), So.initCatmullRom(l.z, f.z, m.z, c.z, this.tension));
					return n.set(bo.calc(d), Mo.calc(d), So.calc(d)), n
				}
				copy(source) {
					super.copy(source), this.points = [];
					for (let i = 0, t = source.points.length; i < t; i++) {
						const t = source.points[i];
						this.points.push(t.clone())
					}
					return this.closed = source.closed, this.curveType = source.curveType, this.tension = source.tension, this
				}
				toJSON() {
					const data = super.toJSON();
					data.points = [];
					for (let i = 0, t = this.points.length; i < t; i++) {
						const t = this.points[i];
						data.points.push(t.toArray())
					}
					return data.closed = this.closed, data.curveType = this.curveType, data.tension = this.tension, data
				}
				fromJSON(t) {
					super.fromJSON(t), this.points = [];
					for (let i = 0, e = t.points.length; i < e; i++) {
						const e = t.points[i];
						this.points.push((new re).fromArray(e))
					}
					return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
				}
			}

			function Eo(t, e, n, r, o) {
				const l = .5 * (r - e),
					c = .5 * (o - n),
					h = t * t;
				return (2 * n - 2 * r + l + c) * (t * h) + (-3 * n + 3 * r - 2 * l - c) * h + l * t + n
			}

			function Co(t, e, n, r) {
				return function(t, p) {
					const e = 1 - t;
					return e * e * p
				}(t, e) + function(t, p) {
					return 2 * (1 - t) * t * p
				}(t, n) + function(t, p) {
					return t * t * p
				}(t, r)
			}

			function Ro(t, e, n, r, o) {
				return function(t, p) {
					const e = 1 - t;
					return e * e * e * p
				}(t, e) + function(t, p) {
					const e = 1 - t;
					return 3 * e * e * t * p
				}(t, n) + function(t, p) {
					return 3 * (1 - t) * t * t * p
				}(t, r) + function(t, p) {
					return t * t * t * p
				}(t, o)
			}
			To.prototype.isCatmullRomCurve3 = !0;
			class Do extends yo {
				constructor(t = new Nt, e = new Nt, n = new Nt, r = new Nt) {
					super(), this.type = "CubicBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
				}
				getPoint(t, e = new Nt) {
					const n = e,
						r = this.v0,
						o = this.v1,
						l = this.v2,
						c = this.v3;
					return n.set(Ro(t, r.x, o.x, l.x, c.x), Ro(t, r.y, o.y, l.y, c.y)), n
				}
				copy(source) {
					return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this.v3.copy(source.v3), this
				}
				toJSON() {
					const data = super.toJSON();
					return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data.v3 = this.v3.toArray(), data
				}
				fromJSON(t) {
					return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
				}
			}
			Do.prototype.isCubicBezierCurve = !0;
			class Lo extends yo {
				constructor(t = new re, e = new re, n = new re, r = new re) {
					super(), this.type = "CubicBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n, this.v3 = r
				}
				getPoint(t, e = new re) {
					const n = e,
						r = this.v0,
						o = this.v1,
						l = this.v2,
						c = this.v3;
					return n.set(Ro(t, r.x, o.x, l.x, c.x), Ro(t, r.y, o.y, l.y, c.y), Ro(t, r.z, o.z, l.z, c.z)), n
				}
				copy(source) {
					return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this.v3.copy(source.v3), this
				}
				toJSON() {
					const data = super.toJSON();
					return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data.v3 = this.v3.toArray(), data
				}
				fromJSON(t) {
					return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
				}
			}
			Lo.prototype.isCubicBezierCurve3 = !0;
			class Po extends yo {
				constructor(t = new Nt, e = new Nt) {
					super(), this.type = "LineCurve", this.v1 = t, this.v2 = e
				}
				getPoint(t, e = new Nt) {
					const n = e;
					return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
				}
				getPointAt(u, t) {
					return this.getPoint(u, t)
				}
				getTangent(t, e) {
					const n = e || new Nt;
					return n.copy(this.v2).sub(this.v1).normalize(), n
				}
				copy(source) {
					return super.copy(source), this.v1.copy(source.v1), this.v2.copy(source.v2), this
				}
				toJSON() {
					const data = super.toJSON();
					return data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
				}
				fromJSON(t) {
					return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
				}
			}
			Po.prototype.isLineCurve = !0;
			class Io extends yo {
				constructor(t = new Nt, e = new Nt, n = new Nt) {
					super(), this.type = "QuadraticBezierCurve", this.v0 = t, this.v1 = e, this.v2 = n
				}
				getPoint(t, e = new Nt) {
					const n = e,
						r = this.v0,
						o = this.v1,
						l = this.v2;
					return n.set(Co(t, r.x, o.x, l.x), Co(t, r.y, o.y, l.y)), n
				}
				copy(source) {
					return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this
				}
				toJSON() {
					const data = super.toJSON();
					return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
				}
				fromJSON(t) {
					return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
				}
			}
			Io.prototype.isQuadraticBezierCurve = !0;
			class Bo extends yo {
				constructor(t = new re, e = new re, n = new re) {
					super(), this.type = "QuadraticBezierCurve3", this.v0 = t, this.v1 = e, this.v2 = n
				}
				getPoint(t, e = new re) {
					const n = e,
						r = this.v0,
						o = this.v1,
						l = this.v2;
					return n.set(Co(t, r.x, o.x, l.x), Co(t, r.y, o.y, l.y), Co(t, r.z, o.z, l.z)), n
				}
				copy(source) {
					return super.copy(source), this.v0.copy(source.v0), this.v1.copy(source.v1), this.v2.copy(source.v2), this
				}
				toJSON() {
					const data = super.toJSON();
					return data.v0 = this.v0.toArray(), data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
				}
				fromJSON(t) {
					return super.fromJSON(t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
				}
			}
			Bo.prototype.isQuadraticBezierCurve3 = !0;
			class Oo extends yo {
				constructor(t = []) {
					super(), this.type = "SplineCurve", this.points = t
				}
				getPoint(t, e = new Nt) {
					const n = e,
						r = this.points,
						p = (r.length - 1) * t,
						o = Math.floor(p),
						l = p - o,
						c = r[0 === o ? o : o - 1],
						h = r[o],
						d = r[o > r.length - 2 ? r.length - 1 : o + 1],
						f = r[o > r.length - 3 ? r.length - 1 : o + 2];
					return n.set(Eo(l, c.x, h.x, d.x, f.x), Eo(l, c.y, h.y, d.y, f.y)), n
				}
				copy(source) {
					super.copy(source), this.points = [];
					for (let i = 0, t = source.points.length; i < t; i++) {
						const t = source.points[i];
						this.points.push(t.clone())
					}
					return this
				}
				toJSON() {
					const data = super.toJSON();
					data.points = [];
					for (let i = 0, t = this.points.length; i < t; i++) {
						const t = this.points[i];
						data.points.push(t.toArray())
					}
					return data
				}
				fromJSON(t) {
					super.fromJSON(t), this.points = [];
					for (let i = 0, e = t.points.length; i < e; i++) {
						const e = t.points[i];
						this.points.push((new Nt).fromArray(e))
					}
					return this
				}
			}
			Oo.prototype.isSplineCurve = !0;
			var Fo = Object.freeze({
				__proto__: null,
				ArcCurve: _o,
				CatmullRomCurve3: To,
				CubicBezierCurve: Do,
				CubicBezierCurve3: Lo,
				EllipseCurve: xo,
				LineCurve: Po,
				LineCurve3: class extends yo {
					constructor(t = new re, e = new re) {
						super(), this.type = "LineCurve3", this.isLineCurve3 = !0, this.v1 = t, this.v2 = e
					}
					getPoint(t, e = new re) {
						const n = e;
						return 1 === t ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(t).add(this.v1)), n
					}
					getPointAt(u, t) {
						return this.getPoint(u, t)
					}
					copy(source) {
						return super.copy(source), this.v1.copy(source.v1), this.v2.copy(source.v2), this
					}
					toJSON() {
						const data = super.toJSON();
						return data.v1 = this.v1.toArray(), data.v2 = this.v2.toArray(), data
					}
					fromJSON(t) {
						return super.fromJSON(t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
					}
				},
				QuadraticBezierCurve: Io,
				QuadraticBezierCurve3: Bo,
				SplineCurve: Oo
			});
			class Ho extends yo {
				constructor() {
					super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
				}
				add(t) {
					this.curves.push(t)
				}
				closePath() {
					const t = this.curves[0].getPoint(0),
						e = this.curves[this.curves.length - 1].getPoint(1);
					t.equals(e) || this.curves.push(new Po(e, t))
				}
				getPoint(t, e) {
					const n = t * this.getLength(),
						r = this.getCurveLengths();
					let i = 0;
					for (; i < r.length;) {
						if (r[i] >= n) {
							const t = r[i] - n,
								o = this.curves[i],
								l = o.getLength(),
								u = 0 === l ? 0 : 1 - t / l;
							return o.getPointAt(u, e)
						}
						i++
					}
					return null
				}
				getLength() {
					const t = this.getCurveLengths();
					return t[t.length - 1]
				}
				updateArcLengths() {
					this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
				}
				getCurveLengths() {
					if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
					const t = [];
					let e = 0;
					for (let i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
					return this.cacheLengths = t, t
				}
				getSpacedPoints(t = 40) {
					const e = [];
					for (let i = 0; i <= t; i++) e.push(this.getPoint(i / t));
					return this.autoClose && e.push(e[0]), e
				}
				getPoints(t = 12) {
					const e = [];
					let n;
					for (let i = 0, r = this.curves; i < r.length; i++) {
						const o = r[i],
							l = o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t,
							c = o.getPoints(l);
						for (let t = 0; t < c.length; t++) {
							const r = c[t];
							n && n.equals(r) || (e.push(r), n = r)
						}
					}
					return this.autoClose && e.length > 1 && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
				}
				copy(source) {
					super.copy(source), this.curves = [];
					for (let i = 0, t = source.curves.length; i < t; i++) {
						const t = source.curves[i];
						this.curves.push(t.clone())
					}
					return this.autoClose = source.autoClose, this
				}
				toJSON() {
					const data = super.toJSON();
					data.autoClose = this.autoClose, data.curves = [];
					for (let i = 0, t = this.curves.length; i < t; i++) {
						const t = this.curves[i];
						data.curves.push(t.toJSON())
					}
					return data
				}
				fromJSON(t) {
					super.fromJSON(t), this.autoClose = t.autoClose, this.curves = [];
					for (let i = 0, e = t.curves.length; i < e; i++) {
						const e = t.curves[i];
						this.curves.push((new Fo[e.type]).fromJSON(e))
					}
					return this
				}
			}
			class No extends Ho {
				constructor(t) {
					super(), this.type = "Path", this.currentPoint = new Nt, t && this.setFromPoints(t)
				}
				setFromPoints(t) {
					this.moveTo(t[0].x, t[0].y);
					for (let i = 1, e = t.length; i < e; i++) this.lineTo(t[i].x, t[i].y);
					return this
				}
				moveTo(t, e) {
					return this.currentPoint.set(t, e), this
				}
				lineTo(t, e) {
					const n = new Po(this.currentPoint.clone(), new Nt(t, e));
					return this.curves.push(n), this.currentPoint.set(t, e), this
				}
				quadraticCurveTo(t, e, n, r) {
					const o = new Io(this.currentPoint.clone(), new Nt(t, e), new Nt(n, r));
					return this.curves.push(o), this.currentPoint.set(n, r), this
				}
				bezierCurveTo(t, e, n, r, o, l) {
					const c = new Do(this.currentPoint.clone(), new Nt(t, e), new Nt(n, r), new Nt(o, l));
					return this.curves.push(c), this.currentPoint.set(o, l), this
				}
				splineThru(t) {
					const e = [this.currentPoint.clone()].concat(t),
						n = new Oo(e);
					return this.curves.push(n), this.currentPoint.copy(t[t.length - 1]), this
				}
				arc(t, e, n, r, o, l) {
					const c = this.currentPoint.x,
						h = this.currentPoint.y;
					return this.absarc(t + c, e + h, n, r, o, l), this
				}
				absarc(t, e, n, r, o, l) {
					return this.absellipse(t, e, n, n, r, o, l), this
				}
				ellipse(t, e, n, r, o, l, c, h) {
					const d = this.currentPoint.x,
						f = this.currentPoint.y;
					return this.absellipse(t + d, e + f, n, r, o, l, c, h), this
				}
				absellipse(t, e, n, r, o, l, c, h) {
					const d = new xo(t, e, n, r, o, l, c, h);
					if (this.curves.length > 0) {
						const t = d.getPoint(0);
						t.equals(this.currentPoint) || this.lineTo(t.x, t.y)
					}
					this.curves.push(d);
					const f = d.getPoint(1);
					return this.currentPoint.copy(f), this
				}
				copy(source) {
					return super.copy(source), this.currentPoint.copy(source.currentPoint), this
				}
				toJSON() {
					const data = super.toJSON();
					return data.currentPoint = this.currentPoint.toArray(), data
				}
				fromJSON(t) {
					return super.fromJSON(t), this.currentPoint.fromArray(t.currentPoint), this
				}
			}
			class Uo extends No {
				constructor(t) {
					super(t), this.uuid = Dt(), this.type = "Shape", this.holes = []
				}
				getPointsHoles(t) {
					const e = [];
					for (let i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
					return e
				}
				extractPoints(t) {
					return {
						shape: this.getPoints(t),
						holes: this.getPointsHoles(t)
					}
				}
				copy(source) {
					super.copy(source), this.holes = [];
					for (let i = 0, t = source.holes.length; i < t; i++) {
						const t = source.holes[i];
						this.holes.push(t.clone())
					}
					return this
				}
				toJSON() {
					const data = super.toJSON();
					data.uuid = this.uuid, data.holes = [];
					for (let i = 0, t = this.holes.length; i < t; i++) {
						const t = this.holes[i];
						data.holes.push(t.toJSON())
					}
					return data
				}
				fromJSON(t) {
					super.fromJSON(t), this.uuid = t.uuid, this.holes = [];
					for (let i = 0, e = t.holes.length; i < e; i++) {
						const e = t.holes[i];
						this.holes.push((new No).fromJSON(e))
					}
					return this
				}
			}
			const zo = function(data, t, e = 2) {
				const n = t && t.length,
					r = n ? t[0] * e : data.length;
				let o = ko(data, 0, r, e, !0);
				const l = [];
				if (!o || o.next === o.prev) return l;
				let c, h, d, f, m, v, y;
				if (n && (o = function(data, t, e, n) {
						const r = [];
						let i, o, l, c, h;
						for (i = 0, o = t.length; i < o; i++) l = t[i] * n, c = i < o - 1 ? t[i + 1] * n : data.length, h = ko(data, l, c, n, !1), h === h.next && (h.steiner = !0), r.push(Zo(h));
						for (r.sort(Qo), i = 0; i < r.length; i++) qo(r[i], e), e = Go(e, e.next);
						return e
					}(data, t, o, e)), data.length > 80 * e) {
					c = d = data[0], h = f = data[1];
					for (let i = e; i < r; i += e) m = data[i], v = data[i + 1], m < c && (c = m), v < h && (h = v), m > d && (d = m), v > f && (f = v);
					y = Math.max(d - c, f - h), y = 0 !== y ? 1 / y : 0
				}
				return Vo(o, l, e, c, h, y), l
			};

			function ko(data, t, e, n, r) {
				let i, o;
				if (r === function(data, t, e, n) {
						let r = 0;
						for (let i = t, o = e - n; i < e; i += n) r += (data[o] - data[i]) * (data[i + 1] + data[o + 1]), o = i;
						return r
					}(data, t, e, n) > 0)
					for (i = t; i < e; i += n) o = ll(i, data[i], data[i + 1], o);
				else
					for (i = e - n; i >= t; i -= n) o = ll(i, data[i], data[i + 1], o);
				return o && el(o, o.next) && (cl(o), o = o.next), o
			}

			function Go(t, e) {
				if (!t) return t;
				e || (e = t);
				let n, p = t;
				do {
					if (n = !1, p.steiner || !el(p, p.next) && 0 !== area(p.prev, p, p.next)) p = p.next;
					else {
						if (cl(p), p = e = p.prev, p === p.next) break;
						n = !0
					}
				} while (n || p !== e);
				return e
			}

			function Vo(t, e, n, r, o, l, c) {
				if (!t) return;
				!c && l && function(t, e, n, r) {
					let p = t;
					do {
						null === p.z && (p.z = Ko(p.x, p.y, e, n, r)), p.prevZ = p.prev, p.nextZ = p.next, p = p.next
					} while (p !== t);
					p.prevZ.nextZ = null, p.prevZ = null,
						function(t) {
							let i, p, q, e, n, r, o, l, c = 1;
							do {
								for (p = t, t = null, n = null, r = 0; p;) {
									for (r++, q = p, o = 0, i = 0; i < c && (o++, q = q.nextZ, q); i++);
									for (l = c; o > 0 || l > 0 && q;) 0 !== o && (0 === l || !q || p.z <= q.z) ? (e = p, p = p.nextZ, o--) : (e = q, q = q.nextZ, l--), n ? n.nextZ = e : t = e, e.prevZ = n, n = e;
									p = q
								}
								n.nextZ = null, c *= 2
							} while (r > 1)
						}(p)
				}(t, r, o, l);
				let h, d, f = t;
				for (; t.prev !== t.next;)
					if (h = t.prev, d = t.next, l ? jo(t, r, o, l) : Wo(t)) e.push(h.i / n), e.push(t.i / n), e.push(d.i / n), cl(t), t = d.next, f = d.next;
					else if ((t = d) === f) {
					c ? 1 === c ? Vo(t = Xo(Go(t), e, n), e, n, r, o, l, 2) : 2 === c && Yo(t, e, n, r, o, l) : Vo(Go(t), e, n, r, o, l, 1);
					break
				}
			}

			function Wo(t) {
				const a = t.prev,
					b = t,
					e = t.next;
				if (area(a, b, e) >= 0) return !1;
				let p = t.next.next;
				for (; p !== t.prev;) {
					if ($o(a.x, a.y, b.x, b.y, e.x, e.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
					p = p.next
				}
				return !0
			}

			function jo(t, e, n, r) {
				const a = t.prev,
					b = t,
					o = t.next;
				if (area(a, b, o) >= 0) return !1;
				const l = a.x < b.x ? a.x < o.x ? a.x : o.x : b.x < o.x ? b.x : o.x,
					c = a.y < b.y ? a.y < o.y ? a.y : o.y : b.y < o.y ? b.y : o.y,
					h = a.x > b.x ? a.x > o.x ? a.x : o.x : b.x > o.x ? b.x : o.x,
					d = a.y > b.y ? a.y > o.y ? a.y : o.y : b.y > o.y ? b.y : o.y,
					f = Ko(l, c, e, n, r),
					m = Ko(h, d, e, n, r);
				let p = t.prevZ,
					v = t.nextZ;
				for (; p && p.z >= f && v && v.z <= m;) {
					if (p !== t.prev && p !== t.next && $o(a.x, a.y, b.x, b.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
					if (p = p.prevZ, v !== t.prev && v !== t.next && $o(a.x, a.y, b.x, b.y, o.x, o.y, v.x, v.y) && area(v.prev, v, v.next) >= 0) return !1;
					v = v.nextZ
				}
				for (; p && p.z >= f;) {
					if (p !== t.prev && p !== t.next && $o(a.x, a.y, b.x, b.y, o.x, o.y, p.x, p.y) && area(p.prev, p, p.next) >= 0) return !1;
					p = p.prevZ
				}
				for (; v && v.z <= m;) {
					if (v !== t.prev && v !== t.next && $o(a.x, a.y, b.x, b.y, o.x, o.y, v.x, v.y) && area(v.prev, v, v.next) >= 0) return !1;
					v = v.nextZ
				}
				return !0
			}

			function Xo(t, e, n) {
				let p = t;
				do {
					const a = p.prev,
						b = p.next.next;
					!el(a, b) && nl(a, p, p.next, b) && sl(a, b) && sl(b, a) && (e.push(a.i / n), e.push(p.i / n), e.push(b.i / n), cl(p), cl(p.next), p = t = b), p = p.next
				} while (p !== t);
				return Go(p)
			}

			function Yo(t, e, n, r, o, l) {
				let a = t;
				do {
					let b = a.next.next;
					for (; b !== a.prev;) {
						if (a.i !== b.i && tl(a, b)) {
							let t = al(a, b);
							return a = Go(a, a.next), t = Go(t, t.next), Vo(a, e, n, r, o, l), void Vo(t, e, n, r, o, l)
						}
						b = b.next
					}
					a = a.next
				} while (a !== t)
			}

			function Qo(a, b) {
				return a.x - b.x
			}

			function qo(t, e) {
				if (e = function(t, e) {
						let p = e;
						const n = t.x,
							r = t.y;
						let o, l = -1 / 0;
						do {
							if (r <= p.y && r >= p.next.y && p.next.y !== p.y) {
								const t = p.x + (r - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
								if (t <= n && t > l) {
									if (l = t, t === n) {
										if (r === p.y) return p;
										if (r === p.next.y) return p.next
									}
									o = p.x < p.next.x ? p : p.next
								}
							}
							p = p.next
						} while (p !== e);
						if (!o) return null;
						if (n === l) return o;
						const c = o,
							h = o.x,
							d = o.y;
						let f, m = 1 / 0;
						p = o;
						do {
							n >= p.x && p.x >= h && n !== p.x && $o(r < d ? n : l, r, h, d, r < d ? l : n, r, p.x, p.y) && (f = Math.abs(r - p.y) / (n - p.x), sl(p, t) && (f < m || f === m && (p.x > o.x || p.x === o.x && Jo(o, p))) && (o = p, m = f)), p = p.next
						} while (p !== c);
						return o
					}(t, e)) {
					const b = al(e, t);
					Go(e, e.next), Go(b, b.next)
				}
			}

			function Jo(t, p) {
				return area(t.prev, t, p.prev) < 0 && area(p.next, t, t.next) < 0
			}

			function Ko(t, e, n, r, o) {
				return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - n) * o) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - r) * o) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1
			}

			function Zo(t) {
				let p = t,
					e = t;
				do {
					(p.x < e.x || p.x === e.x && p.y < e.y) && (e = p), p = p.next
				} while (p !== t);
				return e
			}

			function $o(t, e, n, r, o, l, c, h) {
				return (o - c) * (e - h) - (t - c) * (l - h) >= 0 && (t - c) * (r - h) - (n - c) * (e - h) >= 0 && (n - c) * (l - h) - (o - c) * (r - h) >= 0
			}

			function tl(a, b) {
				return a.next.i !== b.i && a.prev.i !== b.i && ! function(a, b) {
					let p = a;
					do {
						if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && nl(p, p.next, a, b)) return !0;
						p = p.next
					} while (p !== a);
					return !1
				}(a, b) && (sl(a, b) && sl(b, a) && function(a, b) {
					let p = a,
						t = !1;
					const e = (a.x + b.x) / 2,
						n = (a.y + b.y) / 2;
					do {
						p.y > n != p.next.y > n && p.next.y !== p.y && e < (p.next.x - p.x) * (n - p.y) / (p.next.y - p.y) + p.x && (t = !t), p = p.next
					} while (p !== a);
					return t
				}(a, b) && (area(a.prev, a, b.prev) || area(a, b.prev, b)) || el(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0)
			}

			function area(p, q, t) {
				return (q.y - p.y) * (t.x - q.x) - (q.x - p.x) * (t.y - q.y)
			}

			function el(t, e) {
				return t.x === e.x && t.y === e.y
			}

			function nl(t, e, n, r) {
				const o = rl(area(t, e, n)),
					l = rl(area(t, e, r)),
					c = rl(area(n, r, t)),
					h = rl(area(n, r, e));
				return o !== l && c !== h || (!(0 !== o || !il(t, n, e)) || (!(0 !== l || !il(t, r, e)) || (!(0 !== c || !il(n, t, r)) || !(0 !== h || !il(n, e, r)))))
			}

			function il(p, q, t) {
				return q.x <= Math.max(p.x, t.x) && q.x >= Math.min(p.x, t.x) && q.y <= Math.max(p.y, t.y) && q.y >= Math.min(p.y, t.y)
			}

			function rl(t) {
				return t > 0 ? 1 : t < 0 ? -1 : 0
			}

			function sl(a, b) {
				return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0
			}

			function al(a, b) {
				const t = new hl(a.i, a.x, a.y),
					e = new hl(b.i, b.x, b.y),
					n = a.next,
					r = b.prev;
				return a.next = b, b.prev = a, t.next = n, n.prev = t, e.next = t, t.prev = e, r.next = e, e.prev = r, e
			}

			function ll(i, t, e, n) {
				const p = new hl(i, t, e);
				return n ? (p.next = n.next, p.prev = n, n.next.prev = p, n.next = p) : (p.prev = p, p.next = p), p
			}

			function cl(p) {
				p.next.prev = p.prev, p.prev.next = p.next, p.prevZ && (p.prevZ.nextZ = p.nextZ), p.nextZ && (p.nextZ.prevZ = p.prevZ)
			}

			function hl(i, t, e) {
				this.i = i, this.x = t, this.y = e, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
			}
			class pl {
				static area(t) {
					const e = t.length;
					let a = 0;
					for (let p = e - 1, q = 0; q < e; p = q++) a += t[p].x * t[q].y - t[q].x * t[p].y;
					return .5 * a
				}
				static isClockWise(t) {
					return pl.area(t) < 0
				}
				static triangulateShape(t, e) {
					const n = [],
						r = [],
						o = [];
					fl(t), ml(n, t);
					let l = t.length;
					e.forEach(fl);
					for (let i = 0; i < e.length; i++) r.push(l), l += e[i].length, ml(n, e[i]);
					const c = zo(n, r);
					for (let i = 0; i < c.length; i += 3) o.push(c.slice(i, i + 3));
					return o
				}
			}

			function fl(t) {
				const e = t.length;
				e > 2 && t[e - 1].equals(t[0]) && t.pop()
			}

			function ml(t, e) {
				for (let i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
			}
			class gl extends On {
				constructor(t = new Uo([new Nt(.5, .5), new Nt(-.5, .5), new Nt(-.5, -.5), new Nt(.5, -.5)]), e = {}) {
					super(), this.type = "ExtrudeGeometry", this.parameters = {
						shapes: t,
						options: e
					}, t = Array.isArray(t) ? t : [t];
					const n = this,
						r = [],
						o = [];
					for (let i = 0, e = t.length; i < e; i++) {
						l(t[i])
					}

					function l(t) {
						const l = [],
							c = void 0 !== e.curveSegments ? e.curveSegments : 12,
							h = void 0 !== e.steps ? e.steps : 1;
						let d = void 0 !== e.depth ? e.depth : 1,
							f = void 0 === e.bevelEnabled || e.bevelEnabled,
							m = void 0 !== e.bevelThickness ? e.bevelThickness : .2,
							v = void 0 !== e.bevelSize ? e.bevelSize : m - .1,
							y = void 0 !== e.bevelOffset ? e.bevelOffset : 0,
							x = void 0 !== e.bevelSegments ? e.bevelSegments : 3;
						const _ = e.extrudePath,
							w = void 0 !== e.UVGenerator ? e.UVGenerator : vl;
						void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), d = e.amount);
						let A, M, S, T, E, C = !1;
						_ && (A = _.getSpacedPoints(h), C = !0, f = !1, M = _.computeFrenetFrames(h, !1), S = new re, T = new re, E = new re), f || (x = 0, m = 0, v = 0, y = 0);
						const R = t.extractPoints(c);
						let D = R.shape;
						const L = R.holes;
						if (!pl.isClockWise(D)) {
							D = D.reverse();
							for (let t = 0, e = L.length; t < e; t++) {
								const e = L[t];
								pl.isClockWise(e) && (L[t] = e.reverse())
							}
						}
						const P = pl.triangulateShape(D, L),
							I = D;
						for (let t = 0, e = L.length; t < e; t++) {
							const e = L[t];
							D = D.concat(e)
						}

						function B(t, e, n) {
							return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(n).add(t)
						}
						const O = D.length,
							F = P.length;

						function H(t, e, n) {
							let r, o, l;
							const c = t.x - e.x,
								h = t.y - e.y,
								d = n.x - t.x,
								f = n.y - t.y,
								m = c * c + h * h,
								v = c * f - h * d;
							if (Math.abs(v) > Number.EPSILON) {
								const v = Math.sqrt(m),
									y = Math.sqrt(d * d + f * f),
									x = e.x - h / v,
									_ = e.y + c / v,
									w = ((n.x - f / y - x) * f - (n.y + d / y - _) * d) / (c * f - h * d);
								r = x + c * w - t.x, o = _ + h * w - t.y;
								const A = r * r + o * o;
								if (A <= 2) return new Nt(r, o);
								l = Math.sqrt(A / 2)
							} else {
								let t = !1;
								c > Number.EPSILON ? d > Number.EPSILON && (t = !0) : c < -Number.EPSILON ? d < -Number.EPSILON && (t = !0) : Math.sign(h) === Math.sign(f) && (t = !0), t ? (r = -h, o = c, l = Math.sqrt(m)) : (r = c, o = h, l = Math.sqrt(m / 2))
							}
							return new Nt(r / l, o / l)
						}
						const N = [];
						for (let i = 0, t = I.length, e = t - 1, n = i + 1; i < t; i++, e++, n++) e === t && (e = 0), n === t && (n = 0), N[i] = H(I[i], I[e], I[n]);
						const U = [];
						let z, k = N.concat();
						for (let t = 0, e = L.length; t < e; t++) {
							const e = L[t];
							z = [];
							for (let i = 0, t = e.length, n = t - 1, r = i + 1; i < t; i++, n++, r++) n === t && (n = 0), r === t && (r = 0), z[i] = H(e[i], e[n], e[r]);
							U.push(z), k = k.concat(z)
						}
						for (let b = 0; b < x; b++) {
							const t = b / x,
								e = m * Math.cos(t * Math.PI / 2),
								n = v * Math.sin(t * Math.PI / 2) + y;
							for (let i = 0, t = I.length; i < t; i++) {
								const t = B(I[i], N[i], n);
								W(t.x, t.y, -e)
							}
							for (let t = 0, r = L.length; t < r; t++) {
								const r = L[t];
								z = U[t];
								for (let i = 0, t = r.length; i < t; i++) {
									const t = B(r[i], z[i], n);
									W(t.x, t.y, -e)
								}
							}
						}
						const G = v + y;
						for (let i = 0; i < O; i++) {
							const t = f ? B(D[i], k[i], G) : D[i];
							C ? (T.copy(M.normals[0]).multiplyScalar(t.x), S.copy(M.binormals[0]).multiplyScalar(t.y), E.copy(A[0]).add(T).add(S), W(E.x, E.y, E.z)) : W(t.x, t.y, 0)
						}
						for (let s = 1; s <= h; s++)
							for (let i = 0; i < O; i++) {
								const t = f ? B(D[i], k[i], G) : D[i];
								C ? (T.copy(M.normals[s]).multiplyScalar(t.x), S.copy(M.binormals[s]).multiplyScalar(t.y), E.copy(A[s]).add(T).add(S), W(E.x, E.y, E.z)) : W(t.x, t.y, d / h * s)
							}
						for (let b = x - 1; b >= 0; b--) {
							const t = b / x,
								e = m * Math.cos(t * Math.PI / 2),
								n = v * Math.sin(t * Math.PI / 2) + y;
							for (let i = 0, t = I.length; i < t; i++) {
								const t = B(I[i], N[i], n);
								W(t.x, t.y, d + e)
							}
							for (let t = 0, r = L.length; t < r; t++) {
								const r = L[t];
								z = U[t];
								for (let i = 0, t = r.length; i < t; i++) {
									const t = B(r[i], z[i], n);
									C ? W(t.x, t.y + A[h - 1].y, A[h - 1].x + e) : W(t.x, t.y, d + e)
								}
							}
						}

						function V(t, e) {
							let i = t.length;
							for (; --i >= 0;) {
								const n = i;
								let r = i - 1;
								r < 0 && (r = t.length - 1);
								for (let s = 0, t = h + 2 * x; s < t; s++) {
									const t = O * s,
										o = O * (s + 1);
									X(e + n + t, e + r + t, e + r + o, e + n + o)
								}
							}
						}

						function W(t, e, n) {
							l.push(t), l.push(e), l.push(n)
						}

						function j(a, b, t) {
							Y(a), Y(b), Y(t);
							const e = r.length / 3,
								o = w.generateTopUV(n, r, e - 3, e - 2, e - 1);
							Q(o[0]), Q(o[1]), Q(o[2])
						}

						function X(a, b, t, e) {
							Y(a), Y(b), Y(e), Y(b), Y(t), Y(e);
							const o = r.length / 3,
								l = w.generateSideWallUV(n, r, o - 6, o - 3, o - 2, o - 1);
							Q(l[0]), Q(l[1]), Q(l[3]), Q(l[1]), Q(l[2]), Q(l[3])
						}

						function Y(t) {
							r.push(l[3 * t + 0]), r.push(l[3 * t + 1]), r.push(l[3 * t + 2])
						}

						function Q(t) {
							o.push(t.x), o.push(t.y)
						}! function() {
							const t = r.length / 3;
							if (f) {
								let t = 0,
									e = O * t;
								for (let i = 0; i < F; i++) {
									const t = P[i];
									j(t[2] + e, t[1] + e, t[0] + e)
								}
								t = h + 2 * x, e = O * t;
								for (let i = 0; i < F; i++) {
									const t = P[i];
									j(t[0] + e, t[1] + e, t[2] + e)
								}
							} else {
								for (let i = 0; i < F; i++) {
									const t = P[i];
									j(t[2], t[1], t[0])
								}
								for (let i = 0; i < F; i++) {
									const t = P[i];
									j(t[0] + O * h, t[1] + O * h, t[2] + O * h)
								}
							}
							n.addGroup(t, r.length / 3 - t, 0)
						}(),
						function() {
							const t = r.length / 3;
							let e = 0;
							V(I, e), e += I.length;
							for (let t = 0, n = L.length; t < n; t++) {
								const n = L[t];
								V(n, e), e += n.length
							}
							n.addGroup(t, r.length / 3 - t, 1)
						}()
					}
					this.setAttribute("position", new En(r, 3)), this.setAttribute("uv", new En(o, 2)), this.computeVertexNormals()
				}
				toJSON() {
					const data = super.toJSON();
					return function(t, e, data) {
						if (data.shapes = [], Array.isArray(t))
							for (let i = 0, e = t.length; i < e; i++) {
								const e = t[i];
								data.shapes.push(e.uuid)
							} else data.shapes.push(t.uuid);
						void 0 !== e.extrudePath && (data.options.extrudePath = e.extrudePath.toJSON());
						return data
					}(this.parameters.shapes, this.parameters.options, data)
				}
				static fromJSON(data, t) {
					const e = [];
					for (let n = 0, r = data.shapes.length; n < r; n++) {
						const r = t[data.shapes[n]];
						e.push(r)
					}
					const n = data.options.extrudePath;
					return void 0 !== n && (data.options.extrudePath = (new Fo[n.type]).fromJSON(n)), new gl(e, data.options)
				}
			}
			const vl = {
				generateTopUV: function(t, e, n, r, o) {
					const l = e[3 * n],
						c = e[3 * n + 1],
						h = e[3 * r],
						d = e[3 * r + 1],
						f = e[3 * o],
						m = e[3 * o + 1];
					return [new Nt(l, c), new Nt(h, d), new Nt(f, m)]
				},
				generateSideWallUV: function(t, e, n, r, o, l) {
					const c = e[3 * n],
						h = e[3 * n + 1],
						d = e[3 * n + 2],
						f = e[3 * r],
						m = e[3 * r + 1],
						v = e[3 * r + 2],
						y = e[3 * o],
						x = e[3 * o + 1],
						_ = e[3 * o + 2],
						w = e[3 * l],
						A = e[3 * l + 1],
						M = e[3 * l + 2];
					return Math.abs(h - m) < Math.abs(c - f) ? [new Nt(c, 1 - d), new Nt(f, 1 - v), new Nt(y, 1 - _), new Nt(w, 1 - M)] : [new Nt(h, 1 - d), new Nt(m, 1 - v), new Nt(x, 1 - _), new Nt(A, 1 - M)]
				}
			};
			class yl extends On {
				constructor(t = new Uo([new Nt(0, .5), new Nt(-.5, -.5), new Nt(.5, -.5)]), e = 12) {
					super(), this.type = "ShapeGeometry", this.parameters = {
						shapes: t,
						curveSegments: e
					};
					const n = [],
						r = [],
						o = [],
						l = [];
					let c = 0,
						h = 0;
					if (!1 === Array.isArray(t)) d(t);
					else
						for (let i = 0; i < t.length; i++) d(t[i]), this.addGroup(c, h, i), c += h, h = 0;

					function d(t) {
						const c = r.length / 3,
							d = t.extractPoints(e);
						let f = d.shape;
						const m = d.holes;
						!1 === pl.isClockWise(f) && (f = f.reverse());
						for (let i = 0, t = m.length; i < t; i++) {
							const t = m[i];
							!0 === pl.isClockWise(t) && (m[i] = t.reverse())
						}
						const v = pl.triangulateShape(f, m);
						for (let i = 0, t = m.length; i < t; i++) {
							const t = m[i];
							f = f.concat(t)
						}
						for (let i = 0, t = f.length; i < t; i++) {
							const t = f[i];
							r.push(t.x, t.y, 0), o.push(0, 0, 1), l.push(t.x, t.y)
						}
						for (let i = 0, t = v.length; i < t; i++) {
							const t = v[i],
								a = t[0] + c,
								b = t[1] + c,
								e = t[2] + c;
							n.push(a, b, e), h += 3
						}
					}
					this.setIndex(n), this.setAttribute("position", new En(r, 3)), this.setAttribute("normal", new En(o, 3)), this.setAttribute("uv", new En(l, 2))
				}
				toJSON() {
					const data = super.toJSON();
					return function(t, data) {
						if (data.shapes = [], Array.isArray(t))
							for (let i = 0, e = t.length; i < e; i++) {
								const e = t[i];
								data.shapes.push(e.uuid)
							} else data.shapes.push(t.uuid);
						return data
					}(this.parameters.shapes, data)
				}
				static fromJSON(data, t) {
					const e = [];
					for (let n = 0, r = data.shapes.length; n < r; n++) {
						const r = t[data.shapes[n]];
						e.push(r)
					}
					return new yl(e, data.curveSegments)
				}
			}
			class xl extends On {
				constructor(t = 1, e = .4, n = 8, r = 6, o = 2 * Math.PI) {
					super(), this.type = "TorusGeometry", this.parameters = {
						radius: t,
						tube: e,
						radialSegments: n,
						tubularSegments: r,
						arc: o
					}, n = Math.floor(n), r = Math.floor(r);
					const l = [],
						c = [],
						h = [],
						d = [],
						f = new re,
						m = new re,
						v = new re;
					for (let l = 0; l <= n; l++)
						for (let i = 0; i <= r; i++) {
							const u = i / r * o,
								y = l / n * Math.PI * 2;
							m.x = (t + e * Math.cos(y)) * Math.cos(u), m.y = (t + e * Math.cos(y)) * Math.sin(u), m.z = e * Math.sin(y), c.push(m.x, m.y, m.z), f.x = t * Math.cos(u), f.y = t * Math.sin(u), v.subVectors(m, f).normalize(), h.push(v.x, v.y, v.z), d.push(i / r), d.push(l / n)
						}
					for (let t = 1; t <= n; t++)
						for (let i = 1; i <= r; i++) {
							const a = (r + 1) * t + i - 1,
								b = (r + 1) * (t - 1) + i - 1,
								e = (r + 1) * (t - 1) + i,
								n = (r + 1) * t + i;
							l.push(a, b, n), l.push(b, e, n)
						}
					this.setIndex(l), this.setAttribute("position", new En(c, 3)), this.setAttribute("normal", new En(h, 3)), this.setAttribute("uv", new En(d, 2))
				}
				static fromJSON(data) {
					return new xl(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc)
				}
			}
			class _l extends _n {
				constructor(t) {
					super(), this.type = "ShadowMaterial", this.color = new Qt(0), this.transparent = !0, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this
				}
			}
			_l.prototype.isShadowMaterial = !0;
			class wl extends _n {
				constructor(t) {
					super(), this.defines = {
						STANDARD: ""
					}, this.type = "MeshStandardMaterial", this.color = new Qt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xt, this.normalScale = new Nt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.defines = {
						STANDARD: ""
					}, this.color.copy(source.color), this.roughness = source.roughness, this.metalness = source.metalness, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.roughnessMap = source.roughnessMap, this.metalnessMap = source.metalnessMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.envMapIntensity = source.envMapIntensity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.flatShading = source.flatShading, this
				}
			}
			wl.prototype.isMeshStandardMaterial = !0;
			class Al extends wl {
				constructor(t) {
					super(), this.defines = {
						STANDARD: "",
						PHYSICAL: ""
					}, this.type = "MeshPhysicalMaterial", this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Nt(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
						get: function() {
							return Lt(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
						},
						set: function(t) {
							this.ior = (1 + .4 * t) / (1 - .4 * t)
						}
					}), this.sheenColor = new Qt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 0, this.attenuationColor = new Qt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new Qt(1, 1, 1), this.specularColorMap = null, this._sheen = 0, this._clearcoat = 0, this._transmission = 0, this.setValues(t)
				}
				get sheen() {
					return this._sheen
				}
				set sheen(t) {
					this._sheen > 0 != t > 0 && this.version++, this._sheen = t
				}
				get clearcoat() {
					return this._clearcoat
				}
				set clearcoat(t) {
					this._clearcoat > 0 != t > 0 && this.version++, this._clearcoat = t
				}
				get transmission() {
					return this._transmission
				}
				set transmission(t) {
					this._transmission > 0 != t > 0 && this.version++, this._transmission = t
				}
				copy(source) {
					return super.copy(source), this.defines = {
						STANDARD: "",
						PHYSICAL: ""
					}, this.clearcoat = source.clearcoat, this.clearcoatMap = source.clearcoatMap, this.clearcoatRoughness = source.clearcoatRoughness, this.clearcoatRoughnessMap = source.clearcoatRoughnessMap, this.clearcoatNormalMap = source.clearcoatNormalMap, this.clearcoatNormalScale.copy(source.clearcoatNormalScale), this.ior = source.ior, this.sheen = source.sheen, this.sheenColor.copy(source.sheenColor), this.sheenColorMap = source.sheenColorMap, this.sheenRoughness = source.sheenRoughness, this.sheenRoughnessMap = source.sheenRoughnessMap, this.transmission = source.transmission, this.transmissionMap = source.transmissionMap, this.thickness = source.thickness, this.thicknessMap = source.thicknessMap, this.attenuationDistance = source.attenuationDistance, this.attenuationColor.copy(source.attenuationColor), this.specularIntensity = source.specularIntensity, this.specularIntensityMap = source.specularIntensityMap, this.specularColor.copy(source.specularColor), this.specularColorMap = source.specularColorMap, this
				}
			}
			Al.prototype.isMeshPhysicalMaterial = !0;
			class bl extends _n {
				constructor(t) {
					super(), this.type = "MeshPhongMaterial", this.color = new Qt(16777215), this.specular = new Qt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xt, this.normalScale = new Nt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this.specular.copy(source.specular), this.shininess = source.shininess, this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this.flatShading = source.flatShading, this
				}
			}
			bl.prototype.isMeshPhongMaterial = !0;
			class Ml extends _n {
				constructor(t) {
					super(), this.defines = {
						TOON: ""
					}, this.type = "MeshToonMaterial", this.color = new Qt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xt, this.normalScale = new Nt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this.map = source.map, this.gradientMap = source.gradientMap, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.alphaMap = source.alphaMap, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this
				}
			}
			Ml.prototype.isMeshToonMaterial = !0;
			class Sl extends _n {
				constructor(t) {
					super(), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xt, this.normalScale = new Nt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.flatShading = !1, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.flatShading = source.flatShading, this
				}
			}
			Sl.prototype.isMeshNormalMaterial = !0;
			class Tl extends _n {
				constructor(t) {
					super(), this.type = "MeshLambertMaterial", this.color = new Qt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new Qt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this.map = source.map, this.lightMap = source.lightMap, this.lightMapIntensity = source.lightMapIntensity, this.aoMap = source.aoMap, this.aoMapIntensity = source.aoMapIntensity, this.emissive.copy(source.emissive), this.emissiveMap = source.emissiveMap, this.emissiveIntensity = source.emissiveIntensity, this.specularMap = source.specularMap, this.alphaMap = source.alphaMap, this.envMap = source.envMap, this.combine = source.combine, this.reflectivity = source.reflectivity, this.refractionRatio = source.refractionRatio, this.wireframe = source.wireframe, this.wireframeLinewidth = source.wireframeLinewidth, this.wireframeLinecap = source.wireframeLinecap, this.wireframeLinejoin = source.wireframeLinejoin, this
				}
			}
			Tl.prototype.isMeshLambertMaterial = !0;
			class El extends _n {
				constructor(t) {
					super(), this.defines = {
						MATCAP: ""
					}, this.type = "MeshMatcapMaterial", this.color = new Qt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = xt, this.normalScale = new Nt(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.defines = {
						MATCAP: ""
					}, this.color.copy(source.color), this.matcap = source.matcap, this.map = source.map, this.bumpMap = source.bumpMap, this.bumpScale = source.bumpScale, this.normalMap = source.normalMap, this.normalMapType = source.normalMapType, this.normalScale.copy(source.normalScale), this.displacementMap = source.displacementMap, this.displacementScale = source.displacementScale, this.displacementBias = source.displacementBias, this.alphaMap = source.alphaMap, this.flatShading = source.flatShading, this
				}
			}
			El.prototype.isMeshMatcapMaterial = !0;
			class Cl extends Ka {
				constructor(t) {
					super(), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.scale = source.scale, this.dashSize = source.dashSize, this.gapSize = source.gapSize, this
				}
			}
			Cl.prototype.isLineDashedMaterial = !0;
			const Rl = {
				arraySlice: function(t, e, n) {
					return Rl.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== n ? n : t.length)) : t.slice(e, n)
				},
				convertArray: function(t, e, n) {
					return !t || !n && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
				},
				isTypedArray: function(object) {
					return ArrayBuffer.isView(object) && !(object instanceof DataView)
				},
				getKeyframeOrder: function(t) {
					const e = t.length,
						n = new Array(e);
					for (let i = 0; i !== e; ++i) n[i] = i;
					return n.sort((function(i, e) {
						return t[i] - t[e]
					})), n
				},
				sortedArray: function(t, e, n) {
					const r = t.length,
						o = new t.constructor(r);
					for (let i = 0, l = 0; l !== r; ++i) {
						const r = n[i] * e;
						for (let n = 0; n !== e; ++n) o[l++] = t[r + n]
					}
					return o
				},
				flattenJSON: function(t, e, n, r) {
					let i = 1,
						o = t[0];
					for (; void 0 !== o && void 0 === o[r];) o = t[i++];
					if (void 0 === o) return;
					let l = o[r];
					if (void 0 !== l)
						if (Array.isArray(l))
							do {
								l = o[r], void 0 !== l && (e.push(o.time), n.push.apply(n, l)), o = t[i++]
							} while (void 0 !== o);
						else if (void 0 !== l.toArray)
						do {
							l = o[r], void 0 !== l && (e.push(o.time), l.toArray(n, n.length)), o = t[i++]
						} while (void 0 !== o);
					else
						do {
							l = o[r], void 0 !== l && (e.push(o.time), n.push(l)), o = t[i++]
						} while (void 0 !== o)
				},
				subclip: function(t, e, n, r, o = 30) {
					const l = t.clone();
					l.name = e;
					const c = [];
					for (let i = 0; i < l.tracks.length; ++i) {
						const track = l.tracks[i],
							t = track.getValueSize(),
							e = [],
							h = [];
						for (let l = 0; l < track.times.length; ++l) {
							const c = track.times[l] * o;
							if (!(c < n || c >= r)) {
								e.push(track.times[l]);
								for (let e = 0; e < t; ++e) h.push(track.values[l * t + e])
							}
						}
						0 !== e.length && (track.times = Rl.convertArray(e, track.times.constructor), track.values = Rl.convertArray(h, track.values.constructor), c.push(track))
					}
					l.tracks = c;
					let h = 1 / 0;
					for (let i = 0; i < l.tracks.length; ++i) h > l.tracks[i].times[0] && (h = l.tracks[i].times[0]);
					for (let i = 0; i < l.tracks.length; ++i) l.tracks[i].shift(-1 * h);
					return l.resetDuration(), l
				},
				makeClipAdditive: function(t, e = 0, n = t, r = 30) {
					r <= 0 && (r = 30);
					const o = n.tracks.length,
						l = e / r;
					for (let i = 0; i < o; ++i) {
						const e = n.tracks[i],
							r = e.ValueTypeName;
						if ("bool" === r || "string" === r) continue;
						const o = t.tracks.find((function(track) {
							return track.name === e.name && track.ValueTypeName === r
						}));
						if (void 0 === o) continue;
						let c = 0;
						const h = e.getValueSize();
						e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (c = h / 3);
						let d = 0;
						const f = o.getValueSize();
						o.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = f / 3);
						const m = e.times.length - 1;
						let v;
						if (l <= e.times[0]) {
							const t = c,
								n = h - c;
							v = Rl.arraySlice(e.values, t, n)
						} else if (l >= e.times[m]) {
							const t = m * h + c,
								n = t + h - c;
							v = Rl.arraySlice(e.values, t, n)
						} else {
							const t = e.createInterpolant(),
								n = c,
								r = h - c;
							t.evaluate(l), v = Rl.arraySlice(t.resultBuffer, n, r)
						}
						if ("quaternion" === r) {
							(new ie).fromArray(v).normalize().conjugate().toArray(v)
						}
						const y = o.times.length;
						for (let t = 0; t < y; ++t) {
							const e = t * f + d;
							if ("quaternion" === r) ie.multiplyQuaternionsFlat(o.values, e, v, 0, o.values, e);
							else {
								const t = f - 2 * d;
								for (let n = 0; n < t; ++n) o.values[e + n] -= v[n]
							}
						}
					}
					return t.blendMode = 2501, t
				}
			};
			class Dl {
				constructor(t, e, n, r) {
					this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== r ? r : new e.constructor(n), this.sampleValues = e, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
				}
				evaluate(t) {
					const e = this.parameterPositions;
					let n = this._cachedIndex,
						r = e[n],
						o = e[n - 1];
					t: {
						e: {
							let l;n: {
								i: if (!(t < r)) {
									for (let l = n + 2;;) {
										if (void 0 === r) {
											if (t < o) break i;
											return n = e.length, this._cachedIndex = n, this.afterEnd_(n - 1, t, o)
										}
										if (n === l) break;
										if (o = r, r = e[++n], t < r) break e
									}
									l = e.length;
									break n
								}if (t >= o) break t; {
									const c = e[1];
									t < c && (n = 2, o = c);
									for (let l = n - 2;;) {
										if (void 0 === o) return this._cachedIndex = 0, this.beforeStart_(0, t, r);
										if (n === l) break;
										if (r = o, o = e[--n - 1], t >= o) break e
									}
									l = n, n = 0
								}
							}
							for (; n < l;) {
								const r = n + l >>> 1;
								t < e[r] ? l = r : n = r + 1
							}
							if (r = e[n], o = e[n - 1], void 0 === o) return this._cachedIndex = 0,
							this.beforeStart_(0, t, r);
							if (void 0 === r) return n = e.length,
							this._cachedIndex = n,
							this.afterEnd_(n - 1, o, t)
						}
						this._cachedIndex = n,
						this.intervalChanged_(n, o, r)
					}
					return this.interpolate_(n, o, t, r)
				}
				getSettings_() {
					return this.settings || this.DefaultSettings_
				}
				copySampleValue_(t) {
					const e = this.resultBuffer,
						n = this.sampleValues,
						r = this.valueSize,
						o = t * r;
					for (let i = 0; i !== r; ++i) e[i] = n[o + i];
					return e
				}
				interpolate_() {
					throw new Error("call to abstract method")
				}
				intervalChanged_() {}
			}
			Dl.prototype.beforeStart_ = Dl.prototype.copySampleValue_, Dl.prototype.afterEnd_ = Dl.prototype.copySampleValue_;
			class Ll extends Dl {
				constructor(t, e, n, r) {
					super(t, e, n, r), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
						endingStart: lt,
						endingEnd: lt
					}
				}
				intervalChanged_(t, e, n) {
					const r = this.parameterPositions;
					let o = t - 2,
						l = t + 1,
						c = r[o],
						h = r[l];
					if (void 0 === c) switch (this.getSettings_().endingStart) {
						case ct:
							o = t, c = 2 * e - n;
							break;
						case ht:
							o = r.length - 2, c = e + r[o] - r[o + 1];
							break;
						default:
							o = t, c = n
					}
					if (void 0 === h) switch (this.getSettings_().endingEnd) {
						case ct:
							l = t, h = 2 * n - e;
							break;
						case ht:
							l = 1, h = n + r[1] - r[0];
							break;
						default:
							l = t - 1, h = e
					}
					const d = .5 * (n - e),
						f = this.valueSize;
					this._weightPrev = d / (e - c), this._weightNext = d / (h - n), this._offsetPrev = o * f, this._offsetNext = l * f
				}
				interpolate_(t, e, n, r) {
					const o = this.resultBuffer,
						l = this.sampleValues,
						c = this.valueSize,
						h = t * c,
						d = h - c,
						f = this._offsetPrev,
						m = this._offsetNext,
						v = this._weightPrev,
						y = this._weightNext,
						p = (n - e) / (r - e),
						x = p * p,
						_ = x * p,
						w = -v * _ + 2 * v * x - v * p,
						A = (1 + v) * _ + (-1.5 - 2 * v) * x + (-.5 + v) * p + 1,
						M = (-1 - y) * _ + (1.5 + y) * x + .5 * p,
						S = y * _ - y * x;
					for (let i = 0; i !== c; ++i) o[i] = w * l[f + i] + A * l[d + i] + M * l[h + i] + S * l[m + i];
					return o
				}
			}
			class Pl extends Dl {
				constructor(t, e, n, r) {
					super(t, e, n, r)
				}
				interpolate_(t, e, n, r) {
					const o = this.resultBuffer,
						l = this.sampleValues,
						c = this.valueSize,
						h = t * c,
						d = h - c,
						f = (n - e) / (r - e),
						m = 1 - f;
					for (let i = 0; i !== c; ++i) o[i] = l[d + i] * m + l[h + i] * f;
					return o
				}
			}
			class Il extends Dl {
				constructor(t, e, n, r) {
					super(t, e, n, r)
				}
				interpolate_(t) {
					return this.copySampleValue_(t - 1)
				}
			}
			class Bl {
				constructor(t, e, n, r) {
					if (void 0 === t) throw new Error("THREE.KeyframeTrack: track name is undefined");
					if (void 0 === e || 0 === e.length) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + t);
					this.name = t, this.times = Rl.convertArray(e, this.TimeBufferType), this.values = Rl.convertArray(n, this.ValueBufferType), this.setInterpolation(r || this.DefaultInterpolation)
				}
				static toJSON(track) {
					const t = track.constructor;
					let e;
					if (t.toJSON !== this.toJSON) e = t.toJSON(track);
					else {
						e = {
							name: track.name,
							times: Rl.convertArray(track.times, Array),
							values: Rl.convertArray(track.values, Array)
						};
						const t = track.getInterpolation();
						t !== track.DefaultInterpolation && (e.interpolation = t)
					}
					return e.type = track.ValueTypeName, e
				}
				InterpolantFactoryMethodDiscrete(t) {
					return new Il(this.times, this.values, this.getValueSize(), t)
				}
				InterpolantFactoryMethodLinear(t) {
					return new Pl(this.times, this.values, this.getValueSize(), t)
				}
				InterpolantFactoryMethodSmooth(t) {
					return new Ll(this.times, this.values, this.getValueSize(), t)
				}
				setInterpolation(t) {
					let e;
					switch (t) {
						case st:
							e = this.InterpolantFactoryMethodDiscrete;
							break;
						case at:
							e = this.InterpolantFactoryMethodLinear;
							break;
						case ot:
							e = this.InterpolantFactoryMethodSmooth
					}
					if (void 0 === e) {
						const e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
						if (void 0 === this.createInterpolant) {
							if (t === this.DefaultInterpolation) throw new Error(e);
							this.setInterpolation(this.DefaultInterpolation)
						}
						return console.warn("THREE.KeyframeTrack:", e), this
					}
					return this.createInterpolant = e, this
				}
				getInterpolation() {
					switch (this.createInterpolant) {
						case this.InterpolantFactoryMethodDiscrete:
							return st;
						case this.InterpolantFactoryMethodLinear:
							return at;
						case this.InterpolantFactoryMethodSmooth:
							return ot
					}
				}
				getValueSize() {
					return this.values.length / this.times.length
				}
				shift(t) {
					if (0 !== t) {
						const e = this.times;
						for (let i = 0, n = e.length; i !== n; ++i) e[i] += t
					}
					return this
				}
				scale(t) {
					if (1 !== t) {
						const e = this.times;
						for (let i = 0, n = e.length; i !== n; ++i) e[i] *= t
					}
					return this
				}
				trim(t, e) {
					const n = this.times,
						r = n.length;
					let o = 0,
						l = r - 1;
					for (; o !== r && n[o] < t;) ++o;
					for (; - 1 !== l && n[l] > e;) --l;
					if (++l, 0 !== o || l !== r) {
						o >= l && (l = Math.max(l, 1), o = l - 1);
						const t = this.getValueSize();
						this.times = Rl.arraySlice(n, o, l), this.values = Rl.arraySlice(this.values, o * t, l * t)
					}
					return this
				}
				validate() {
					let t = !0;
					const e = this.getValueSize();
					e - Math.floor(e) != 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
					const n = this.times,
						r = this.values,
						o = n.length;
					0 === o && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
					let l = null;
					for (let i = 0; i !== o; i++) {
						const e = n[i];
						if ("number" == typeof e && isNaN(e)) {
							console.error("THREE.KeyframeTrack: Time is not a valid number.", this, i, e), t = !1;
							break
						}
						if (null !== l && l > e) {
							console.error("THREE.KeyframeTrack: Out of order keys.", this, i, e, l), t = !1;
							break
						}
						l = e
					}
					if (void 0 !== r && Rl.isTypedArray(r))
						for (let i = 0, e = r.length; i !== e; ++i) {
							const e = r[i];
							if (isNaN(e)) {
								console.error("THREE.KeyframeTrack: Value is not a valid number.", this, i, e), t = !1;
								break
							}
						}
					return t
				}
				optimize() {
					const t = Rl.arraySlice(this.times),
						e = Rl.arraySlice(this.values),
						n = this.getValueSize(),
						r = this.getInterpolation() === ot,
						o = t.length - 1;
					let l = 1;
					for (let i = 1; i < o; ++i) {
						let o = !1;
						const time = t[i];
						if (time !== t[i + 1] && (1 !== i || time !== t[0]))
							if (r) o = !0;
							else {
								const t = i * n,
									r = t - n,
									l = t + n;
								for (let c = 0; c !== n; ++c) {
									const n = e[t + c];
									if (n !== e[r + c] || n !== e[l + c]) {
										o = !0;
										break
									}
								}
							} if (o) {
							if (i !== l) {
								t[l] = t[i];
								const r = i * n,
									o = l * n;
								for (let t = 0; t !== n; ++t) e[o + t] = e[r + t]
							}++l
						}
					}
					if (o > 0) {
						t[l] = t[o];
						for (let t = o * n, r = l * n, c = 0; c !== n; ++c) e[r + c] = e[t + c];
						++l
					}
					return l !== t.length ? (this.times = Rl.arraySlice(t, 0, l), this.values = Rl.arraySlice(e, 0, l * n)) : (this.times = t, this.values = e), this
				}
				clone() {
					const t = Rl.arraySlice(this.times, 0),
						e = Rl.arraySlice(this.values, 0),
						track = new(0, this.constructor)(this.name, t, e);
					return track.createInterpolant = this.createInterpolant, track
				}
			}
			Bl.prototype.TimeBufferType = Float32Array, Bl.prototype.ValueBufferType = Float32Array, Bl.prototype.DefaultInterpolation = at;
			class Ol extends Bl {}
			Ol.prototype.ValueTypeName = "bool", Ol.prototype.ValueBufferType = Array, Ol.prototype.DefaultInterpolation = st, Ol.prototype.InterpolantFactoryMethodLinear = void 0, Ol.prototype.InterpolantFactoryMethodSmooth = void 0;
			class Fl extends Bl {}
			Fl.prototype.ValueTypeName = "color";
			class Hl extends Bl {}
			Hl.prototype.ValueTypeName = "number";
			class Nl extends Dl {
				constructor(t, e, n, r) {
					super(t, e, n, r)
				}
				interpolate_(t, e, n, r) {
					const o = this.resultBuffer,
						l = this.sampleValues,
						c = this.valueSize,
						h = (n - e) / (r - e);
					let d = t * c;
					for (let t = d + c; d !== t; d += 4) ie.slerpFlat(o, 0, l, d - c, l, d, h);
					return o
				}
			}
			class Ul extends Bl {
				InterpolantFactoryMethodLinear(t) {
					return new Nl(this.times, this.values, this.getValueSize(), t)
				}
			}
			Ul.prototype.ValueTypeName = "quaternion", Ul.prototype.DefaultInterpolation = at, Ul.prototype.InterpolantFactoryMethodSmooth = void 0;
			class zl extends Bl {}
			zl.prototype.ValueTypeName = "string", zl.prototype.ValueBufferType = Array, zl.prototype.DefaultInterpolation = st, zl.prototype.InterpolantFactoryMethodLinear = void 0, zl.prototype.InterpolantFactoryMethodSmooth = void 0;
			class kl extends Bl {}
			kl.prototype.ValueTypeName = "vector";
			class Gl {
				constructor(t, e = -1, n, r = 2500) {
					this.name = t, this.tracks = n, this.duration = e, this.blendMode = r, this.uuid = Dt(), this.duration < 0 && this.resetDuration()
				}
				static parse(t) {
					const e = [],
						n = t.tracks,
						r = 1 / (t.fps || 1);
					for (let i = 0, t = n.length; i !== t; ++i) e.push(Vl(n[i]).scale(r));
					const o = new this(t.name, t.duration, e, t.blendMode);
					return o.uuid = t.uuid, o
				}
				static toJSON(t) {
					const e = [],
						n = t.tracks,
						r = {
							name: t.name,
							duration: t.duration,
							tracks: e,
							uuid: t.uuid,
							blendMode: t.blendMode
						};
					for (let i = 0, t = n.length; i !== t; ++i) e.push(Bl.toJSON(n[i]));
					return r
				}
				static CreateFromMorphTargetSequence(t, e, n, r) {
					const o = e.length,
						l = [];
					for (let i = 0; i < o; i++) {
						let t = [],
							c = [];
						t.push((i + o - 1) % o, i, (i + 1) % o), c.push(0, 1, 0);
						const h = Rl.getKeyframeOrder(t);
						t = Rl.sortedArray(t, 1, h), c = Rl.sortedArray(c, 1, h), r || 0 !== t[0] || (t.push(o), c.push(c[0])), l.push(new Hl(".morphTargetInfluences[" + e[i].name + "]", t, c).scale(1 / n))
					}
					return new this(t, -1, l)
				}
				static findByName(t, e) {
					let n = t;
					if (!Array.isArray(t)) {
						const e = t;
						n = e.geometry && e.geometry.animations || e.animations
					}
					for (let i = 0; i < n.length; i++)
						if (n[i].name === e) return n[i];
					return null
				}
				static CreateClipsFromMorphTargetSequences(t, e, n) {
					const r = {},
						pattern = /^([\w-]*?)([\d]+)$/;
					for (let i = 0, e = t.length; i < e; i++) {
						const e = t[i],
							n = e.name.match(pattern);
						if (n && n.length > 1) {
							const t = n[1];
							let o = r[t];
							o || (r[t] = o = []), o.push(e)
						}
					}
					const o = [];
					for (const t in r) o.push(this.CreateFromMorphTargetSequence(t, r[t], e, n));
					return o
				}
				static parseAnimation(t, e) {
					if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
					const n = function(t, e, n, r, o) {
							if (0 !== n.length) {
								const l = [],
									c = [];
								Rl.flattenJSON(n, l, c, r), 0 !== l.length && o.push(new t(e, l, c))
							}
						},
						r = [],
						o = t.name || "default",
						l = t.fps || 30,
						c = t.blendMode;
					let h = t.length || -1;
					const d = t.hierarchy || [];
					for (let t = 0; t < d.length; t++) {
						const o = d[t].keys;
						if (o && 0 !== o.length)
							if (o[0].morphTargets) {
								const t = {};
								let e;
								for (e = 0; e < o.length; e++)
									if (o[e].morphTargets)
										for (let n = 0; n < o[e].morphTargets.length; n++) t[o[e].morphTargets[n]] = -1;
								for (const n in t) {
									const t = [],
										l = [];
									for (let r = 0; r !== o[e].morphTargets.length; ++r) {
										const r = o[e];
										t.push(r.time), l.push(r.morphTarget === n ? 1 : 0)
									}
									r.push(new Hl(".morphTargetInfluence[" + n + "]", t, l))
								}
								h = t.length * (l || 1)
							} else {
								const l = ".bones[" + e[t].name + "]";
								n(kl, l + ".position", o, "pos", r), n(Ul, l + ".quaternion", o, "rot", r), n(kl, l + ".scale", o, "scl", r)
							}
					}
					if (0 === r.length) return null;
					return new this(o, h, r, c)
				}
				resetDuration() {
					let t = 0;
					for (let i = 0, e = this.tracks.length; i !== e; ++i) {
						const track = this.tracks[i];
						t = Math.max(t, track.times[track.times.length - 1])
					}
					return this.duration = t, this
				}
				trim() {
					for (let i = 0; i < this.tracks.length; i++) this.tracks[i].trim(0, this.duration);
					return this
				}
				validate() {
					let t = !0;
					for (let i = 0; i < this.tracks.length; i++) t = t && this.tracks[i].validate();
					return t
				}
				optimize() {
					for (let i = 0; i < this.tracks.length; i++) this.tracks[i].optimize();
					return this
				}
				clone() {
					const t = [];
					for (let i = 0; i < this.tracks.length; i++) t.push(this.tracks[i].clone());
					return new this.constructor(this.name, this.duration, t, this.blendMode)
				}
				toJSON() {
					return this.constructor.toJSON(this)
				}
			}

			function Vl(t) {
				if (void 0 === t.type) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
				const e = function(t) {
					switch (t.toLowerCase()) {
						case "scalar":
						case "double":
						case "float":
						case "number":
						case "integer":
							return Hl;
						case "vector":
						case "vector2":
						case "vector3":
						case "vector4":
							return kl;
						case "color":
							return Fl;
						case "quaternion":
							return Ul;
						case "bool":
						case "boolean":
							return Ol;
						case "string":
							return zl
					}
					throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
				}(t.type);
				if (void 0 === t.times) {
					const e = [],
						n = [];
					Rl.flattenJSON(t.keys, e, n, "value"), t.times = e, t.values = n
				}
				return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
			}
			const Wl = {
				enabled: !1,
				files: {},
				add: function(t, e) {
					!1 !== this.enabled && (this.files[t] = e)
				},
				get: function(t) {
					if (!1 !== this.enabled) return this.files[t]
				},
				remove: function(t) {
					delete this.files[t]
				},
				clear: function() {
					this.files = {}
				}
			};
			class jl {
				constructor(t, e, n) {
					const r = this;
					let o, l = !1,
						c = 0,
						h = 0;
					const d = [];
					this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = n, this.itemStart = function(t) {
						h++, !1 === l && void 0 !== r.onStart && r.onStart(t, c, h), l = !0
					}, this.itemEnd = function(t) {
						c++, void 0 !== r.onProgress && r.onProgress(t, c, h), c === h && (l = !1, void 0 !== r.onLoad && r.onLoad())
					}, this.itemError = function(t) {
						void 0 !== r.onError && r.onError(t)
					}, this.resolveURL = function(t) {
						return o ? o(t) : t
					}, this.setURLModifier = function(t) {
						return o = t, this
					}, this.addHandler = function(t, e) {
						return d.push(t, e), this
					}, this.removeHandler = function(t) {
						const e = d.indexOf(t);
						return -1 !== e && d.splice(e, 2), this
					}, this.getHandler = function(t) {
						for (let i = 0, e = d.length; i < e; i += 2) {
							const e = d[i],
								n = d[i + 1];
							if (e.global && (e.lastIndex = 0), e.test(t)) return n
						}
						return null
					}
				}
			}
			const Xl = new jl;
			class Yl {
				constructor(t) {
					this.manager = void 0 !== t ? t : Xl, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
				}
				load() {}
				loadAsync(t, e) {
					const n = this;
					return new Promise((function(r, o) {
						n.load(t, r, e, o)
					}))
				}
				parse() {}
				setCrossOrigin(t) {
					return this.crossOrigin = t, this
				}
				setWithCredentials(t) {
					return this.withCredentials = t, this
				}
				setPath(path) {
					return this.path = path, this
				}
				setResourcePath(t) {
					return this.resourcePath = t, this
				}
				setRequestHeader(t) {
					return this.requestHeader = t, this
				}
			}
			const Ql = {};
			class ql extends Yl {
				constructor(t) {
					super(t)
				}
				load(t, e, n, r) {
					void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
					const o = Wl.get(t);
					if (void 0 !== o) return this.manager.itemStart(t), setTimeout((() => {
						e && e(o), this.manager.itemEnd(t)
					}), 0), o;
					if (void 0 !== Ql[t]) return void Ql[t].push({
						onLoad: e,
						onProgress: n,
						onError: r
					});
					Ql[t] = [], Ql[t].push({
						onLoad: e,
						onProgress: n,
						onError: r
					});
					const l = new Request(t, {
							headers: new Headers(this.requestHeader),
							credentials: this.withCredentials ? "include" : "same-origin"
						}),
						c = this.mimeType,
						h = this.responseType;
					fetch(l).then((e => {
						if (200 === e.status || 0 === e.status) {
							if (0 === e.status && console.warn("THREE.FileLoader: HTTP Status 0 received."), "undefined" == typeof ReadableStream || void 0 === e.body.getReader) return e;
							const n = Ql[t],
								r = e.body.getReader(),
								o = e.headers.get("Content-Length"),
								l = o ? parseInt(o) : 0,
								c = 0 !== l;
							let h = 0;
							const d = new ReadableStream({
								start(t) {
									! function e() {
										r.read().then((({
											done: r,
											value: o
										}) => {
											if (r) t.close();
											else {
												h += o.byteLength;
												const r = new ProgressEvent("progress", {
													lengthComputable: c,
													loaded: h,
													total: l
												});
												for (let i = 0, t = n.length; i < t; i++) {
													const t = n[i];
													t.onProgress && t.onProgress(r)
												}
												t.enqueue(o), e()
											}
										}))
									}()
								}
							});
							return new Response(d)
						}
						throw Error(`fetch for "${e.url}" responded with ${e.status}: ${e.statusText}`)
					})).then((t => {
						switch (h) {
							case "arraybuffer":
								return t.arrayBuffer();
							case "blob":
								return t.blob();
							case "document":
								return t.text().then((text => (new DOMParser).parseFromString(text, c)));
							case "json":
								return t.json();
							default:
								if (void 0 === c) return t.text(); {
									const e = /charset="?([^;"\s]*)"?/i.exec(c),
										label = e && e[1] ? e[1].toLowerCase() : void 0,
										n = new TextDecoder(label);
									return t.arrayBuffer().then((t => n.decode(t)))
								}
						}
					})).then((data => {
						Wl.add(t, data);
						const e = Ql[t];
						delete Ql[t];
						for (let i = 0, t = e.length; i < t; i++) {
							const t = e[i];
							t.onLoad && t.onLoad(data)
						}
					})).catch((e => {
						const n = Ql[t];
						if (void 0 === n) throw this.manager.itemError(t), e;
						delete Ql[t];
						for (let i = 0, t = n.length; i < t; i++) {
							const t = n[i];
							t.onError && t.onError(e)
						}
						this.manager.itemError(t)
					})).finally((() => {
						this.manager.itemEnd(t)
					})), this.manager.itemStart(t)
				}
				setResponseType(t) {
					return this.responseType = t, this
				}
				setMimeType(t) {
					return this.mimeType = t, this
				}
			}
			class Jl extends Yl {
				constructor(t) {
					super(t)
				}
				load(t, e, n, r) {
					void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
					const o = this,
						l = Wl.get(t);
					if (void 0 !== l) return o.manager.itemStart(t), setTimeout((function() {
						e && e(l), o.manager.itemEnd(t)
					}), 0), l;
					const image = kt("img");

					function c() {
						d(), Wl.add(t, this), e && e(this), o.manager.itemEnd(t)
					}

					function h(e) {
						d(), r && r(e), o.manager.itemError(t), o.manager.itemEnd(t)
					}

					function d() {
						image.removeEventListener("load", c, !1), image.removeEventListener("error", h, !1)
					}
					return image.addEventListener("load", c, !1), image.addEventListener("error", h, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (image.crossOrigin = this.crossOrigin), o.manager.itemStart(t), image.src = t, image
				}
			}
			class Kl extends Yl {
				constructor(t) {
					super(t)
				}
				load(t, e, n, r) {
					const o = new ui,
						l = new Jl(this.manager);
					l.setCrossOrigin(this.crossOrigin), l.setPath(this.path);
					let c = 0;

					function h(i) {
						l.load(t[i], (function(image) {
							o.images[i] = image, c++, 6 === c && (o.needsUpdate = !0, e && e(o))
						}), void 0, r)
					}
					for (let i = 0; i < t.length; ++i) h(i);
					return o
				}
			}
			class Zl extends Yl {
				constructor(t) {
					super(t)
				}
				load(t, e, n, r) {
					const o = new Zt,
						l = new Jl(this.manager);
					return l.setCrossOrigin(this.crossOrigin), l.setPath(this.path), l.load(t, (function(image) {
						o.image = image, o.needsUpdate = !0, void 0 !== e && e(o)
					}), n, r), o
				}
			}
			class $l extends on {
				constructor(t, e = 1) {
					super(), this.type = "Light", this.color = new Qt(t), this.intensity = e
				}
				dispose() {}
				copy(source) {
					return super.copy(source), this.color.copy(source.color), this.intensity = source.intensity, this
				}
				toJSON(meta) {
					const data = super.toJSON(meta);
					return data.object.color = this.color.getHex(), data.object.intensity = this.intensity, void 0 !== this.groundColor && (data.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (data.object.distance = this.distance), void 0 !== this.angle && (data.object.angle = this.angle), void 0 !== this.decay && (data.object.decay = this.decay), void 0 !== this.penumbra && (data.object.penumbra = this.penumbra), void 0 !== this.shadow && (data.object.shadow = this.shadow.toJSON()), data
				}
			}
			$l.prototype.isLight = !0;
			class tc extends $l {
				constructor(t, e, n) {
					super(t, n), this.type = "HemisphereLight", this.position.copy(on.DefaultUp), this.updateMatrix(), this.groundColor = new Qt(e)
				}
				copy(source) {
					return $l.prototype.copy.call(this, source), this.groundColor.copy(source.groundColor), this
				}
			}
			tc.prototype.isHemisphereLight = !0;
			const ec = new Oe,
				nc = new re,
				ic = new re;
			class rc {
				constructor(t) {
					this.camera = t, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Nt(512, 512), this.map = null, this.mapPass = null, this.matrix = new Oe, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new xi, this._frameExtents = new Nt(1, 1), this._viewportCount = 1, this._viewports = [new te(0, 0, 1, 1)]
				}
				getViewportCount() {
					return this._viewportCount
				}
				getFrustum() {
					return this._frustum
				}
				updateMatrices(t) {
					const e = this.camera,
						n = this.matrix;
					nc.setFromMatrixPosition(t.matrixWorld), e.position.copy(nc), ic.setFromMatrixPosition(t.target.matrixWorld), e.lookAt(ic), e.updateMatrixWorld(), ec.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), this._frustum.setFromProjectionMatrix(ec), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(e.projectionMatrix), n.multiply(e.matrixWorldInverse)
				}
				getViewport(t) {
					return this._viewports[t]
				}
				getFrameExtents() {
					return this._frameExtents
				}
				dispose() {
					this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
				}
				copy(source) {
					return this.camera = source.camera.clone(), this.bias = source.bias, this.radius = source.radius, this.mapSize.copy(source.mapSize), this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				toJSON() {
					const object = {};
					return 0 !== this.bias && (object.bias = this.bias), 0 !== this.normalBias && (object.normalBias = this.normalBias), 1 !== this.radius && (object.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (object.mapSize = this.mapSize.toArray()), object.camera = this.camera.toJSON(!1).object, delete object.camera.matrix, object
				}
			}
			class sc extends rc {
				constructor() {
					super(new oi(50, 1, .5, 500)), this.focus = 1
				}
				updateMatrices(t) {
					const e = this.camera,
						n = 2 * Rt * t.angle * this.focus,
						r = this.mapSize.width / this.mapSize.height,
						o = t.distance || e.far;
					n === e.fov && r === e.aspect && o === e.far || (e.fov = n, e.aspect = r, e.far = o, e.updateProjectionMatrix()), super.updateMatrices(t)
				}
				copy(source) {
					return super.copy(source), this.focus = source.focus, this
				}
			}
			sc.prototype.isSpotLightShadow = !0;
			class ac extends $l {
				constructor(t, e, n = 0, r = Math.PI / 3, o = 0, l = 1) {
					super(t, e), this.type = "SpotLight", this.position.copy(on.DefaultUp), this.updateMatrix(), this.target = new on, this.distance = n, this.angle = r, this.penumbra = o, this.decay = l, this.shadow = new sc
				}
				get power() {
					return this.intensity * Math.PI
				}
				set power(t) {
					this.intensity = t / Math.PI
				}
				dispose() {
					this.shadow.dispose()
				}
				copy(source) {
					return super.copy(source), this.distance = source.distance, this.angle = source.angle, this.penumbra = source.penumbra, this.decay = source.decay, this.target = source.target.clone(), this.shadow = source.shadow.clone(), this
				}
			}
			ac.prototype.isSpotLight = !0;
			const oc = new Oe,
				lc = new re,
				cc = new re;
			class hc extends rc {
				constructor() {
					super(new oi(90, 1, .5, 500)), this._frameExtents = new Nt(4, 2), this._viewportCount = 6, this._viewports = [new te(2, 1, 1, 1), new te(0, 1, 1, 1), new te(3, 1, 1, 1), new te(1, 1, 1, 1), new te(3, 0, 1, 1), new te(1, 0, 1, 1)], this._cubeDirections = [new re(1, 0, 0), new re(-1, 0, 0), new re(0, 0, 1), new re(0, 0, -1), new re(0, 1, 0), new re(0, -1, 0)], this._cubeUps = [new re(0, 1, 0), new re(0, 1, 0), new re(0, 1, 0), new re(0, 1, 0), new re(0, 0, 1), new re(0, 0, -1)]
				}
				updateMatrices(t, e = 0) {
					const n = this.camera,
						r = this.matrix,
						o = t.distance || n.far;
					o !== n.far && (n.far = o, n.updateProjectionMatrix()), lc.setFromMatrixPosition(t.matrixWorld), n.position.copy(lc), cc.copy(n.position), cc.add(this._cubeDirections[e]), n.up.copy(this._cubeUps[e]), n.lookAt(cc), n.updateMatrixWorld(), r.makeTranslation(-lc.x, -lc.y, -lc.z), oc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(oc)
				}
			}
			hc.prototype.isPointLightShadow = !0;
			class uc extends $l {
				constructor(t, e, n = 0, r = 1) {
					super(t, e), this.type = "PointLight", this.distance = n, this.decay = r, this.shadow = new hc
				}
				get power() {
					return 4 * this.intensity * Math.PI
				}
				set power(t) {
					this.intensity = t / (4 * Math.PI)
				}
				dispose() {
					this.shadow.dispose()
				}
				copy(source) {
					return super.copy(source), this.distance = source.distance, this.decay = source.decay, this.shadow = source.shadow.clone(), this
				}
			}
			uc.prototype.isPointLight = !0;
			class dc extends rc {
				constructor() {
					super(new Pi(-5, 5, 5, -5, .5, 500))
				}
			}
			dc.prototype.isDirectionalLightShadow = !0;
			class pc extends $l {
				constructor(t, e) {
					super(t, e), this.type = "DirectionalLight", this.position.copy(on.DefaultUp), this.updateMatrix(), this.target = new on, this.shadow = new dc
				}
				dispose() {
					this.shadow.dispose()
				}
				copy(source) {
					return super.copy(source), this.target = source.target.clone(), this.shadow = source.shadow.clone(), this
				}
			}
			pc.prototype.isDirectionalLight = !0;
			class fc extends $l {
				constructor(t, e) {
					super(t, e), this.type = "AmbientLight"
				}
			}
			fc.prototype.isAmbientLight = !0;
			class mc extends $l {
				constructor(t, e, n = 10, r = 10) {
					super(t, e), this.type = "RectAreaLight", this.width = n, this.height = r
				}
				get power() {
					return this.intensity * this.width * this.height * Math.PI
				}
				set power(t) {
					this.intensity = t / (this.width * this.height * Math.PI)
				}
				copy(source) {
					return super.copy(source), this.width = source.width, this.height = source.height, this
				}
				toJSON(meta) {
					const data = super.toJSON(meta);
					return data.object.width = this.width, data.object.height = this.height, data
				}
			}
			mc.prototype.isRectAreaLight = !0;
			class gc {
				constructor() {
					this.coefficients = [];
					for (let i = 0; i < 9; i++) this.coefficients.push(new re)
				}
				set(t) {
					for (let i = 0; i < 9; i++) this.coefficients[i].copy(t[i]);
					return this
				}
				zero() {
					for (let i = 0; i < 9; i++) this.coefficients[i].set(0, 0, 0);
					return this
				}
				getAt(t, e) {
					const n = t.x,
						r = t.y,
						o = t.z,
						l = this.coefficients;
					return e.copy(l[0]).multiplyScalar(.282095), e.addScaledVector(l[1], .488603 * r), e.addScaledVector(l[2], .488603 * o), e.addScaledVector(l[3], .488603 * n), e.addScaledVector(l[4], n * r * 1.092548), e.addScaledVector(l[5], r * o * 1.092548), e.addScaledVector(l[6], .315392 * (3 * o * o - 1)), e.addScaledVector(l[7], n * o * 1.092548), e.addScaledVector(l[8], .546274 * (n * n - r * r)), e
				}
				getIrradianceAt(t, e) {
					const n = t.x,
						r = t.y,
						o = t.z,
						l = this.coefficients;
					return e.copy(l[0]).multiplyScalar(.886227), e.addScaledVector(l[1], 1.023328 * r), e.addScaledVector(l[2], 1.023328 * o), e.addScaledVector(l[3], 1.023328 * n), e.addScaledVector(l[4], .858086 * n * r), e.addScaledVector(l[5], .858086 * r * o), e.addScaledVector(l[6], .743125 * o * o - .247708), e.addScaledVector(l[7], .858086 * n * o), e.addScaledVector(l[8], .429043 * (n * n - r * r)), e
				}
				add(t) {
					for (let i = 0; i < 9; i++) this.coefficients[i].add(t.coefficients[i]);
					return this
				}
				addScaledSH(t, s) {
					for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(t.coefficients[i], s);
					return this
				}
				scale(s) {
					for (let i = 0; i < 9; i++) this.coefficients[i].multiplyScalar(s);
					return this
				}
				lerp(t, e) {
					for (let i = 0; i < 9; i++) this.coefficients[i].lerp(t.coefficients[i], e);
					return this
				}
				equals(t) {
					for (let i = 0; i < 9; i++)
						if (!this.coefficients[i].equals(t.coefficients[i])) return !1;
					return !0
				}
				copy(t) {
					return this.set(t.coefficients)
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				fromArray(t, e = 0) {
					const n = this.coefficients;
					for (let i = 0; i < 9; i++) n[i].fromArray(t, e + 3 * i);
					return this
				}
				toArray(t = [], e = 0) {
					const n = this.coefficients;
					for (let i = 0; i < 9; i++) n[i].toArray(t, e + 3 * i);
					return t
				}
				static getBasisAt(t, e) {
					const n = t.x,
						r = t.y,
						o = t.z;
					e[0] = .282095, e[1] = .488603 * r, e[2] = .488603 * o, e[3] = .488603 * n, e[4] = 1.092548 * n * r, e[5] = 1.092548 * r * o, e[6] = .315392 * (3 * o * o - 1), e[7] = 1.092548 * n * o, e[8] = .546274 * (n * n - r * r)
				}
			}
			gc.prototype.isSphericalHarmonics3 = !0;
			class vc extends $l {
				constructor(t = new gc, e = 1) {
					super(void 0, e), this.sh = t
				}
				copy(source) {
					return super.copy(source), this.sh.copy(source.sh), this
				}
				fromJSON(t) {
					return this.intensity = t.intensity, this.sh.fromArray(t.sh), this
				}
				toJSON(meta) {
					const data = super.toJSON(meta);
					return data.object.sh = this.sh.toArray(), data
				}
			}
			vc.prototype.isLightProbe = !0;
			class yc {
				static decodeText(t) {
					if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
					let s = "";
					for (let i = 0, e = t.length; i < e; i++) s += String.fromCharCode(t[i]);
					try {
						return decodeURIComponent(escape(s))
					} catch (t) {
						return s
					}
				}
				static extractUrlBase(t) {
					const e = t.lastIndexOf("/");
					return -1 === e ? "./" : t.substr(0, e + 1)
				}
				static resolveURL(t, path) {
					return "string" != typeof t || "" === t ? "" : (/^https?:\/\//i.test(path) && /^\//.test(t) && (path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(t) || /^data:.*,.*$/i.test(t) || /^blob:.*$/i.test(t) ? t : path + t)
				}
			}
			class xc extends On {
				constructor() {
					super(), this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
				}
				copy(source) {
					return super.copy(source), this.instanceCount = source.instanceCount, this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				toJSON() {
					const data = super.toJSON(this);
					return data.instanceCount = this.instanceCount, data.isInstancedBufferGeometry = !0, data
				}
			}
			xc.prototype.isInstancedBufferGeometry = !0;
			class _c extends Yl {
				constructor(t) {
					super(t), "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
						premultiplyAlpha: "none"
					}
				}
				setOptions(t) {
					return this.options = t, this
				}
				load(t, e, n, r) {
					void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
					const o = this,
						l = Wl.get(t);
					if (void 0 !== l) return o.manager.itemStart(t), setTimeout((function() {
						e && e(l), o.manager.itemEnd(t)
					}), 0), l;
					const c = {};
					c.credentials = "anonymous" === this.crossOrigin ? "same-origin" : "include", c.headers = this.requestHeader, fetch(t, c).then((function(t) {
						return t.blob()
					})).then((function(t) {
						return createImageBitmap(t, Object.assign(o.options, {
							colorSpaceConversion: "none"
						}))
					})).then((function(n) {
						Wl.add(t, n), e && e(n), o.manager.itemEnd(t)
					})).catch((function(e) {
						r && r(e), o.manager.itemError(t), o.manager.itemEnd(t)
					})), o.manager.itemStart(t)
				}
			}
			let wc;
			_c.prototype.isImageBitmapLoader = !0;
			const Ac = function() {
				return void 0 === wc && (wc = new(window.AudioContext || window.webkitAudioContext)), wc
			};
			class bc extends Yl {
				constructor(t) {
					super(t)
				}
				load(t, e, n, r) {
					const o = this,
						l = new ql(this.manager);
					l.setResponseType("arraybuffer"), l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(t, (function(n) {
						try {
							const t = n.slice(0);
							Ac().decodeAudioData(t, (function(t) {
								e(t)
							}))
						} catch (e) {
							r ? r(e) : console.error(e), o.manager.itemError(t)
						}
					}), n, r)
				}
			}(class extends vc {
				constructor(t, e, n = 1) {
					super(void 0, n);
					const r = (new Qt).set(t),
						o = (new Qt).set(e),
						l = new re(r.r, r.g, r.b),
						c = new re(o.r, o.g, o.b),
						h = Math.sqrt(Math.PI),
						d = h * Math.sqrt(.75);
					this.sh.coefficients[0].copy(l).add(c).multiplyScalar(h), this.sh.coefficients[1].copy(l).sub(c).multiplyScalar(d)
				}
			}).prototype.isHemisphereLightProbe = !0;
			(class extends vc {
				constructor(t, e = 1) {
					super(void 0, e);
					const n = (new Qt).set(t);
					this.sh.coefficients[0].set(n.r, n.g, n.b).multiplyScalar(2 * Math.sqrt(Math.PI))
				}
			}).prototype.isAmbientLightProbe = !0;
			class Mc {
				constructor(t = !0) {
					this.autoStart = t, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
				}
				start() {
					this.startTime = Sc(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
				}
				stop() {
					this.getElapsedTime(), this.running = !1, this.autoStart = !1
				}
				getElapsedTime() {
					return this.getDelta(), this.elapsedTime
				}
				getDelta() {
					let t = 0;
					if (this.autoStart && !this.running) return this.start(), 0;
					if (this.running) {
						const e = Sc();
						t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
					}
					return t
				}
			}

			function Sc() {
				return ("undefined" == typeof performance ? Date : performance).now()
			}
			const Tc = new re,
				Ec = new ie,
				Cc = new re,
				Rc = new re;
			class Dc extends on {
				constructor() {
					super(), this.type = "AudioListener", this.context = Ac(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new Mc
				}
				getInput() {
					return this.gain
				}
				removeFilter() {
					return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
				}
				getFilter() {
					return this.filter
				}
				setFilter(t) {
					return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
				}
				getMasterVolume() {
					return this.gain.gain.value
				}
				setMasterVolume(t) {
					return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
				}
				updateMatrixWorld(t) {
					super.updateMatrixWorld(t);
					const e = this.context.listener,
						n = this.up;
					if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(Tc, Ec, Cc), Rc.set(0, 0, -1).applyQuaternion(Ec), e.positionX) {
						const t = this.context.currentTime + this.timeDelta;
						e.positionX.linearRampToValueAtTime(Tc.x, t), e.positionY.linearRampToValueAtTime(Tc.y, t), e.positionZ.linearRampToValueAtTime(Tc.z, t), e.forwardX.linearRampToValueAtTime(Rc.x, t), e.forwardY.linearRampToValueAtTime(Rc.y, t), e.forwardZ.linearRampToValueAtTime(Rc.z, t), e.upX.linearRampToValueAtTime(n.x, t), e.upY.linearRampToValueAtTime(n.y, t), e.upZ.linearRampToValueAtTime(n.z, t)
					} else e.setPosition(Tc.x, Tc.y, Tc.z), e.setOrientation(Rc.x, Rc.y, Rc.z, n.x, n.y, n.z)
				}
			}
			class Lc extends on {
				constructor(t) {
					super(), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
				}
				getOutput() {
					return this.gain
				}
				setNodeSource(t) {
					return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
				}
				setMediaElementSource(t) {
					return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
				}
				setMediaStreamSource(t) {
					return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(t), this.connect(), this
				}
				setBuffer(t) {
					return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
				}
				play(t = 0) {
					if (!0 === this.isPlaying) return void console.warn("THREE.Audio: Audio is already playing.");
					if (!1 === this.hasPlaybackControl) return void console.warn("THREE.Audio: this Audio has no playback control.");
					this._startedAt = this.context.currentTime + t;
					const source = this.context.createBufferSource();
					return source.buffer = this.buffer, source.loop = this.loop, source.loopStart = this.loopStart, source.loopEnd = this.loopEnd, source.onended = this.onEnded.bind(this), source.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = source, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
				}
				pause() {
					if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, !0 === this.loop && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				stop() {
					if (!1 !== this.hasPlaybackControl) return this._progress = 0, this.source.stop(), this.source.onended = null, this.isPlaying = !1, this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				connect() {
					if (this.filters.length > 0) {
						this.source.connect(this.filters[0]);
						for (let i = 1, t = this.filters.length; i < t; i++) this.filters[i - 1].connect(this.filters[i]);
						this.filters[this.filters.length - 1].connect(this.getOutput())
					} else this.source.connect(this.getOutput());
					return this._connected = !0, this
				}
				disconnect() {
					if (this.filters.length > 0) {
						this.source.disconnect(this.filters[0]);
						for (let i = 1, t = this.filters.length; i < t; i++) this.filters[i - 1].disconnect(this.filters[i]);
						this.filters[this.filters.length - 1].disconnect(this.getOutput())
					} else this.source.disconnect(this.getOutput());
					return this._connected = !1, this
				}
				getFilters() {
					return this.filters
				}
				setFilters(t) {
					return t || (t = []), !0 === this._connected ? (this.disconnect(), this.filters = t.slice(), this.connect()) : this.filters = t.slice(), this
				}
				setDetune(t) {
					if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
				}
				getDetune() {
					return this.detune
				}
				getFilter() {
					return this.getFilters()[0]
				}
				setFilter(filter) {
					return this.setFilters(filter ? [filter] : [])
				}
				setPlaybackRate(t) {
					if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				getPlaybackRate() {
					return this.playbackRate
				}
				onEnded() {
					this.isPlaying = !1
				}
				getLoop() {
					return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
				}
				setLoop(t) {
					if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
					console.warn("THREE.Audio: this Audio has no playback control.")
				}
				setLoopStart(t) {
					return this.loopStart = t, this
				}
				setLoopEnd(t) {
					return this.loopEnd = t, this
				}
				getVolume() {
					return this.gain.gain.value
				}
				setVolume(t) {
					return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
				}
			}
			const Pc = new re,
				Ic = new ie,
				Bc = new re,
				Oc = new re;
			class Fc extends Lc {
				constructor(t) {
					super(t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
				}
				getOutput() {
					return this.panner
				}
				getRefDistance() {
					return this.panner.refDistance
				}
				setRefDistance(t) {
					return this.panner.refDistance = t, this
				}
				getRolloffFactor() {
					return this.panner.rolloffFactor
				}
				setRolloffFactor(t) {
					return this.panner.rolloffFactor = t, this
				}
				getDistanceModel() {
					return this.panner.distanceModel
				}
				setDistanceModel(t) {
					return this.panner.distanceModel = t, this
				}
				getMaxDistance() {
					return this.panner.maxDistance
				}
				setMaxDistance(t) {
					return this.panner.maxDistance = t, this
				}
				setDirectionalCone(t, e, n) {
					return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = n, this
				}
				updateMatrixWorld(t) {
					if (super.updateMatrixWorld(t), !0 === this.hasPlaybackControl && !1 === this.isPlaying) return;
					this.matrixWorld.decompose(Pc, Ic, Bc), Oc.set(0, 0, 1).applyQuaternion(Ic);
					const e = this.panner;
					if (e.positionX) {
						const t = this.context.currentTime + this.listener.timeDelta;
						e.positionX.linearRampToValueAtTime(Pc.x, t), e.positionY.linearRampToValueAtTime(Pc.y, t), e.positionZ.linearRampToValueAtTime(Pc.z, t), e.orientationX.linearRampToValueAtTime(Oc.x, t), e.orientationY.linearRampToValueAtTime(Oc.y, t), e.orientationZ.linearRampToValueAtTime(Oc.z, t)
					} else e.setPosition(Pc.x, Pc.y, Pc.z), e.setOrientation(Oc.x, Oc.y, Oc.z)
				}
			}
			class Hc {
				constructor(audio, t = 2048) {
					this.analyser = audio.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), audio.getOutput().connect(this.analyser)
				}
				getFrequencyData() {
					return this.analyser.getByteFrequencyData(this.data), this.data
				}
				getAverageFrequency() {
					let t = 0;
					const data = this.getFrequencyData();
					for (let i = 0; i < data.length; i++) t += data[i];
					return t / data.length
				}
			}
			class Nc {
				constructor(t, e, n) {
					let r, o, l;
					switch (this.binding = t, this.valueSize = n, e) {
						case "quaternion":
							r = this._slerp, o = this._slerpAdditive, l = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(6 * n), this._workIndex = 5;
							break;
						case "string":
						case "bool":
							r = this._select, o = this._select, l = this._setAdditiveIdentityOther, this.buffer = new Array(5 * n);
							break;
						default:
							r = this._lerp, o = this._lerpAdditive, l = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(5 * n)
					}
					this._mixBufferRegion = r, this._mixBufferRegionAdditive = o, this._setIdentity = l, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
				}
				accumulate(t, e) {
					const n = this.buffer,
						r = this.valueSize,
						o = t * r + r;
					let l = this.cumulativeWeight;
					if (0 === l) {
						for (let i = 0; i !== r; ++i) n[o + i] = n[i];
						l = e
					} else {
						l += e;
						const t = e / l;
						this._mixBufferRegion(n, o, 0, t, r)
					}
					this.cumulativeWeight = l
				}
				accumulateAdditive(t) {
					const e = this.buffer,
						n = this.valueSize,
						r = n * this._addIndex;
					0 === this.cumulativeWeightAdditive && this._setIdentity(), this._mixBufferRegionAdditive(e, r, 0, t, n), this.cumulativeWeightAdditive += t
				}
				apply(t) {
					const e = this.valueSize,
						n = this.buffer,
						r = t * e + e,
						o = this.cumulativeWeight,
						l = this.cumulativeWeightAdditive,
						c = this.binding;
					if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, o < 1) {
						const t = e * this._origIndex;
						this._mixBufferRegion(n, r, t, 1 - o, e)
					}
					l > 0 && this._mixBufferRegionAdditive(n, r, this._addIndex * e, 1, e);
					for (let i = e, t = e + e; i !== t; ++i)
						if (n[i] !== n[i + e]) {
							c.setValue(n, r);
							break
						}
				}
				saveOriginalState() {
					const t = this.binding,
						e = this.buffer,
						n = this.valueSize,
						r = n * this._origIndex;
					t.getValue(e, r);
					for (let i = n, t = r; i !== t; ++i) e[i] = e[r + i % n];
					this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
				}
				restoreOriginalState() {
					const t = 3 * this.valueSize;
					this.binding.setValue(this.buffer, t)
				}
				_setAdditiveIdentityNumeric() {
					const t = this._addIndex * this.valueSize,
						e = t + this.valueSize;
					for (let i = t; i < e; i++) this.buffer[i] = 0
				}
				_setAdditiveIdentityQuaternion() {
					this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
				}
				_setAdditiveIdentityOther() {
					const t = this._origIndex * this.valueSize,
						e = this._addIndex * this.valueSize;
					for (let i = 0; i < this.valueSize; i++) this.buffer[e + i] = this.buffer[t + i]
				}
				_select(t, e, n, r, o) {
					if (r >= .5)
						for (let i = 0; i !== o; ++i) t[e + i] = t[n + i]
				}
				_slerp(t, e, n, r) {
					ie.slerpFlat(t, e, t, e, t, n, r)
				}
				_slerpAdditive(t, e, n, r, o) {
					const l = this._workIndex * o;
					ie.multiplyQuaternionsFlat(t, l, t, e, t, n), ie.slerpFlat(t, e, t, e, t, l, r)
				}
				_lerp(t, e, n, r, o) {
					const s = 1 - r;
					for (let i = 0; i !== o; ++i) {
						const o = e + i;
						t[o] = t[o] * s + t[n + i] * r
					}
				}
				_lerpAdditive(t, e, n, r, o) {
					for (let i = 0; i !== o; ++i) {
						const o = e + i;
						t[o] = t[o] + t[n + i] * r
					}
				}
			}
			const Uc = "\\[\\]\\.:\\/",
				zc = new RegExp("[\\[\\]\\.:\\/]", "g"),
				kc = "[^\\[\\]\\.:\\/]",
				Gc = "[^" + Uc.replace("\\.", "") + "]",
				Vc = /((?:WC+[\/:])*)/.source.replace("WC", kc),
				Wc = /(WCOD+)?/.source.replace("WCOD", Gc),
				jc = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", kc),
				Xc = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", kc),
				Yc = new RegExp("^" + Vc + Wc + jc + Xc + "$"),
				Qc = ["material", "materials", "bones"];
			class qc {
				constructor(t, path, e) {
					this.path = path, this.parsedPath = e || qc.parseTrackName(path), this.node = qc.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
				}
				static create(t, path, e) {
					return t && t.isAnimationObjectGroup ? new qc.Composite(t, path, e) : new qc(t, path, e)
				}
				static sanitizeNodeName(t) {
					return t.replace(/\s/g, "_").replace(zc, "")
				}
				static parseTrackName(t) {
					const e = Yc.exec(t);
					if (!e) throw new Error("PropertyBinding: Cannot parse trackName: " + t);
					const n = {
							nodeName: e[2],
							objectName: e[3],
							objectIndex: e[4],
							propertyName: e[5],
							propertyIndex: e[6]
						},
						r = n.nodeName && n.nodeName.lastIndexOf(".");
					if (void 0 !== r && -1 !== r) {
						const t = n.nodeName.substring(r + 1); - 1 !== Qc.indexOf(t) && (n.nodeName = n.nodeName.substring(0, r), n.objectName = t)
					}
					if (null === n.propertyName || 0 === n.propertyName.length) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + t);
					return n
				}
				static findNode(t, e) {
					if (!e || "" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
					if (t.skeleton) {
						const n = t.skeleton.getBoneByName(e);
						if (void 0 !== n) return n
					}
					if (t.children) {
						const n = function(t) {
								for (let i = 0; i < t.length; i++) {
									const r = t[i];
									if (r.name === e || r.uuid === e) return r;
									const o = n(r.children);
									if (o) return o
								}
								return null
							},
							r = n(t.children);
						if (r) return r
					}
					return null
				}
				_getValue_unavailable() {}
				_setValue_unavailable() {}
				_getValue_direct(t, e) {
					t[e] = this.targetObject[this.propertyName]
				}
				_getValue_array(t, e) {
					const source = this.resolvedProperty;
					for (let i = 0, n = source.length; i !== n; ++i) t[e++] = source[i]
				}
				_getValue_arrayElement(t, e) {
					t[e] = this.resolvedProperty[this.propertyIndex]
				}
				_getValue_toArray(t, e) {
					this.resolvedProperty.toArray(t, e)
				}
				_setValue_direct(t, e) {
					this.targetObject[this.propertyName] = t[e]
				}
				_setValue_direct_setNeedsUpdate(t, e) {
					this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
				}
				_setValue_direct_setMatrixWorldNeedsUpdate(t, e) {
					this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
				}
				_setValue_array(t, e) {
					const n = this.resolvedProperty;
					for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++]
				}
				_setValue_array_setNeedsUpdate(t, e) {
					const n = this.resolvedProperty;
					for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
					this.targetObject.needsUpdate = !0
				}
				_setValue_array_setMatrixWorldNeedsUpdate(t, e) {
					const n = this.resolvedProperty;
					for (let i = 0, r = n.length; i !== r; ++i) n[i] = t[e++];
					this.targetObject.matrixWorldNeedsUpdate = !0
				}
				_setValue_arrayElement(t, e) {
					this.resolvedProperty[this.propertyIndex] = t[e]
				}
				_setValue_arrayElement_setNeedsUpdate(t, e) {
					this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
				}
				_setValue_arrayElement_setMatrixWorldNeedsUpdate(t, e) {
					this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
				}
				_setValue_fromArray(t, e) {
					this.resolvedProperty.fromArray(t, e)
				}
				_setValue_fromArray_setNeedsUpdate(t, e) {
					this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
				}
				_setValue_fromArray_setMatrixWorldNeedsUpdate(t, e) {
					this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
				}
				_getValue_unbound(t, e) {
					this.bind(), this.getValue(t, e)
				}
				_setValue_unbound(t, e) {
					this.bind(), this.setValue(t, e)
				}
				bind() {
					let t = this.node;
					const e = this.parsedPath,
						n = e.objectName,
						r = e.propertyName;
					let o = e.propertyIndex;
					if (t || (t = qc.findNode(this.rootNode, e.nodeName) || this.rootNode, this.node = t), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !t) return void console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.");
					if (n) {
						let r = e.objectIndex;
						switch (n) {
							case "materials":
								if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
								if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
								t = t.material.materials;
								break;
							case "bones":
								if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
								t = t.skeleton.bones;
								for (let i = 0; i < t.length; i++)
									if (t[i].name === r) {
										r = i;
										break
									} break;
							default:
								if (void 0 === t[n]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
								t = t[n]
						}
						if (void 0 !== r) {
							if (void 0 === t[r]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
							t = t[r]
						}
					}
					const l = t[r];
					if (void 0 === l) {
						const n = e.nodeName;
						return void console.error("THREE.PropertyBinding: Trying to update property for track: " + n + "." + r + " but it wasn't found.", t)
					}
					let c = this.Versioning.None;
					this.targetObject = t, void 0 !== t.needsUpdate ? c = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (c = this.Versioning.MatrixWorldNeedsUpdate);
					let h = this.BindingType.Direct;
					if (void 0 !== o) {
						if ("morphTargetInfluences" === r) {
							if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
							if (!t.geometry.isBufferGeometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.", this);
							if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
							void 0 !== t.morphTargetDictionary[o] && (o = t.morphTargetDictionary[o])
						}
						h = this.BindingType.ArrayElement, this.resolvedProperty = l, this.propertyIndex = o
					} else void 0 !== l.fromArray && void 0 !== l.toArray ? (h = this.BindingType.HasFromToArray, this.resolvedProperty = l) : Array.isArray(l) ? (h = this.BindingType.EntireArray, this.resolvedProperty = l) : this.propertyName = r;
					this.getValue = this.GetterByBindingType[h], this.setValue = this.SetterByBindingTypeAndVersioning[h][c]
				}
				unbind() {
					this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
				}
			}
			qc.Composite = class {
				constructor(t, path, e) {
					const n = e || qc.parseTrackName(path);
					this._targetGroup = t, this._bindings = t.subscribe_(path, n)
				}
				getValue(t, e) {
					this.bind();
					const n = this._targetGroup.nCachedObjects_,
						r = this._bindings[n];
					void 0 !== r && r.getValue(t, e)
				}
				setValue(t, e) {
					const n = this._bindings;
					for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i) n[i].setValue(t, e)
				}
				bind() {
					const t = this._bindings;
					for (let i = this._targetGroup.nCachedObjects_, e = t.length; i !== e; ++i) t[i].bind()
				}
				unbind() {
					const t = this._bindings;
					for (let i = this._targetGroup.nCachedObjects_, e = t.length; i !== e; ++i) t[i].unbind()
				}
			}, qc.prototype.BindingType = {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			}, qc.prototype.Versioning = {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			}, qc.prototype.GetterByBindingType = [qc.prototype._getValue_direct, qc.prototype._getValue_array, qc.prototype._getValue_arrayElement, qc.prototype._getValue_toArray], qc.prototype.SetterByBindingTypeAndVersioning = [
				[qc.prototype._setValue_direct, qc.prototype._setValue_direct_setNeedsUpdate, qc.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
				[qc.prototype._setValue_array, qc.prototype._setValue_array_setNeedsUpdate, qc.prototype._setValue_array_setMatrixWorldNeedsUpdate],
				[qc.prototype._setValue_arrayElement, qc.prototype._setValue_arrayElement_setNeedsUpdate, qc.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
				[qc.prototype._setValue_fromArray, qc.prototype._setValue_fromArray_setNeedsUpdate, qc.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
			];
			class Jc {
				constructor(t, e, n = null, r = e.blendMode) {
					this._mixer = t, this._clip = e, this._localRoot = n, this.blendMode = r;
					const o = e.tracks,
						l = o.length,
						c = new Array(l),
						h = {
							endingStart: lt,
							endingEnd: lt
						};
					for (let i = 0; i !== l; ++i) {
						const t = o[i].createInterpolant(null);
						c[i] = t, t.settings = h
					}
					this._interpolantSettings = h, this._interpolants = c, this._propertyBindings = new Array(l), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
				}
				play() {
					return this._mixer._activateAction(this), this
				}
				stop() {
					return this._mixer._deactivateAction(this), this.reset()
				}
				reset() {
					return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
				}
				isRunning() {
					return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
				}
				isScheduled() {
					return this._mixer._isActiveAction(this)
				}
				startAt(time) {
					return this._startTime = time, this
				}
				setLoop(t, e) {
					return this.loop = t, this.repetitions = e, this
				}
				setEffectiveWeight(t) {
					return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
				}
				getEffectiveWeight() {
					return this._effectiveWeight
				}
				fadeIn(t) {
					return this._scheduleFading(t, 0, 1)
				}
				fadeOut(t) {
					return this._scheduleFading(t, 1, 0)
				}
				crossFadeFrom(t, e, n) {
					if (t.fadeOut(e), this.fadeIn(e), n) {
						const n = this._clip.duration,
							r = t._clip.duration,
							o = r / n,
							l = n / r;
						t.warp(1, o, e), this.warp(l, 1, e)
					}
					return this
				}
				crossFadeTo(t, e, n) {
					return t.crossFadeFrom(this, e, n)
				}
				stopFading() {
					const t = this._weightInterpolant;
					return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
				}
				setEffectiveTimeScale(t) {
					return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
				}
				getEffectiveTimeScale() {
					return this._effectiveTimeScale
				}
				setDuration(t) {
					return this.timeScale = this._clip.duration / t, this.stopWarping()
				}
				syncWith(t) {
					return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
				}
				halt(t) {
					return this.warp(this._effectiveTimeScale, 0, t)
				}
				warp(t, e, n) {
					const r = this._mixer,
						o = r.time,
						l = this.timeScale;
					let c = this._timeScaleInterpolant;
					null === c && (c = r._lendControlInterpolant(), this._timeScaleInterpolant = c);
					const h = c.parameterPositions,
						d = c.sampleValues;
					return h[0] = o, h[1] = o + n, d[0] = t / l, d[1] = e / l, this
				}
				stopWarping() {
					const t = this._timeScaleInterpolant;
					return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
				}
				getMixer() {
					return this._mixer
				}
				getClip() {
					return this._clip
				}
				getRoot() {
					return this._localRoot || this._mixer._root
				}
				_update(time, t, e, n) {
					if (!this.enabled) return void this._updateWeight(time);
					const r = this._startTime;
					if (null !== r) {
						const n = (time - r) * e;
						if (n < 0 || 0 === e) return;
						this._startTime = null, t = e * n
					}
					t *= this._updateTimeScale(time);
					const o = this._updateTime(t),
						l = this._updateWeight(time);
					if (l > 0) {
						const t = this._interpolants,
							e = this._propertyBindings;
						switch (this.blendMode) {
							case 2501:
								for (let n = 0, r = t.length; n !== r; ++n) t[n].evaluate(o), e[n].accumulateAdditive(l);
								break;
							case ut:
							default:
								for (let r = 0, c = t.length; r !== c; ++r) t[r].evaluate(o), e[r].accumulate(n, l)
						}
					}
				}
				_updateWeight(time) {
					let t = 0;
					if (this.enabled) {
						t = this.weight;
						const e = this._weightInterpolant;
						if (null !== e) {
							const n = e.evaluate(time)[0];
							t *= n, time > e.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
						}
					}
					return this._effectiveWeight = t, t
				}
				_updateTimeScale(time) {
					let t = 0;
					if (!this.paused) {
						t = this.timeScale;
						const e = this._timeScaleInterpolant;
						if (null !== e) {
							t *= e.evaluate(time)[0], time > e.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.paused = !0 : this.timeScale = t)
						}
					}
					return this._effectiveTimeScale = t, t
				}
				_updateTime(t) {
					const e = this._clip.duration,
						n = this.loop;
					let time = this.time + t,
						r = this._loopCount;
					const o = 2202 === n;
					if (0 === t) return -1 === r ? time : o && 1 == (1 & r) ? e - time : time;
					if (2200 === n) {
						-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1));
						t: {
							if (time >= e) time = e;
							else {
								if (!(time < 0)) {
									this.time = time;
									break t
								}
								time = 0
							}
							this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
							this.time = time,
							this._mixer.dispatchEvent({
								type: "finished",
								action: this,
								direction: t < 0 ? -1 : 1
							})
						}
					} else {
						if (-1 === r && (t >= 0 ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), time >= e || time < 0) {
							const n = Math.floor(time / e);
							time -= e * n, r += Math.abs(n);
							const l = this.repetitions - r;
							if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, time = t > 0 ? e : 0, this.time = time, this._mixer.dispatchEvent({
								type: "finished",
								action: this,
								direction: t > 0 ? 1 : -1
							});
							else {
								if (1 === l) {
									const e = t < 0;
									this._setEndings(e, !e, o)
								} else this._setEndings(!1, !1, o);
								this._loopCount = r, this.time = time, this._mixer.dispatchEvent({
									type: "loop",
									action: this,
									loopDelta: n
								})
							}
						} else this.time = time;
						if (o && 1 == (1 & r)) return e - time
					}
					return time
				}
				_setEndings(t, e, n) {
					const r = this._interpolantSettings;
					n ? (r.endingStart = ct, r.endingEnd = ct) : (r.endingStart = t ? this.zeroSlopeAtStart ? ct : lt : ht, r.endingEnd = e ? this.zeroSlopeAtEnd ? ct : lt : ht)
				}
				_scheduleFading(t, e, n) {
					const r = this._mixer,
						o = r.time;
					let l = this._weightInterpolant;
					null === l && (l = r._lendControlInterpolant(), this._weightInterpolant = l);
					const c = l.parameterPositions,
						h = l.sampleValues;
					return c[0] = o, h[0] = e, c[1] = o + t, h[1] = n, this
				}
			}(class extends St {
				constructor(t) {
					super(), this._root = t, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
				}
				_bindAction(t, e) {
					const n = t._localRoot || this._root,
						r = t._clip.tracks,
						o = r.length,
						l = t._propertyBindings,
						c = t._interpolants,
						h = n.uuid,
						d = this._bindingsByRootAndName;
					let f = d[h];
					void 0 === f && (f = {}, d[h] = f);
					for (let i = 0; i !== o; ++i) {
						const track = r[i],
							t = track.name;
						let o = f[t];
						if (void 0 !== o) ++o.referenceCount, l[i] = o;
						else {
							if (o = l[i], void 0 !== o) {
								null === o._cacheIndex && (++o.referenceCount, this._addInactiveBinding(o, h, t));
								continue
							}
							const path = e && e._propertyBindings[i].binding.parsedPath;
							o = new Nc(qc.create(n, t, path), track.ValueTypeName, track.getValueSize()), ++o.referenceCount, this._addInactiveBinding(o, h, t), l[i] = o
						}
						c[i].resultBuffer = o.buffer
					}
				}
				_activateAction(t) {
					if (!this._isActiveAction(t)) {
						if (null === t._cacheIndex) {
							const e = (t._localRoot || this._root).uuid,
								n = t._clip.uuid,
								r = this._actionsByClip[n];
							this._bindAction(t, r && r.knownActions[0]), this._addInactiveAction(t, n, e)
						}
						const e = t._propertyBindings;
						for (let i = 0, t = e.length; i !== t; ++i) {
							const t = e[i];
							0 == t.useCount++ && (this._lendBinding(t), t.saveOriginalState())
						}
						this._lendAction(t)
					}
				}
				_deactivateAction(t) {
					if (this._isActiveAction(t)) {
						const e = t._propertyBindings;
						for (let i = 0, t = e.length; i !== t; ++i) {
							const t = e[i];
							0 == --t.useCount && (t.restoreOriginalState(), this._takeBackBinding(t))
						}
						this._takeBackAction(t)
					}
				}
				_initMemoryManager() {
					this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
					const t = this;
					this.stats = {
						actions: {
							get total() {
								return t._actions.length
							},
							get inUse() {
								return t._nActiveActions
							}
						},
						bindings: {
							get total() {
								return t._bindings.length
							},
							get inUse() {
								return t._nActiveBindings
							}
						},
						controlInterpolants: {
							get total() {
								return t._controlInterpolants.length
							},
							get inUse() {
								return t._nActiveControlInterpolants
							}
						}
					}
				}
				_isActiveAction(t) {
					const e = t._cacheIndex;
					return null !== e && e < this._nActiveActions
				}
				_addInactiveAction(t, e, n) {
					const r = this._actions,
						o = this._actionsByClip;
					let l = o[e];
					if (void 0 === l) l = {
						knownActions: [t],
						actionByRoot: {}
					}, t._byClipCacheIndex = 0, o[e] = l;
					else {
						const e = l.knownActions;
						t._byClipCacheIndex = e.length, e.push(t)
					}
					t._cacheIndex = r.length, r.push(t), l.actionByRoot[n] = t
				}
				_removeInactiveAction(t) {
					const e = this._actions,
						n = e[e.length - 1],
						r = t._cacheIndex;
					n._cacheIndex = r, e[r] = n, e.pop(), t._cacheIndex = null;
					const o = t._clip.uuid,
						l = this._actionsByClip,
						c = l[o],
						h = c.knownActions,
						d = h[h.length - 1],
						f = t._byClipCacheIndex;
					d._byClipCacheIndex = f, h[f] = d, h.pop(), t._byClipCacheIndex = null;
					delete c.actionByRoot[(t._localRoot || this._root).uuid], 0 === h.length && delete l[o], this._removeInactiveBindingsForAction(t)
				}
				_removeInactiveBindingsForAction(t) {
					const e = t._propertyBindings;
					for (let i = 0, t = e.length; i !== t; ++i) {
						const t = e[i];
						0 == --t.referenceCount && this._removeInactiveBinding(t)
					}
				}
				_lendAction(t) {
					const e = this._actions,
						n = t._cacheIndex,
						r = this._nActiveActions++,
						o = e[r];
					t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o
				}
				_takeBackAction(t) {
					const e = this._actions,
						n = t._cacheIndex,
						r = --this._nActiveActions,
						o = e[r];
					t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o
				}
				_addInactiveBinding(t, e, n) {
					const r = this._bindingsByRootAndName,
						o = this._bindings;
					let l = r[e];
					void 0 === l && (l = {}, r[e] = l), l[n] = t, t._cacheIndex = o.length, o.push(t)
				}
				_removeInactiveBinding(t) {
					const e = this._bindings,
						n = t.binding,
						r = n.rootNode.uuid,
						o = n.path,
						l = this._bindingsByRootAndName,
						c = l[r],
						h = e[e.length - 1],
						d = t._cacheIndex;
					h._cacheIndex = d, e[d] = h, e.pop(), delete c[o], 0 === Object.keys(c).length && delete l[r]
				}
				_lendBinding(t) {
					const e = this._bindings,
						n = t._cacheIndex,
						r = this._nActiveBindings++,
						o = e[r];
					t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o
				}
				_takeBackBinding(t) {
					const e = this._bindings,
						n = t._cacheIndex,
						r = --this._nActiveBindings,
						o = e[r];
					t._cacheIndex = r, e[r] = t, o._cacheIndex = n, e[n] = o
				}
				_lendControlInterpolant() {
					const t = this._controlInterpolants,
						e = this._nActiveControlInterpolants++;
					let n = t[e];
					return void 0 === n && (n = new Pl(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = e, t[e] = n), n
				}
				_takeBackControlInterpolant(t) {
					const e = this._controlInterpolants,
						n = t.__cacheIndex,
						r = --this._nActiveControlInterpolants,
						o = e[r];
					t.__cacheIndex = r, e[r] = t, o.__cacheIndex = n, e[n] = o
				}
				clipAction(t, e, n) {
					const r = e || this._root,
						o = r.uuid;
					let l = "string" == typeof t ? Gl.findByName(r, t) : t;
					const c = null !== l ? l.uuid : t,
						h = this._actionsByClip[c];
					let d = null;
					if (void 0 === n && (n = null !== l ? l.blendMode : ut), void 0 !== h) {
						const t = h.actionByRoot[o];
						if (void 0 !== t && t.blendMode === n) return t;
						d = h.knownActions[0], null === l && (l = d._clip)
					}
					if (null === l) return null;
					const f = new Jc(this, l, e, n);
					return this._bindAction(f, d), this._addInactiveAction(f, c, o), f
				}
				existingAction(t, e) {
					const n = e || this._root,
						r = n.uuid,
						o = "string" == typeof t ? Gl.findByName(n, t) : t,
						l = o ? o.uuid : t,
						c = this._actionsByClip[l];
					return void 0 !== c && c.actionByRoot[r] || null
				}
				stopAllAction() {
					const t = this._actions;
					for (let i = this._nActiveActions - 1; i >= 0; --i) t[i].stop();
					return this
				}
				update(t) {
					t *= this.timeScale;
					const e = this._actions,
						n = this._nActiveActions,
						time = this.time += t,
						r = Math.sign(t),
						o = this._accuIndex ^= 1;
					for (let i = 0; i !== n; ++i) {
						e[i]._update(time, t, r, o)
					}
					const l = this._bindings,
						c = this._nActiveBindings;
					for (let i = 0; i !== c; ++i) l[i].apply(o);
					return this
				}
				setTime(t) {
					this.time = 0;
					for (let i = 0; i < this._actions.length; i++) this._actions[i].time = 0;
					return this.update(t)
				}
				getRoot() {
					return this._root
				}
				uncacheClip(t) {
					const e = this._actions,
						n = t.uuid,
						r = this._actionsByClip,
						o = r[n];
					if (void 0 !== o) {
						const t = o.knownActions;
						for (let i = 0, n = t.length; i !== n; ++i) {
							const n = t[i];
							this._deactivateAction(n);
							const r = n._cacheIndex,
								o = e[e.length - 1];
							n._cacheIndex = null, n._byClipCacheIndex = null, o._cacheIndex = r, e[r] = o, e.pop(), this._removeInactiveBindingsForAction(n)
						}
						delete r[n]
					}
				}
				uncacheRoot(t) {
					const e = t.uuid,
						n = this._actionsByClip;
					for (const t in n) {
						const r = n[t].actionByRoot[e];
						void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
					}
					const r = this._bindingsByRootAndName[e];
					if (void 0 !== r)
						for (const t in r) {
							const e = r[t];
							e.restoreOriginalState(), this._removeInactiveBinding(e)
						}
				}
				uncacheAction(t, e) {
					const n = this.existingAction(t, e);
					null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
				}
			}).prototype._controlInterpolantsResultBuffer = new Float32Array(1);
			class Kc {
				constructor(t) {
					"string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = arguments[1]), this.value = t
				}
				clone() {
					return new Kc(void 0 === this.value.clone ? this.value : this.value.clone())
				}
			}(class extends ma {
				constructor(t, e, n = 1) {
					super(t, e), this.meshPerAttribute = n
				}
				copy(source) {
					return super.copy(source), this.meshPerAttribute = source.meshPerAttribute, this
				}
				clone(data) {
					const t = super.clone(data);
					return t.meshPerAttribute = this.meshPerAttribute, t
				}
				toJSON(data) {
					const t = super.toJSON(data);
					return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
				}
			}).prototype.isInstancedInterleavedBuffer = !0;
			const Zc = new Nt;
			class $c {
				constructor(t = new Nt(1 / 0, 1 / 0), e = new Nt(-1 / 0, -1 / 0)) {
					this.min = t, this.max = e
				}
				set(t, e) {
					return this.min.copy(t), this.max.copy(e), this
				}
				setFromPoints(t) {
					this.makeEmpty();
					for (let i = 0, e = t.length; i < e; i++) this.expandByPoint(t[i]);
					return this
				}
				setFromCenterAndSize(t, e) {
					const n = Zc.copy(e).multiplyScalar(.5);
					return this.min.copy(t).sub(n), this.max.copy(t).add(n), this
				}
				clone() {
					return (new this.constructor).copy(this)
				}
				copy(t) {
					return this.min.copy(t.min), this.max.copy(t.max), this
				}
				makeEmpty() {
					return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
				}
				isEmpty() {
					return this.max.x < this.min.x || this.max.y < this.min.y
				}
				getCenter(t) {
					return this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
				}
				getSize(t) {
					return this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
				}
				expandByPoint(t) {
					return this.min.min(t), this.max.max(t), this
				}
				expandByVector(t) {
					return this.min.sub(t), this.max.add(t), this
				}
				expandByScalar(t) {
					return this.min.addScalar(-t), this.max.addScalar(t), this
				}
				containsPoint(t) {
					return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
				}
				containsBox(t) {
					return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
				}
				getParameter(t, e) {
					return e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
				}
				intersectsBox(t) {
					return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
				}
				clampPoint(t, e) {
					return e.copy(t).clamp(this.min, this.max)
				}
				distanceToPoint(t) {
					return Zc.copy(t).clamp(this.min, this.max).sub(t).length()
				}
				intersect(t) {
					return this.min.max(t.min), this.max.min(t.max), this
				}
				union(t) {
					return this.min.min(t.min), this.max.max(t.max), this
				}
				translate(t) {
					return this.min.add(t), this.max.add(t), this
				}
				equals(t) {
					return t.min.equals(this.min) && t.max.equals(this.max)
				}
			}
			$c.prototype.isBox2 = !0;
			const eh = new re,
				nh = new Oe,
				ih = new Oe;

			function rh(object) {
				const t = [];
				object && object.isBone && t.push(object);
				for (let i = 0; i < object.children.length; i++) t.push.apply(t, rh(object.children[i]));
				return t
			}
			const sh = new Float32Array(1);
			new Int32Array(sh.buffer);
			yo.create = function(t, e) {
				return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(yo.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
			}, No.prototype.fromPoints = function(t) {
				return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
			}, class extends ao {
				constructor(t = 10, e = 10, n = 4473924, r = 8947848) {
					n = new Qt(n), r = new Qt(r);
					const o = e / 2,
						l = t / e,
						c = t / 2,
						h = [],
						d = [];
					for (let i = 0, t = 0, f = -c; i <= e; i++, f += l) {
						h.push(-c, 0, f, c, 0, f), h.push(f, 0, -c, f, 0, c);
						const e = i === o ? n : r;
						e.toArray(d, t), t += 3, e.toArray(d, t), t += 3, e.toArray(d, t), t += 3, e.toArray(d, t), t += 3
					}
					const f = new On;
					f.setAttribute("position", new En(h, 3)), f.setAttribute("color", new En(d, 3));
					super(f, new Ka({
						vertexColors: !0,
						toneMapped: !1
					})), this.type = "GridHelper"
				}
			}.prototype.setColors = function() {
				console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
			}, class extends ao {
				constructor(object) {
					const t = rh(object),
						e = new On,
						n = [],
						r = [],
						o = new Qt(0, 0, 1),
						l = new Qt(0, 1, 0);
					for (let i = 0; i < t.length; i++) {
						const e = t[i];
						e.parent && e.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(l.r, l.g, l.b))
					}
					e.setAttribute("position", new En(n, 3)), e.setAttribute("color", new En(r, 3));
					super(e, new Ka({
						vertexColors: !0,
						depthTest: !1,
						depthWrite: !1,
						toneMapped: !1,
						transparent: !0
					})), this.type = "SkeletonHelper", this.isSkeletonHelper = !0, this.root = object, this.bones = t, this.matrix = object.matrixWorld, this.matrixAutoUpdate = !1
				}
				updateMatrixWorld(t) {
					const e = this.bones,
						n = this.geometry,
						r = n.getAttribute("position");
					ih.copy(this.root.matrixWorld).invert();
					for (let i = 0, t = 0; i < e.length; i++) {
						const n = e[i];
						n.parent && n.parent.isBone && (nh.multiplyMatrices(ih, n.matrixWorld), eh.setFromMatrixPosition(nh), r.setXYZ(t, eh.x, eh.y, eh.z), nh.multiplyMatrices(ih, n.parent.matrixWorld), eh.setFromMatrixPosition(nh), r.setXYZ(t + 1, eh.x, eh.y, eh.z), t += 2)
					}
					n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(t)
				}
			}.prototype.update = function() {
				console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
			}, Yl.prototype.extractUrlBase = function(t) {
				return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), yc.extractUrlBase(t)
			}, Yl.Handlers = {
				add: function() {
					console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")
				},
				get: function() {
					console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")
				}
			}, $c.prototype.center = function(t) {
				return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
			}, $c.prototype.empty = function() {
				return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
			}, $c.prototype.isIntersectionBox = function(t) {
				return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
			}, $c.prototype.size = function(t) {
				return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
			}, oe.prototype.center = function(t) {
				return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
			}, oe.prototype.empty = function() {
				return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
			}, oe.prototype.isIntersectionBox = function(t) {
				return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
			}, oe.prototype.isIntersectionSphere = function(t) {
				return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
			}, oe.prototype.size = function(t) {
				return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
			}, Te.prototype.empty = function() {
				return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."), this.isEmpty()
			}, xi.prototype.setFromMatrix = function(t) {
				return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."), this.setFromProjectionMatrix(t)
			}, Ut.prototype.flattenToArrayOffset = function(t, e) {
				return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
			}, Ut.prototype.multiplyVector3 = function(t) {
				return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
			}, Ut.prototype.multiplyVector3Array = function() {
				console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
			}, Ut.prototype.applyToBufferAttribute = function(t) {
				return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
			}, Ut.prototype.applyToVector3Array = function() {
				console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
			}, Ut.prototype.getInverse = function(t) {
				return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
			}, Oe.prototype.extractPosition = function(t) {
				return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
			}, Oe.prototype.flattenToArrayOffset = function(t, e) {
				return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
			}, Oe.prototype.getPosition = function() {
				return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), (new re).setFromMatrixColumn(this, 3)
			}, Oe.prototype.setRotationFromQuaternion = function(q) {
				return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(q)
			}, Oe.prototype.multiplyToArray = function() {
				console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
			}, Oe.prototype.multiplyVector3 = function(t) {
				return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
			}, Oe.prototype.multiplyVector4 = function(t) {
				return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
			}, Oe.prototype.multiplyVector3Array = function() {
				console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
			}, Oe.prototype.rotateAxis = function(t) {
				console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
			}, Oe.prototype.crossVector = function(t) {
				return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
			}, Oe.prototype.translate = function() {
				console.error("THREE.Matrix4: .translate() has been removed.")
			}, Oe.prototype.rotateX = function() {
				console.error("THREE.Matrix4: .rotateX() has been removed.")
			}, Oe.prototype.rotateY = function() {
				console.error("THREE.Matrix4: .rotateY() has been removed.")
			}, Oe.prototype.rotateZ = function() {
				console.error("THREE.Matrix4: .rotateZ() has been removed.")
			}, Oe.prototype.rotateByAxis = function() {
				console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
			}, Oe.prototype.applyToBufferAttribute = function(t) {
				return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
			}, Oe.prototype.applyToVector3Array = function() {
				console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
			}, Oe.prototype.makeFrustum = function(t, e, n, r, o, l) {
				return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, r, n, o, l)
			}, Oe.prototype.getInverse = function(t) {
				return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."), this.copy(t).invert()
			}, gi.prototype.isIntersectionLine = function(line) {
				return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(line)
			}, ie.prototype.multiplyVector3 = function(t) {
				return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
			}, ie.prototype.inverse = function() {
				return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."), this.invert()
			}, Be.prototype.isIntersectionBox = function(t) {
				return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
			}, Be.prototype.isIntersectionPlane = function(t) {
				return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
			}, Be.prototype.isIntersectionSphere = function(t) {
				return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
			}, yn.prototype.area = function() {
				return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
			}, yn.prototype.barycoordFromPoint = function(t, e) {
				return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
			}, yn.prototype.midpoint = function(t) {
				return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
			}, yn.prototypenormal = function(t) {
				return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
			}, yn.prototype.plane = function(t) {
				return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
			}, yn.barycoordFromPoint = function(t, a, b, e, n) {
				return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), yn.getBarycoord(t, a, b, e, n)
			}, yn.normal = function(a, b, t, e) {
				return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), yn.getNormal(a, b, t, e)
			}, Uo.prototype.extractAllPoints = function(t) {
				return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
			}, Uo.prototype.extrude = function(t) {
				return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new gl(this, t)
			}, Uo.prototype.makeGeometry = function(t) {
				return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new yl(this, t)
			}, Nt.prototype.fromAttribute = function(t, e, n) {
				return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
			}, Nt.prototype.distanceToManhattan = function(t) {
				return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
			}, Nt.prototype.lengthManhattan = function() {
				return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
			}, re.prototype.setEulerFromRotationMatrix = function() {
				console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
			}, re.prototype.setEulerFromQuaternion = function() {
				console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
			}, re.prototype.getPositionFromMatrix = function(t) {
				return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
			}, re.prototype.getScaleFromMatrix = function(t) {
				return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
			}, re.prototype.getColumnFromMatrix = function(t, e) {
				return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
			}, re.prototype.applyProjection = function(t) {
				return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
			}, re.prototype.fromAttribute = function(t, e, n) {
				return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
			}, re.prototype.distanceToManhattan = function(t) {
				return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
			}, re.prototype.lengthManhattan = function() {
				return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
			}, te.prototype.fromAttribute = function(t, e, n) {
				return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, n)
			}, te.prototype.lengthManhattan = function() {
				return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
			}, on.prototype.getChildByName = function(t) {
				return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
			}, on.prototype.renderDepth = function() {
				console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
			}, on.prototype.translate = function(t, e) {
				return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
			}, on.prototype.getWorldRotation = function() {
				console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
			}, on.prototype.applyMatrix = function(t) {
				return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
			}, Object.defineProperties(on.prototype, {
				eulerOrder: {
					get: function() {
						return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
					},
					set: function(t) {
						console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
					}
				},
				useQuaternion: {
					get: function() {
						console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
					},
					set: function() {
						console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
					}
				}
			}), $n.prototype.setDrawMode = function() {
				console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
			}, Object.defineProperties($n.prototype, {
				drawMode: {
					get: function() {
						return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."), 0
					},
					set: function() {
						console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")
					}
				}
			}), Ua.prototype.initBones = function() {
				console.error("THREE.SkinnedMesh: initBones() has been removed.")
			}, oi.prototype.setLens = function(t, e) {
				console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
			}, Object.defineProperties($l.prototype, {
				onlyShadow: {
					set: function() {
						console.warn("THREE.Light: .onlyShadow has been removed.")
					}
				},
				shadowCameraFov: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
					}
				},
				shadowCameraLeft: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
					}
				},
				shadowCameraRight: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
					}
				},
				shadowCameraTop: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
					}
				},
				shadowCameraBottom: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
					}
				},
				shadowCameraNear: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
					}
				},
				shadowCameraFar: {
					set: function(t) {
						console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
					}
				},
				shadowCameraVisible: {
					set: function() {
						console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
					}
				},
				shadowBias: {
					set: function(t) {
						console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
					}
				},
				shadowDarkness: {
					set: function() {
						console.warn("THREE.Light: .shadowDarkness has been removed.")
					}
				},
				shadowMapWidth: {
					set: function(t) {
						console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
					}
				},
				shadowMapHeight: {
					set: function(t) {
						console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
					}
				}
			}), Object.defineProperties(Mn.prototype, {
				length: {
					get: function() {
						return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
					}
				},
				dynamic: {
					get: function() {
						return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.usage === At
					},
					set: function() {
						console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."), this.setUsage(At)
					}
				}
			}), Mn.prototype.setDynamic = function(t) {
				return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? At : wt), this
			}, Mn.prototype.copyIndicesArray = function() {
				console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
			}, Mn.prototype.setArray = function() {
				console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
			}, On.prototype.addIndex = function(t) {
				console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
			}, On.prototype.addAttribute = function(t, e) {
				return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."), e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : this.setAttribute(t, e) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.setAttribute(t, new Mn(arguments[1], arguments[2])))
			}, On.prototype.addDrawCall = function(t, e, n) {
				void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
			}, On.prototype.clearDrawCalls = function() {
				console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
			}, On.prototype.computeOffsets = function() {
				console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
			}, On.prototype.removeAttribute = function(t) {
				return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."), this.deleteAttribute(t)
			}, On.prototype.applyMatrix = function(t) {
				return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."), this.applyMatrix4(t)
			}, Object.defineProperties(On.prototype, {
				drawcalls: {
					get: function() {
						return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
					}
				},
				offsets: {
					get: function() {
						return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
					}
				}
			}), ma.prototype.setDynamic = function(t) {
				return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."), this.setUsage(!0 === t ? At : wt), this
			}, ma.prototype.setArray = function() {
				console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")
			}, gl.prototype.getArrays = function() {
				console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")
			}, gl.prototype.addShapeList = function() {
				console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")
			}, gl.prototype.addShape = function() {
				console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")
			}, fa.prototype.dispose = function() {
				console.error("THREE.Scene: .dispose() has been removed.")
			}, Kc.prototype.onUpdate = function() {
				return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
			}, Object.defineProperties(_n.prototype, {
				wrapAround: {
					get: function() {
						console.warn("THREE.Material: .wrapAround has been removed.")
					},
					set: function() {
						console.warn("THREE.Material: .wrapAround has been removed.")
					}
				},
				overdraw: {
					get: function() {
						console.warn("THREE.Material: .overdraw has been removed.")
					},
					set: function() {
						console.warn("THREE.Material: .overdraw has been removed.")
					}
				},
				wrapRGB: {
					get: function() {
						return console.warn("THREE.Material: .wrapRGB has been removed."), new Qt
					}
				},
				shading: {
					get: function() {
						console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
					},
					set: function(t) {
						console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
					}
				},
				stencilMask: {
					get: function() {
						return console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask
					},
					set: function(t) {
						console.warn("THREE." + this.type + ": .stencilMask has been removed. Use .stencilFuncMask instead."), this.stencilFuncMask = t
					}
				},
				vertexTangents: {
					get: function() {
						console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
					},
					set: function() {
						console.warn("THREE." + this.type + ": .vertexTangents has been removed.")
					}
				}
			}), Object.defineProperties(si.prototype, {
				derivatives: {
					get: function() {
						return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
					},
					set: function(t) {
						console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
					}
				}
			}), ua.prototype.clearTarget = function(t, e, n, r) {
				console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, n, r)
			}, ua.prototype.animate = function(t) {
				console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
			}, ua.prototype.getCurrentRenderTarget = function() {
				return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
			}, ua.prototype.getMaxAnisotropy = function() {
				return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
			}, ua.prototype.getPrecision = function() {
				return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
			}, ua.prototype.resetGLState = function() {
				return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
			}, ua.prototype.supportsFloatTextures = function() {
				return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
			}, ua.prototype.supportsHalfFloatTextures = function() {
				return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
			}, ua.prototype.supportsStandardDerivatives = function() {
				return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
			}, ua.prototype.supportsCompressedTextureS3TC = function() {
				return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
			}, ua.prototype.supportsCompressedTexturePVRTC = function() {
				return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
			}, ua.prototype.supportsBlendMinMax = function() {
				return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
			}, ua.prototype.supportsVertexTextures = function() {
				return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
			}, ua.prototype.supportsInstancedArrays = function() {
				return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
			}, ua.prototype.enableScissorTest = function(t) {
				console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
			}, ua.prototype.initMaterial = function() {
				console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
			}, ua.prototype.addPrePlugin = function() {
				console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
			}, ua.prototype.addPostPlugin = function() {
				console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
			}, ua.prototype.updateShadowMap = function() {
				console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
			}, ua.prototype.setFaceCulling = function() {
				console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
			}, ua.prototype.allocTextureUnit = function() {
				console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")
			}, ua.prototype.setTexture = function() {
				console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")
			}, ua.prototype.setTexture2D = function() {
				console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")
			}, ua.prototype.setTextureCube = function() {
				console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")
			}, ua.prototype.getActiveMipMapLevel = function() {
				return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."), this.getActiveMipmapLevel()
			}, Object.defineProperties(ua.prototype, {
				shadowMapEnabled: {
					get: function() {
						return this.shadowMap.enabled
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
					}
				},
				shadowMapType: {
					get: function() {
						return this.shadowMap.type
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
					}
				},
				shadowMapCullFace: {
					get: function() {
						console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
					}
				},
				context: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."), this.getContext()
					}
				},
				vr: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"), this.xr
					}
				},
				gammaInput: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."), !1
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")
					}
				},
				gammaOutput: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), !1
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."), this.outputEncoding = !0 === t ? gt : mt
					}
				},
				toneMappingWhitePoint: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."), 1
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")
					}
				},
				gammaFactor: {
					get: function() {
						return console.warn("THREE.WebGLRenderer: .gammaFactor has been removed."), 2
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")
					}
				}
			}), Object.defineProperties(ta.prototype, {
				cullFace: {
					get: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
					}
				},
				renderReverseSided: {
					get: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
					}
				},
				renderSingleSided: {
					get: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
					},
					set: function() {
						console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
					}
				}
			}), Object.defineProperties(ee.prototype, {
				wrapS: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
					}
				},
				wrapT: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
					}
				},
				magFilter: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
					}
				},
				minFilter: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
					}
				},
				anisotropy: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
					}
				},
				offset: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
					}
				},
				repeat: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
					}
				},
				format: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
					}
				},
				type: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
					}
				},
				generateMipmaps: {
					get: function() {
						return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
					},
					set: function(t) {
						console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
					}
				}
			}), Lc.prototype.load = function(t) {
				console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
				const e = this;
				return (new bc).load(t, (function(t) {
					e.setBuffer(t)
				})), this
			}, Hc.prototype.getData = function() {
				return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
			}, hi.prototype.updateCubeMap = function(t, e) {
				return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
			}, hi.prototype.clear = function(t, e, n, r) {
				return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."), this.renderTarget.clear(t, e, n, r)
			}, Jt.crossOrigin = void 0, Jt.loadTexture = function(t, e, n, r) {
				console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
				const o = new Zl;
				o.setCrossOrigin(this.crossOrigin);
				const l = o.load(t, n, void 0, r);
				return e && (l.mapping = e), l
			}, Jt.loadTextureCube = function(t, e, n, r) {
				console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
				const o = new Kl;
				o.setCrossOrigin(this.crossOrigin);
				const l = o.load(t, n, void 0, r);
				return e && (l.mapping = e), l
			}, Jt.loadCompressedTexture = function() {
				console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
			}, Jt.loadCompressedTextureCube = function() {
				console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
			};
			"undefined" != typeof __THREE_DEVTOOLS__ && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
				detail: {
					revision: r
				}
			})), "undefined" != typeof window && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = r)
		},
		215: function(t, e, n) {
			"use strict";
			n.d(e, "a", (function() {
				return Ce
			})), n.d(e, "b", (function() {
				return Me
			})), n.d(e, "c", (function() {
				return He
			})), n.d(e, "d", (function() {
				return we
			})), n.d(e, "e", (function() {
				return ye
			})), n.d(e, "f", (function() {
				return me
			})), n.d(e, "g", (function() {
				return se
			})), n.d(e, "h", (function() {
				return Ae
			})), n.d(e, "i", (function() {
				return xe
			})), n.d(e, "j", (function() {
				return ve
			})), n.d(e, "k", (function() {
				return _e
			})), n.d(e, "l", (function() {
				return re
			})), n.d(e, "m", (function() {
				return Ee
			})), n.d(e, "n", (function() {
				return Fe
			})), n.d(e, "o", (function() {
				return Ie
			})), n.d(e, "p", (function() {
				return be
			})), n.d(e, "q", (function() {
				return Oe
			})), n.d(e, "r", (function() {
				return Le
			})), n.d(e, "s", (function() {
				return Pe
			})), n.d(e, "t", (function() {
				return Be
			}));
			var r = n(212),
				o = 0,
				l = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
				c = (r.Rb, r.Rb, r.Rb, "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=linearToRelativeLuminance(texture2D(inputBuffer,vUv).rgb);float lLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv0).rgb);float lTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=linearToRelativeLuminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=linearToRelativeLuminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=linearToRelativeLuminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=linearToRelativeLuminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}"),
				h = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}",
				d = (r.Rb, r.Rb, [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])]),
				f = {
					VERY_SMALL: 0,
					SMALL: 1,
					MEDIUM: 2,
					LARGE: 3,
					VERY_LARGE: 4,
					HUGE: 5
				},
				m = class extends r.Rb {
					constructor() {
						super({
							type: "CopyMaterial",
							uniforms: {
								inputBuffer: new r.cc(null),
								opacity: new r.cc(1)
							},
							fragmentShader: "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <encodings_fragment>\n}",
							vertexShader: l,
							blending: r.vb,
							depthWrite: !1,
							depthTest: !1
						}), this.toneMapped = !1
					}
				},
				v = (r.Rb, r.Rb, {
					FULL: 0,
					SINGLE: 1
				}),
				y = (r.Rb, r.Rb, r.Rb, {
					DEPTH: 0,
					LUMA: 1,
					COLOR: 2
				}),
				x = (r.Rb, {
					FRAGMENT_HEAD: "FRAGMENT_HEAD",
					FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
					FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
					VERTEX_HEAD: "VERTEX_HEAD",
					VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
				}),
				_ = (r.Rb, r.Rb, r.Rb, {
					DISCARD: 0,
					MULTIPLY: 1,
					MULTIPLY_RGB_SET_ALPHA: 2
				}),
				w = (r.Rb, r.Rb, r.Rb, new r.m),
				A = null;
			var M = class {
					constructor(t = "Pass", e = new r.Qb, n = w) {
						this.name = t, this.scene = e, this.camera = n, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
					}
					get renderToScreen() {
						return !this.rtt
					}
					set renderToScreen(t) {
						if (this.rtt === t) {
							const e = this.getFullscreenMaterial();
							null !== e && (e.needsUpdate = !0), this.rtt = !t
						}
					}
					getFullscreenMaterial() {
						return null !== this.screen ? this.screen.material : null
					}
					setFullscreenMaterial(t) {
						let e = this.screen;
						null !== e ? e.material = t : (e = new r.jb(function() {
							if (null === A) {
								const t = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
									e = new Float32Array([0, 0, 2, 0, 0, 2]);
								void 0 !== (A = new r.l).setAttribute ? (A.setAttribute("position", new r.k(t, 3)), A.setAttribute("uv", new r.k(e, 2))) : (A.addAttribute("position", new r.k(t, 3)), A.addAttribute("uv", new r.k(e, 2)))
							}
							return A
						}(), t), e.frustumCulled = !1, null === this.scene && (this.scene = new r.Qb), this.scene.add(e), this.screen = e)
					}
					getDepthTexture() {
						return null
					}
					setDepthTexture(t, e = 0) {}
					render(t, e, n, r, o) {
						throw new Error("Render method not implemented!")
					}
					setSize(t, e) {}
					initialize(t, e, n) {}
					dispose() {
						const t = this.getFullscreenMaterial();
						null !== t && t.dispose();
						for (const t of Object.keys(this)) {
							const e = this[t];
							if (null !== e && "function" == typeof e.dispose) {
								if (e instanceof r.Qb) continue;
								this[t].dispose()
							}
						}
					}
				},
				S = class extends M {
					constructor() {
						super("ClearMaskPass", null, null), this.needsSwap = !1
					}
					render(t, e, n, r, o) {
						const l = t.state.buffers.stencil;
						l.setLocked(!1), l.setTest(!1)
					}
				},
				T = new r.o,
				E = class extends M {
					constructor(t = !0, e = !0, n = !1) {
						super("ClearPass", null, null), this.needsSwap = !1, this.color = t, this.depth = e, this.stencil = n, this.overrideClearColor = null, this.overrideClearAlpha = -1
					}
					render(t, e, n, r, o) {
						const l = this.overrideClearColor,
							c = this.overrideClearAlpha,
							h = t.getClearAlpha(),
							d = null !== l,
							f = c >= 0;
						d ? (T.copy(t.getClearColor(T)), t.setClearColor(l, f ? c : h)) : f && t.setClearAlpha(c), t.setRenderTarget(this.renderToScreen ? null : e), t.clear(this.color, this.depth, this.stencil), d ? t.setClearColor(T, h) : f && t.setClearAlpha(h)
					}
				},
				C = !1,
				R = class {
					constructor(t = null) {
						this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.setMaterial(t), this.meshCount = 0, this.replaceMaterial = t => {
							if (t.isMesh) {
								let e;
								switch (t.material.side) {
									case r.A:
										e = this.materialsDoubleSide;
										break;
									case r.g:
										e = this.materialsBackSide;
										break;
									default:
										e = this.materials
								}
								this.originalMaterials.set(t, t.material), t.isSkinnedMesh ? t.material = e[2] : t.isInstancedMesh ? t.material = e[1] : t.material = e[0], ++this.meshCount
							}
						}
					}
					setMaterial(t) {
						if (this.disposeMaterials(), this.material = t, null !== t) {
							const e = this.materials = [t.clone(), t.clone(), t.clone()];
							for (const n of e) n.uniforms = Object.assign({}, t.uniforms), n.side = r.F;
							e[2].skinning = !0, this.materialsBackSide = e.map((e => {
								const n = e.clone();
								return n.uniforms = Object.assign({}, t.uniforms), n.side = r.g, n
							})), this.materialsDoubleSide = e.map((e => {
								const n = e.clone();
								return n.uniforms = Object.assign({}, t.uniforms), n.side = r.A, n
							}))
						}
					}
					render(t, e, n) {
						const r = t.shadowMap.enabled;
						if (t.shadowMap.enabled = !1, C) {
							const r = this.originalMaterials;
							this.meshCount = 0, e.traverse(this.replaceMaterial), t.render(e, n);
							for (const t of r) t[0].material = t[1];
							this.meshCount !== r.size && r.clear()
						} else {
							const r = e.overrideMaterial;
							e.overrideMaterial = this.material, t.render(e, n), e.overrideMaterial = r
						}
						t.shadowMap.enabled = r
					}
					disposeMaterials() {
						if (null !== this.material) {
							const t = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide);
							for (const e of t) e.dispose()
						}
					}
					dispose() {
						this.originalMaterials.clear(), this.disposeMaterials()
					}
					static get workaroundEnabled() {
						return C
					}
					static set workaroundEnabled(t) {
						C = t
					}
				},
				D = class extends M {
					constructor(t, e, n = null) {
						super("RenderPass", t, e), this.needsSwap = !1, this.clearPass = new E, this.overrideMaterialManager = null === n ? null : new R(n)
					}
					get renderToScreen() {
						return super.renderToScreen
					}
					set renderToScreen(t) {
						super.renderToScreen = t, this.clearPass.renderToScreen = t
					}
					get overrideMaterial() {
						const t = this.overrideMaterialManager;
						return null !== t ? t.material : null
					}
					set overrideMaterial(t) {
						const e = this.overrideMaterialManager;
						null !== t ? null !== e ? e.setMaterial(t) : this.overrideMaterialManager = new R(t) : null !== e && (e.dispose(), this.overrideMaterialManager = null)
					}
					get clear() {
						return this.clearPass.enabled
					}
					set clear(t) {
						this.clearPass.enabled = t
					}
					getClearPass() {
						return this.clearPass
					}
					render(t, e, n, r, o) {
						const l = this.scene,
							c = this.camera,
							h = l.background,
							d = this.renderToScreen ? null : e;
						this.clear && (null !== this.clearPass.overrideClearColor && (l.background = null), this.clearPass.render(t, e)), t.setRenderTarget(d), null !== this.overrideMaterialManager ? this.overrideMaterialManager.render(t, l, c) : t.render(l, c), l.background !== h && (l.background = h)
					}
				};
			new Float32Array([255 / 256 / 256 ** 3, 255 / 256 / 65536, 255 / 256 / 256]);
			var L = 0,
				P = 2,
				I = 10,
				B = 13,
				O = 14,
				F = 16,
				H = new Map([
					[L, null],
					[1, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x+y,1.0)*opacity+x*(1.0-opacity);}"],
					[P, "vec3 blend(const in vec3 x,const in vec3 y,const in float opacity){return y*opacity+x*(1.0-opacity);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){float a=min(y.a,opacity);return vec4(blend(x.rgb,y.rgb,a),max(x.a,a));}"],
					[3, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y)*0.5*opacity+x*(1.0-opacity);}"],
					[4, "float blend(const in float x,const in float y){return(y==0.0)? y : max(1.0-(1.0-x)/y,0.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
					[5, "float blend(const in float x,const in float y){return(y==1.0)? y : min(x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
					[6, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return min(x,y)*opacity+x*(1.0-opacity);}"],
					[7, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return abs(x-y)*opacity+x*(1.0-opacity);}"],
					[8, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(x+y-2.0*x*y)*opacity+x*(1.0-opacity);}"],
					[9, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x,y)*opacity+x*(1.0-opacity);}"],
					[I, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return x*y*opacity+x*(1.0-opacity);}"],
					[11, "float blend(const in float x,const in float y){return(y>0.0)? min(x/y,1.0): 1.0;}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
					[12, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-abs(1.0-x-y))*opacity+x*(1.0-opacity);}"],
					[B, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y*opacity+x*(1.0-opacity);}"],
					[O, "float blend(const in float x,const in float y){return(x<0.5)?(2.0*x*y):(1.0-2.0*(1.0-x)*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
					[15, "float blend(const in float x,const in float y){return(y==1.0)? y : min(x*x/(1.0-y),1.0);}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
					[F, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return(1.0-(1.0-x)*(1.0-y))*opacity+x*(1.0-opacity);}"],
					[17, "float blend(const in float x,const in float y){return(y<0.5)?(2.0*x*y+x*x*(1.0-2.0*y)):(sqrt(x)*(2.0*y-1.0)+2.0*x*(1.0-y));}vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=vec4(blend(x.r,y.r),blend(x.g,y.g),blend(x.b,y.b),blend(x.a,y.a));return z*opacity+x*(1.0-opacity);}"],
					[18, "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return max(x+y-1.0,0.0)*opacity+x*(1.0-opacity);}"]
				]),
				N = class extends r.C {
					constructor(t, e = 1) {
						super(), this.blendFunction = t, this.opacity = new r.cc(e)
					}
					getBlendFunction() {
						return this.blendFunction
					}
					setBlendFunction(t) {
						this.blendFunction = t, this.dispatchEvent({
							type: "change"
						})
					}
					getShaderCode() {
						return H.get(this.blendFunction)
					}
				},
				U = (r.C, {
					NONE: 0,
					DEPTH: 1,
					CONVOLUTION: 2
				});
			var z = class extends M {
					constructor(t, e) {
						super("MaskPass", t, e), this.needsSwap = !1, this.clearPass = new E(!1, !1, !0), this.inverse = !1
					}
					get clear() {
						return this.clearPass.enabled
					}
					set clear(t) {
						this.clearPass.enabled = t
					}
					render(t, e, n, r, o) {
						const l = t.getContext(),
							c = t.state.buffers,
							h = this.scene,
							d = this.camera,
							f = this.clearPass,
							m = this.inverse ? 0 : 1,
							v = 1 - m;
						c.color.setMask(!1), c.depth.setMask(!1), c.color.setLocked(!0), c.depth.setLocked(!0), c.stencil.setTest(!0), c.stencil.setOp(l.REPLACE, l.REPLACE, l.REPLACE), c.stencil.setFunc(l.ALWAYS, m, 4294967295), c.stencil.setClear(v), c.stencil.setLocked(!0), this.clear && (this.renderToScreen ? f.render(t, null) : (f.render(t, e), f.render(t, n))), this.renderToScreen ? (t.setRenderTarget(null), t.render(h, d)) : (t.setRenderTarget(e), t.render(h, d), t.setRenderTarget(n), t.render(h, d)), c.color.setLocked(!1), c.depth.setLocked(!1), c.stencil.setLocked(!1), c.stencil.setFunc(l.EQUAL, 1, 4294967295), c.stencil.setOp(l.KEEP, l.KEEP, l.KEEP), c.stencil.setLocked(!0)
					}
				},
				k = class extends M {
					constructor(t, input = "inputBuffer") {
						super("ShaderPass"), this.setFullscreenMaterial(t), this.uniform = null, this.setInput(input)
					}
					setInput(input) {
						const t = this.getFullscreenMaterial();
						if (this.uniform = null, null !== t) {
							const e = t.uniforms;
							void 0 !== e && void 0 !== e[input] && (this.uniform = e[input])
						}
					}
					render(t, e, n, r, o) {
						null !== this.uniform && null !== e && (this.uniform.value = e.texture), t.setRenderTarget(this.renderToScreen ? null : n), t.render(this.scene, this.camera)
					}
					initialize(t, e, n) {
						if (void 0 !== n && n !== r.ec) {
							this.getFullscreenMaterial().defines.FRAMEBUFFER_PRECISION_HIGH = "1"
						}
					}
				};
			Set;
			r.v;
			new r.ic, new r.ib;

			function G(t, e, data) {
				const canvas = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
					n = canvas.getContext("2d");
				if (canvas.width = t, canvas.height = e, data instanceof Image) n.drawImage(data, 0, 0);
				else {
					const r = n.createImageData(t, e);
					r.data.set(data), n.putImageData(r, 0, 0)
				}
				return canvas
			}
			var V = class {
					constructor(t = 0, e = 0, data = null) {
						this.width = t, this.height = e, this.data = data
					}
					toCanvas() {
						return "undefined" == typeof document ? null : G(this.width, this.height, this.data)
					}
					static from(image) {
						const {
							width: t,
							height: e
						} = image;
						let data;
						if (image instanceof Image) {
							const canvas = G(t, e, image);
							if (null !== canvas) {
								data = canvas.getContext("2d").getImageData(0, 0, t, e).data
							}
						} else data = image.data;
						return new V(t, e, data)
					}
				},
				W = "lut.scaleup",
				j = new r.o,
				X = class extends r.w {
					constructor(data, t) {
						super(data, t, t, t), this.type = r.E, this.format = r.Mb, this.encoding = r.W, this.minFilter = r.X, this.magFilter = r.X, this.wrapS = r.n, this.wrapT = r.n, this.wrapR = r.n, this.unpackAlignment = 1, this.domainMin = new r.ic(0, 0, 0), this.domainMax = new r.ic(1, 1, 1)
					}
					get isLookupTexture3D() {
						return !0
					}
					scaleUp(t, e = !0) {
						const image = this.image;
						let n;
						if (t <= image.width) n = Promise.reject(new Error("The target size must be greater than the current size"));
						else {
							const r = URL.createObjectURL(new Blob(['(()=>{var q={SCALE_UP:"lut.scaleup"};var _=[new Float32Array(3),new Float32Array(3)],t=[new Float32Array(3),new Float32Array(3),new Float32Array(3),new Float32Array(3)],U=[[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([1,0,0]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([1,0,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([1,1,0]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,1,0]),new Float32Array([0,1,1]),new Float32Array([1,1,1])],[new Float32Array([0,0,0]),new Float32Array([0,0,1]),new Float32Array([0,1,1]),new Float32Array([1,1,1])]];function L(a,n,r,m){let h=r[0]-n[0],e=r[1]-n[1],s=r[2]-n[2],l=a[0]-n[0],w=a[1]-n[1],c=a[2]-n[2],y=e*c-s*w,A=s*l-h*c,g=h*w-e*l,p=Math.sqrt(y*y+A*A+g*g),V=p*.5,F=y/p,f=A/p,i=g/p,u=-(a[0]*F+a[1]*f+a[2]*i),M=m[0]*F+m[1]*f+m[2]*i;return Math.abs(M+u)*V/3}function X(a,n,r,m,h,e){let s=(r+m*n+h*n*n)*3;e[0]=a[s+0],e[1]=a[s+1],e[2]=a[s+2]}function k(a,n,r,m,h,e){let s=r*(n-1),l=m*(n-1),w=h*(n-1),c=Math.floor(s),y=Math.floor(l),A=Math.floor(w),g=Math.ceil(s),p=Math.ceil(l),V=Math.ceil(w),F=s-c,f=l-y,i=w-A;if(c===s&&y===l&&A===w)X(a,n,s,l,w,e);else{let u;F>=f&&f>=i?u=U[0]:F>=i&&i>=f?u=U[1]:i>=F&&F>=f?u=U[2]:f>=F&&F>=i?u=U[3]:f>=i&&i>=F?u=U[4]:i>=f&&f>=F&&(u=U[5]);let[M,x,P,T]=u,d=_[0];d[0]=F,d[1]=f,d[2]=i;let o=_[1],Y=g-c,Z=p-y,b=V-A;o[0]=Y*M[0]+c,o[1]=Z*M[1]+y,o[2]=b*M[2]+A,X(a,n,o[0],o[1],o[2],t[0]),o[0]=Y*x[0]+c,o[1]=Z*x[1]+y,o[2]=b*x[2]+A,X(a,n,o[0],o[1],o[2],t[1]),o[0]=Y*P[0]+c,o[1]=Z*P[1]+y,o[2]=b*P[2]+A,X(a,n,o[0],o[1],o[2],t[2]),o[0]=Y*T[0]+c,o[1]=Z*T[1]+y,o[2]=b*T[2]+A,X(a,n,o[0],o[1],o[2],t[3]);let v=L(x,P,T,d)*6,S=L(M,P,T,d)*6,C=L(M,x,T,d)*6,E=L(M,x,P,d)*6;t[0][0]*=v,t[0][1]*=v,t[0][2]*=v,t[1][0]*=S,t[1][1]*=S,t[1][2]*=S,t[2][0]*=C,t[2][1]*=C,t[2][2]*=C,t[3][0]*=E,t[3][1]*=E,t[3][2]*=E,e[0]=t[0][0]+t[1][0]+t[2][0]+t[3][0],e[1]=t[0][1]+t[1][1]+t[2][1]+t[3][1],e[2]=t[0][2]+t[1][2]+t[2][2]+t[3][2]}}var O=class{static expand(n,r){let m=Math.cbrt(n.length/3),h=new Float32Array(3),e=new n.constructor(r**3*3),s=1/(r-1);for(let l=0;l<r;++l)for(let w=0;w<r;++w)for(let c=0;c<r;++c){let y=c*s,A=w*s,g=l*s,p=Math.round(c+w*r+l*r*r)*3;k(n,m,y,A,g,h),e[p+0]=h[0],e[p+1]=h[1],e[p+2]=h[2]}return e}};self.addEventListener("message",a=>{let n=a.data,r=n.data;switch(n.operation){case q.SCALE_UP:r=O.expand(r,n.size);break}postMessage(r,[r.buffer]),close()});})();\n'], {
									type: "text/javascript"
								})),
								o = new Worker(r);
							n = new Promise(((n, l) => {
								o.addEventListener("error", (t => l(t.error))), o.addEventListener("message", (e => {
									const o = new X(e.data, t);
									o.encoding = this.encoding, o.type = this.type, o.name = this.name, URL.revokeObjectURL(r), n(o)
								}));
								const c = e ? [image.data.buffer] : [];
								o.postMessage({
									operation: W,
									data: image.data,
									size: t
								}, c)
							}))
						}
						return n
					}
					applyLUT(t) {
						const e = this.image,
							n = t.image,
							o = Math.min(e.width, e.height, e.depth);
						if (o !== Math.min(n.width, n.height, n.depth)) console.error("Size mismatch");
						else if (t.type !== r.E || this.type !== r.E) console.error("Both LUTs must be FloatType textures");
						else if (t.format !== r.Mb || this.format !== r.Mb) console.error("Both LUTs must be RGB textures");
						else {
							const t = e.data,
								r = n.data,
								l = o,
								s = l - 1;
							for (let i = 0, e = l ** 3; i < e; ++i) {
								const e = 3 * i,
									n = t[e + 0] * s,
									g = t[e + 1] * s,
									b = t[e + 2] * s,
									o = 3 * Math.round(n + g * l + b * l * l);
								t[e + 0] = r[o + 0], t[e + 1] = r[o + 1], t[e + 2] = r[o + 2]
							}
							this.needsUpdate = !0
						}
						return this
					}
					convertToUint8() {
						if (this.type === r.E) {
							const t = this.image.data,
								e = new Uint8ClampedArray(t.length);
							for (let i = 0, n = t.length; i < n; ++i) e[i] = 255 * t[i];
							this.image.data = e, this.type = r.ec, this.needsUpdate = !0
						}
						return this
					}
					convertToFloat() {
						if (this.type === r.ec) {
							const t = this.image.data,
								e = new Float32Array(t.length);
							for (let i = 0, n = t.length; i < n; ++i) e[i] = t[i] / 255;
							this.image.data = e, this.type = r.E, this.needsUpdate = !0
						}
						return this
					}
					convertLinearToSRGB() {
						const data = this.image.data;
						if (this.type === r.E) {
							const t = this.format === r.Lb ? 4 : 3;
							for (let i = 0, e = data.length; i < e; i += t) j.fromArray(data, i).convertLinearToSRGB().toArray(data, i);
							this.encoding = r.pc, this.needsUpdate = !0
						} else console.error("Color space conversion requires FloatType data");
						return this
					}
					convertSRGBToLinear() {
						const data = this.image.data;
						if (this.type === r.E) {
							const t = this.format === r.Lb ? 4 : 3;
							for (let i = 0, e = data.length; i < e; i += t) j.fromArray(data, i).convertSRGBToLinear().toArray(data, i);
							this.encoding = r.W, this.needsUpdate = !0
						} else console.error("Color space conversion requires FloatType data");
						return this
					}
					convertToRGBA() {
						if (this.format === r.Mb) {
							const t = this.image.width,
								e = this.image.data,
								n = new e.constructor(t ** 3 * 4),
								o = this.type === r.E ? 1 : 255;
							for (let i = 0, t = 0, r = e.length; i < r; i += 3, t += 4) n[t + 0] = e[i + 0], n[t + 1] = e[i + 1], n[t + 2] = e[i + 2], n[t + 3] = o;
							this.image.data = n, this.format = r.Lb, this.needsUpdate = !0
						}
						return this
					}
					toDataTexture() {
						const t = this.image.width,
							e = this.image.height * this.image.depth,
							n = new r.v(this.image.data, t, e);
						return n.name = this.name, n.type = this.type, n.format = this.format, n.encoding = this.encoding, n.minFilter = r.X, n.magFilter = r.X, n.wrapS = this.wrapS, n.wrapT = this.wrapT, n.generateMipmaps = !1, n
					}
					static from(t) {
						const image = t.image,
							{
								width: e,
								height: n
							} = image,
							r = Math.min(e, n);
						let data;
						if (image instanceof Image) {
							data = V.from(image).data;
							const t = new Uint8Array(r ** 3 * 3);
							if (e > n)
								for (let e = 0; e < r; ++e)
									for (let n = 0; n < r; ++n)
										for (let o = 0; o < r; ++o) {
											const l = 4 * (o + e * r + n * r * r),
												c = 3 * (o + n * r + e * r * r);
											t[c + 0] = data[l + 0], t[c + 1] = data[l + 1], t[c + 2] = data[l + 2]
										} else
											for (let i = 0, e = r ** 3; i < e; ++i) {
												const e = 4 * i,
													n = 3 * i;
												t[n + 0] = data[e + 0], t[n + 1] = data[e + 1], t[n + 2] = data[e + 2]
											}
							data = t
						} else data = image.data.slice();
						const o = new X(data, r);
						return o.type = t.type, o.encoding = t.encoding, o.name = t.name, o
					}
					static createNeutral(t) {
						const data = new Float32Array(t ** 3 * 3),
							s = 1 / (t - 1);
						for (let e = 0; e < t; ++e)
							for (let g = 0; g < t; ++g)
								for (let b = 0; b < t; ++b) {
									const n = 3 * (e + g * t + b * t * t);
									data[n + 0] = e * s, data[n + 1] = g * s, data[n + 2] = b * s
								}
						const e = new X(data, t);
						return e.name = "neutral", e
					}
				},
				Y = (Math.PI, new r.ic, new r.ic, "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC"),
				Q = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAKAAAAIwCAYAAAABNmBHAAAgAElEQVR4Xuy9CbhlV1ktOvbpq09DkiIkUBI6kxASIH0DlAQiIK1wRfSJTx+i4JX7vKIigs8HXpXvqVcvrcC9agQ7IDTSSWgqCQQliDRBJKkkhDSkqVPNqVOnP+8b//rH3P+eZ+199tlznVTlvVrft7+1T7OaueZY42/m37QALKNk2wHg1pITlB17mC+Pp11W3X/LHyT32vhg48/5SOv+PnwpsHA70JoGlueB1iKApeqzvOzn44GatTB76Xzhd7suBR7+WWADgDEAwwCG/L54b/poDLrHuvvm70Z2Avhsc+PVcxscBU8F8C8ADg5+ipIjD/PlGwfgju8B924E5seARUfLsiNmqQW0IjL8+7L2NYD/7COBzfcCm+aB8SVgdAkYIRCXKyDax4EdAanL5PuNPllNvXDlAHwFgP8AcC2AhRIoDXbsYb48dl5WkVFTE3LGDcC9m4CZCWBuFFgeAZaGAYJQQCRqDHT+McJrVb8zwATUXH02MHYfMHEIGFsAxgjApQqACYQORjtd/B7Axt/z79sC0+cMPgjjlwPwVwHcA+DfAHzTxcVgWBroqMN8+cYBeM71wH0TwKExYHYUWCIAHYRLTlkCYgcIBcAgU/n3qy8GRu4HRgnAOWBkERhddPAJhGJDBxkvw7cqimr+zFM/ZLnZF64cgL8BYD+AWwB8x/dlWuWagHiYL984AJ/0RWBy1AE4AizyM1yxYAcTigW55xMbAkxEiwEdkJ/ZCQxPAiOHgBECcKEC4TBZcKkSv+mTieNcNPNC26mLNsj45QD8LQDTAO4GcJt/7iw2bfoG4WG+vAGwm9ExiEg69zpg/wgwPQLMjgALzn4E4aIzoJjQ9g4024uygkj+pyuAoX0VAIfngOH5NgCHMhAm8Sv2y3XDZeBhNIp8OzJE8OsBzAKYBHAXgDt8/4O+MVT0j4f58o0D8Pxrgf3DwMwIMEPQEYRkNwfgsuuDZLskip0No0gWMD/9HGDoADAkAC4Aw/wsAgZAgs2Z0ABI0GU6IVmKv+f28KDnHxkA/G0A8y6G73N9kOCjXnh/Ebb6OvgwX75xAF5wLTA1VIHPADgMLDj4yIA5AAm6aCUnv4oz46eeDwxNAUMzwJAz4BABSNDFTwSfg7DDKHE23MG5PqIY8A1u/dINs9dBdy8AgnGPM2NfUBrsnw7z5RsH4IXXAAcJviFgluAbygBINnSLWOAjGxJ4pgOKDV0v/OSLKp8iGXBovhLBBOCQM2ACoTOhnYrAdItYbCij5JFzRyIAqRccAnDAQUjg6UNQ7hsMXP0cRQAexss3DsCLCECCLwCQzMcPwUi2MwAScAKbfnY/YRLFQ8DHX+IAJAMSfDkAF13kLvleIjhjQQHxUVS3jjgGpKeeNzYVQEjgUS8k+PghONdhIwAP4+XXBYCHKIJbwJyDTgaIAdCBJx3Q2M8tYAHP9m4df/ylQOsQ0JqtRLCx30K1wtLBggScQOgsKBGcWHAJeOwRC0BSM1mQIKRbhh+Bj98JQP6t4U0APEyXXxcAEnxkQAFwoVUxID9kvQg+c1C7vidRbIDkc24B//hTQGumDcCWA5DgMxASdNIFBUI5pCML8v8API5zfEQx4BudgqiczviSnJhQwCP4BMCGl+wO8+U7AJi/W4O4YS6+pmK/2ciADsAOBhTIIiAJnPB7AvNjP+0AnANaYkAHX2JBAc+tYaJXOqBZv24Vc386XW5dtkHGW+4HFAJonpOe+YYQZAShgKjv3PNvPQaxVoI8zJdfFwASfPzMUwS3Kt1v0UFIlos6oDFdAGFcliMAP/ryAEAGNwQRnDOgLbdlIEwrIs6AZ/QgkMMHQF6ZAKQcJAsSYPwIeAIk9wJgoPK1gi7+PwF4GC/fOAAvIQPSs0URTPBJ/Pp3GSEGRHfBCIQ0xowBtUbcAj7ys5X4Jfu1HIAGQrIgQRXEsAFQIORDFhiDY/rMHmrU4QUgR08AkgUjCAW6CD6CkwBsAIQC4GG6fPMA3OXiNzCg2I9gNCMksmAAoemDzoimFwL48M85AKkiuQVMAAp8CYRRDAt8GQiJ67N6GJODAXAHlsGguscA2AJg1IPGYmxOpBxFWkRN9LsATgIwXnNs/v/5z/9XCf8BO3YAtxbc/46/KDt+5+ea1Yku2VUxHz/z0v24FwMGK1gWsK2OUUxHHdCBeRUB6OxHABr4ZICIBd0QWSF+XRdMTAjgCdTrG9cBNwE4F8CpDkICyYLGsuhFt6zs+gISwUen8zEAjgMw4cfx2H6O/90yAFo84Cbg4ID3/9TfLTt+5+ebnRABkODjx0SwPi5ec/FrYpmqSAxM8Dn60CsqAFI6GfhqAMiDE/gokmvEr0C4PgDkBQm40wE8zMFEUDKEVoxIMLl/KS73mE7H9d+vcKHQQcjwW0Yu9nP8m8sAmOIBuWY6wP2/4s0ezjjg8TuvaR6ABJ70vxUApGrm7EbGE+i472BAB+WHfqHS/eoAaEwY2E9+wLSXTqhI7CXgnB6LCoOJ4BiST+hTnG0HcCwAglCx3ARoZEVFXnBPp/O/A/hXACc7CPs9/i1lAOyIB+RDX+P9/+pbQjjjAMfv/PL6AFDs1wFAgs/9fgKfgdE/ZEpuiQlbwAde6QAMBgiRmsSwA9BY0JfjovGRDBMH4TlcXGhcBOc6HkF0gjPhZgchxTLZMAci/04W/B6Ab3t09EPXcPyflgFwRTwgJ2MN9/8bf5qFM67x+B/aW4XQz42FeL0YrRyikztUFw0704mf9kXgxhOAqc3AAsPyRxxQCs/PdXOFY0W1KHy3QIUGtx+6vdnx1vsB+dsTncm2AogglFgVEAlUWrOMB2RyEmMCGQ/Y7/HvKns6tfGAnJQ+r/9b76oJZ1zD8WdyQjYBh8aBhVEHjELouQ8ukQ7VRSCJAALwkr+sALhnGzDD3JAJYJHg9uhoi4bx8ytkWUtvHT/7+Zc4dw1uZ3612fH2dkQf7yxIEEockwkJQn4IQoq8unhAhmPRKKFx0uv4K8ueTs94wD7u//VX9ghn7OP4c+4G7h8HpseB+dF2AKlFLwuAIZ8jD6NPrOhAffmfA9/ZBuzZCkyRWSeqBCWyoYGQ5yQrBpDbum/ME1HoPo0XEkSD2zlfbna8q6+EUJcTCxKEtHL5EQjP6BEPyIgYAZBvYt3xHyx7OqvGA65y/7/9wVXCGVc5/sl7qxD66dEqiYgRzAqhN1A4CBNAAlDyAFI+iZ9/N3DLJuC+jcDUBmCWyUnOrmTYCMIOkNclLg0B8/RsNLg9+UvNjnd1APLmmQpFHyEBROuWACQT8nN+H/GAvY7/VNnT6SsesMf13/CpahGnZzhjj+PPmwX2MYdDIfQexWyBAwEUOQDrRDN/98p3A7dvAO6fAA5sqHJDBEAyoUVGkwEd6HR12XU4kwzfl6fCXTZzjy57vvnR513X7Hj7AyDvggAUi9EyFgiZqNxPQF6345nOWbD1HQ/Y5fpvuLa/2+82/vNHgAPDFQDnhoF5j2C2qBWCI8bw1eRw5CL5l94L3DEOTI4DB8Y9OWmsEu/zBJ3rgsaybqBob/7A4C7jtWcooRrczr+u2fH2D0AOQgAUCxKEP7aGgLy64+m6KdjWFA9Yc/03/Osa4glrjr+AupqHz1sEs0cxG0BC9HIePLoit9eNkVf9L+DuUWByDJgaq4ybGYLPAWgiXmLedUE7dwC7saL7CqfPKXi4NYdaykCD410bAHlDEsNiwZ9wAPYbkJcfz6T2gm3N8YDZ9d/wHxUA+739fPwXPrSKYGb+BuP3jAFDElFH9HIWwbzCIGkBr/or4J4RYO8oMOW6ZVcAuvi1Cgoha04BCwT5gfMKHm7NoRde2+x41w5A3hQZkADk5+cGiAeMx3+/7AENFA8Yrv/G71cAXFM4Yzj+otOAaQLQA0gZxaIIZtMDFTigKJV8H9Iq6aZ59ZXAvSPAvpEKgBTtBODcSCWCZeRYtpzrmLyeGNCAyFl1v+Hei8qeb370Rdc2O97BAMi7EgB/2QG41nhAHU9LuWAbOB7Qr//GPRUA13r7Gv9FZwIMoVcEswEwfDoimEP0shKKtIphaZQAXv1+YM+wA3DEdcvRKkGJADQQEsQuhi1Tjt95vBsh5nx2IO59SsHDrTmUOStNjndwAAqEry0IyCMICkOyiuIBNwBvPFQQT7gBuPjc9oRYAIHyOEL4vIFEYVNaOou5vCGE/tV/A0wOVcnpzI47NOri3QFIBpSeaSDUdYLOSWvYImSGgftpJDa4MWJbAGxivGUA5MAOc0Be6eVLj7/4Mk+hzCOYPYpZDBiNkLh+G/M3yFyv/ltgL3W3YQfgcFUhgRY2PwY+Z7/EhAR1SFyXCOb57r28QfQBsJQBMn5D4y0HYLPje9Cd7RIC0PM3EiMofF4gVCBp1P840ix/gyz56r+vAMjk9Gl375iB4+CzveuZdLkkEPJ8ZEfX/6R73vOjzT5Si9hucLxHAVg4PwJgRwh9CKOXK8YA4ZEqKZXSQWh5P+5AftXfA/uGKvYjCKn72cctbFrZNECka5L5CPwIPtMH3TVz17MLB5gdLgA2Nd6jACycHwLQxFEUSR5ASvARDB0h9AQb9bXIgCGk6lUfAPYTgEPAITKgg1BObk58srTJgG58WMkWMaAbQQT1nc8rHGANAJsc71EAFs4PAagQestgC1lsBJ4BMCSOK6dDUcwqqaFiQr/0QeAAAdjy+jBiQQeeMSBZT3nCPUDIa9z+/MIB1gCwyfEeBWDh/BCAeQSzgkjFfGLBBD5nxQ4DxN0wv3hVxX5TBGDwL5obxvVA5YqYL5BeMLd66YYxJpRB0gK+96LCAdYAsMnxHgVg4fwIgMrhUPKQ2C+Bz0PmBTqBMQehAbDlIjj4F80KJguSVZ0FuXpjoCOgXawLjALhbT9eOMAuAGxqvEcBWDg/l1IE05Ed0ygZnyHdz0VwCqEPIfNyx0QQvvLDFQCp+8nfZk5und8tXwIgWcHSNX0N2CJmnAl3v6RwgNnhl17T7HiPArBwfghAS7mV/hey2JS9FvM3BLpUUi1YwDRMXvkRYJoAlAh2l0dcZ04s6JUTDIjyBcrl4yDc/dLCAdYAsMnxHgVg4fxwKVwJgGEJNmWtxpQMpX9on2eRhVA+O56AjMfnP+e3Xvf3NwG4xIPTleiY55bpGh6UbafNU0l0z0p+5Jh5HqYJ6b51nP6XP8cx12XNHQVgIQB/bFPVg2OC7Q+WgVFWng/FvtWLI06uWh5oguKEcXVS/9sEAF//VGD7t4ETDgJbF4CNi8CGZWBs2fPL/H6Vwp2KEtVk4fJ+v/EIYPN9wKa5qu+IncfPwXHVZe/aOL3EbwS7xv8A1rQvnO0j8PArTgTGZ4BxFv9mIxhOCGsv+0OPYDRghcLfkWkEuq0+G00x4OtfDGz+d2DbHmDLjL8si8AYP/7CGIAiEEMTG92zXqSbH+d9R2aA0XnvO+JjthiIrOVDHHPOkBrzUQAWAPsZp3oPDpa/Xag6EVkLBK+5rAnJC3/nYk/APD704WiEAV8OTHwX2LQH2DgFbJgFNrBhjd8r79deGoEwsllgNBOzy8CdjweG9wBj08AIAci2D6HafmyAk4/Z7SJ72hGYRwFYAMDLTwOGp4FRFgD3HhzqRGQiyeurqOdG6r0Rm8IEZjzRlkiqCWoEgK8Axm4BJu4HJhyAbFhDxmbDGnZO4j0SgLGDkpibgEq66TJw/1nA0F5gdLpq+zDqFfd5LMeWqu5HNST0uJOIllg+qgMWgI+HPv0xwLA3gWHpW2sC441gCECbmKziaGrnUdMO4aHeh6MxAP4SMHI7ML4HGD8AjHvHJGNAgpDgY/ck3stipRemvVhc+uASMPUEYGh/9dIRgGx8Y+MNbR/00uVtH0wEx94j/v0oAxaA8Ed+GBieAYZZg5kADC0QWGOFzGJlcGPzl1BxNLXD8sk4xftwNAbA/wwM3wGMUmxOOQBnHXzetIYvibonmSiuYTNjriVg7glAiwBk0fNZH6+PmX9P6kfNmCXGpftJ7TgKwBIAnln14BAAYxMYm5C6RjCyCoOyr0qkD/c+HI0B8DXA8N3AyCQwesD1VQKH7EcASm1Q+y4CkN9pUKiVF5nLvy+fBbTUd8QBaH1HvNBROiZvfsNnrF4kcvPwpdsBLBeU18Nf7AB23Dp4ecHC8oBgUlJJecLS+7+WOpE3gbE+HKw+yoevCYkMGKqPJrdEKARutaFYRs1fiEZ0wP8CDN8LDO8FRqYq3W10pgKgfYLaYCzootgA6KXaTA90y374TKB1sBozy77xHFZ536utRgAmEaw6g5kUSFZwSXnA330qsOlfgHMPDlZesLA8IOjoLypPWHj/11EnCiVwkz7kAExtsGraYUWdSDX5TmsagL8KDBGA7Bd30JsW0oWivnEOQNP7yGTSBR101AlZSUtGyfgZDkCWY1HnJdcBVe6325hTvelg2CQjZNDygG/2An0j1wKnL6y9vGBheUC8prQ8YeH9X39OVQSc7Mc6fCaKvAeHdCIVf4yMYCynTpX+nb97NJmlSQb8r8DQHm9YOFUZTKOzoXGhs6AxF0HIexcLBvWBuiHN8s2ne98R3qc6L4Vyb2oBVjfm9MIFHbjDCh6kPOBbQoG+oW8CO5bWVl6wsDwgfr20PGHh/X/1iaEIuDcCTIW/1Q4rFv8OnYiW3c+W2iKwUjKbyjQNwL1uuR6sAEgDgq1brXOmV81PxhNB6DUDBSYzQJwFtz623XcktX1Q1VWKaTF/zZhVazBVYA1tX5MazsGvobwe/jQr0Ne6BTh5uf/ygoXlAfG60vKEhff/rSe1i4DnTWDUACY1guFTDqLYdCBvf6DJYSMYATBfOx1kLfj1v1axH10nQ3Sd0GUkBnTfpemtBJgseIKQAHLQcVxa2TnuMW0Aqui5es8xBIegVdVVE8VhzHnLh65WMB9An+X18K6aAn2tO4ETl6vqbKuVFywsDwhevqg8YeH93/Rk70JE90nowxZbIJjvS3WYNSGUwGHJTpPxwwcbBuBrgRYBeKACn7VtpdUu/c0NJxO9BIxcKu4TTODzbkonPLoaL0vyUQRb2y8HsL1ckfWzMeuFi40Qezqi+yiPhyt7FOjr6/gCFwgP7Xb5vssTFt7/nQRg6MGRWmDRoeyTlpgw68GRTwgZgo1gGmXAX6/8dtaylSKY/koyID9BhzML3q1gAos2AcOrZYSoq/pJp1VtODRm9Z3LS/7WjVkvXOzEtOpKyGrlAT+4SoG+VY8vBGCvy/dVnrDw/vee65NBJiAjBIVcAJQjOm+DkCZEeiGAMw6sAwDZsJrAdhFM9rPGhd4904Co5oVuCZPV6kD40Ec6+9W8dBTBsfdc3nkpvnB82fp2RPcs79dHgb51LA9ofsDV6vut5/3PnxcAmLVBiDqgevDaJLkYrpuQxzcNwN8AWgIgRbB8loEBzXDwl4cGiDGft58SCOWGedgjvOJ+bPvgRkiuA+ZjzhnQQOiFNVbloa7l/fos0LdO5QENgEXlCfs8Qbf7HyMA3QVjYihYhLENgjX9y/qwxQmRU/asfd0ZcLU2CHVGyusJQLKfVi98CS12T5f7iECkHpsMkAhCF8+nshWH2I/jXsOYO144GV/9ApAIrS3vt4YCfetQHtAA2G+/4PW4/2PPbzMgmUMi2NoeSCRxIt2/FvuxWURIWCXg357gfTjEDNIHnTRXRCpH5ugKwGl3HpMBXQc0v6WLYVm/5limj04rG762K2uYY9jBkr9+rI03NL5ZbczS/dJ+LQyoga4o77fGAn0NlwdMAOy3vl/T938KAcj121z8Bn+Y9eWQJRz8Y6kNagDh2ey5EvxjxQD8TWdAuneCCO4An1vw5vdzQMmdktwq7pLZQR+dM34+ZumAxvY1Y04uqOAJ6FsExzeto7zfAAX6GiwPaLWR1lrfr8n7f/Rl3QGzmsis+/uO71V9OFgP2gpPhgr7TGRqRUT6dyvr4aIs/pm/2zVUNbBSv6G8e5pEv0Cvec7Po7+bTtjlBRlkvAMBkDeQyvsNWKCvofKACYBrre/X1P0/oWEAnnFD1YdjhtXxR73mX10FfCHHE9pVWcGAI/S0gKsfA2y+twrFZw6Hxf/F0Pk8Ri/kpGSnMuDx5T0iACgQHioo0NdAecBUHW6QdsV2/cL7v/Cyqr5gnc42CCOcfX1VIZ/V8We9IDmTzVXwPDJiXuKXPxtDBma8+lzP4WAgKkPxCUAPE4v5GzEuMX0PYJPLhB6FJsc7MAMmkVxaYC/K9gG+F1++8AQ7Gwbgk78I7GFpXgIwFiRXOwaJZPUbiR0yCUDRk+cHf+YpwMj9HgfI8ClGPyvsSiH0WSKRuYlitLb/zHM/JOSs5C/YIC9cMQDZr/dwxgOW9gtGYUBi0wA8l304vDQvAchilFbpIBQhZ7Ejq6ZQ0/Yhil8y4j89Axie9DAsD6FX9HOK3QtROTFkviN83kG4felIY8DCeLrSeMDSfsEovAECUFsTjHD+tcB+tkFgcXKvBRir7qtFl9owmO4Xy/1G3bAFfPrZHorFNWBFwHjQAFctIghj2kBarw06If/+MM9ZqTN6DgsDojCerjQesLRfMApvoGkAWh8Ob/tgAPSKWCp8ngNQtadjmTdltvNvn3peFYhgQQgh+iUmEaUAUoXM1yRLmWuFLaE9Z+XIAWBhPF1pPGBpv2AU3kDTALzwmqo6qtVh9kJErAudABia38TC5wJgS2xIhAwBn3yhByL4EhzXfRXxYsDTJ4IvrNN2JFMxZcBzVo4cABbG05XGA5b2C0bhDTQNQLZBYH1AVsQSAAU+imI1obHyblnjG/kJk3U8BHz8xVUQAhnQIl5CyNgKAGp5LKSSCoAySh5Jj79vTagcxUaIBeRNe79g9gq+DXig4wGzy+PONfT7RWFA4noAkGXZVAhcBckJQgNgrLiaNb3paIDo1vHHX+oA9LQBi4DxJcOUPJUnTgU2NJUyROs8irGARxQAC+PpCtsFd40H/AEf0gMQkLgeACT41PiGoLOKqyrJq3K/Ya9mNyr5FusN/uPLPIeDa8Bc+w3rtyl4VFHaMZc3i9RWBM9jjzgAFsbTFbYLRmm/YBTeQNMAtD4cBKDXBTQGdAB2MGBo8SCLmEuS1AFVAJ3A/NhPt0PoCcA8bSDG76XI7aySg6JYuGfKwJHFgH0E5B3ueMCe/Y4L+xVHAOZ+9EHcEgQgwbeiEYx6jwTdz4qfu7EhEJqxGqruf/RnHIAEnxgwBM0aC8aUAYWNBRCmoIll4HTqO122QcZbrgMWxtMVtgvuOx6wa7/jwhtoGoDWh4MBJ16WN4lfr8AqI0TVV1O1fa9BbQzovkAy4Ed+NgCQUSxZCFWvCOaOFREXyUwZOPIA2GdA3uGOB6wPaOz+QPv5S+MA3OXiN9aclghW+d3IgupBF2pPqxcxGenDPxfSRh2ASiKKiVP2PaZScvAKoA0VDc6cOlIB2GdA3uGOB1zR77iwX/F6AFB9ONSOQW0frA50sILVcckWJyIDSgwPAVcJgFbYuZ3FJvAlEHbJ3IsgJLGedeBIA+AAAXmHOx6wo99xYb/i9QKg2iAIfDJEJHqj4SExbEty0gkdhB/6P9oZbBZIGiKYVb9GKaN50lRHBLOvhDxh/5EKwDUG5B3ueMB2QGM/grb7/6wHAPNGMAY+GSGUjC52VX2f2CD4+HO0gqkZfegXKgBaHkcWtS0AWii9xG1ImrLlN5XR8L8fmQD05BVrmEENmpYSP9QX+KHiqj2/82+HqqDWwnbBRfGATdzAegGwru2DpRq7Mzq2fpAf0Nq0Rl2wBXzglZ4yUAPAmDSVWDBPHQjLcgTqOZ6zUvdKHh4ruDCerox/Dnu7YqwXAC1NI/QcEQuK6WK/kdgCTGC0PYAP/KIDMBgglq+hIkrOfsaCviLSofcJgJ5AdM7kkSaCj/HqQKVIGvD4swF8bcBjmzjsaQ2H5D/6acBd9wALB4DFWWB5AVherMp4GKIYEOp7+26UF0aSfT/xYuDG7wDjrIpAERytXf2vajj7ueryQXSFl10K/ON3gIWDwCLvjfGB8Z54O+Ee4ve6513uB2R1yzsqC+twbC8HcNVhfAeaBuDP/TvwtS3A/ePAIfYFVlPq2HHTuyulZCTlhbjhETF5yxTQGgPGhoHhIWC4VSXGD3n0tLkMHXHxu+YyB+MlPwDuZs5K6FlsbCzdVO9DuKfkHM8AEkP7B8fOkwDcD+B7np42+JkGOvKdAL4E4K8P0zvQdET0b14D3DgB3D0B7B8HZka9WzrD88N6sFm+YcUjrn7E1ZDvMtF9DBgeAYaHgSGB0PNHCD4BLwLRsByAyX/ij0/dDUxuqlIG5hix7eFhvLcOVUAtyPSydAFmOQNe6EYGV/9ZESiKgIEgtbaD/gHALQC4ovY5r5KwtjOU/XfTAHzzLuCmIeDuMWDvKHBwpMoN0WQzNtAaYSs0K4ZlOSAjGG9kPjCBRwZ0ABKEBJexYAZEAU3A7Oi1BeDym4EDnjQ1TwCGWMW8MXcKks0YOyZNlQOQjcgYIUHllEzYQ0ktm+r6oz8G4F4AXwXwRd8/kO9A0wB8y65KmPxgGJgcqYJTKYpTv2CCzyddQJRDOjKivn+Deh8BF8BnwBtaCUA+YYEyAU8h+c6Az9gNHHRmrgOgmDA3jHQ+iWupCeUAvNSrA9HNwqx+muk9nJVNg/CTfrmbAPwbgK8D+PcHkIibjob5o13A3XypWsAkG1cPA9PDFQDZM1id0i1KxsWfOrKnAFXlifCFFMMRcASigOcs2MGAIfE9iWXplS6On7UbmPaUUTXQrgsVMzcRj5Folg2V5ayUA5BWYKwOxKUafnosWjcJwk+7W5F2EKvlE3xcXaNYfiCYsGkA/smuqug6hcleAnAImPbO6YwRpMgjCAVAm/yQmKTv5hNsAf/i7SyNBSl2a8Qv/4/M1yF+BZSYlNQCnnVrpbC+mToAACAASURBVJcaI7sOSEY2NpaDXLqpR+vE/OVksDgImgGgghHoYJbTWc7oJtFWc65/cg2AYvh2ALsB3AzgVv95nS/f4QdsIkT9T3cBrGtITWZfC5hqtQHInsEGQn3UDDvEDEY/ICf7SxMOrAg8T+c00JGkvHGd2DABUYZIAONzCUDppCFhSukCBsLQrFtZe/IixYQpSyEoJoqnuPWrVRAubQh83HNlZB23z7j1ywmj6CIIqUPxw2Xeu9bx2jx10wz4Z7sqTYZaDD8EIDuoE3hMVEphWg66JIp90k0sBxBcy+iPIIaT1RtEsHS/yIAqw+VSNPWQfe5tlVEk8auXgVa5BUsEJuT5uoliAbE5AGotmIAjCPnR9xDG3TQernYAUupTdBGEFMf83OkApHG+XlvTAPwfuyrgSZOhas3u6cwTsUBVn2gTwyFMi8wjHZAA1M9fYGHDULJD1m8Cpa8fRxDad+l+Ykf/3XNvd11U+qiL39SxXevSsshdDFvgbI1O2AwAtRZMZzTBRuDFjxe1Xg8QEIB8yyj5yYIUxfQIkfkIRnmHCM712JoG4FsdgHHp3ACoMH2G6jM4lWzoQarSvwQ6MSB/vporVaFkh+mCLlpVR8Z+dqDZLoDOpHSiQeAFDkBjPrlgCHgCUaFifg67H/9uYjn4Ai1vpTERTAASBaoQJBAKeNqHlL6mwPDZYAOROag/EYRkPX34MwHIvzW9rQcA+TLpI22G7EcQKlJGsYIJhC6ClUMiXfBTbFUQAej6nPS/OuAl9pOOqIc2BLzg++3VmWgIEUz82cRuCAtLIHQQm0gO52uOAb22sC3JEWgRfPpZf2sQBQIgLydPEIFGwPEj8MlF2bSbsulghLftqsCXq9HGgHysznrGgi5qzTUTFH8FLhAUn3hIJwCN0HLncw37qaF2zoYvuKNivmQIuUNc7GvWt6sHNs26twA6vhyq8NEMAHlyntFrDCcQehyaPTl+FwAbXDcmAKMRThakEk8Q8kPg8SPL0qzLBl+A9QCgR6uZGs3vfHz8TtBZvkgGQrEPBVAUg2Sij50QAOjiVKI3saADJRm7dSLYWfSFDkCem/dhZeMy9pPY5QvSDYQyUJoDIK8qMezh3wY6fSL49PcGgCAA8pScJLIgAUYQEmz8RPA17StvGoBv39W24eREiBoNQSgWNI1HBkdgxJSw1AI+dFIbgOYmkjimQ1r6XXC3rAbCHycAgytohf8vsB/r2KRaRq7zpZ+D37HMX0s3DDcCUGLYaw53MJ4YUODzusqlGCQAOQCejuxA8UULUkxIwAmMAp8Wa3qkN/R9W+sBwOhIEPjk5SLr8HeKFbTQfb77csPIMHGl/4MPbReslPhNe4+MiTpi9AFGV4nI7MfvagNQLh/pfrYnDAS8aJQ42A2w4em2cAyWQUuJVQTGWLs1uL7DG9J1RjhA+jvYk4t3KXeMqijpzrud4At9z3XtP16yGfjKZmCGooYh1tZzvv8xXPFl4PoJYC97k9FlwZWD+Azi/deMZWeP13eQCGEyoERudChIjbb3mJYwH7V0QIKuCwj/gfMj0asn2I0FXRSHXfL/iRkNgLyeVj8ccMY//J1fyxzTAXT2+xoQViKYD/1hDqLxPiYxTgSvQrphphG97tz4Slqafnj7uk1kIQDZrvWTw8B3jwEW+RLxPgSiCERdPwPR7+wCPg/gulFgfruDkOMQkFc5x84e708JAMmCuRNBXi4TIg5CGRzGiBGE/D4E/C2r2vcAYJoify62i0aJSMhB+2IHoNwu0fkcjQ85pu3ack5nIBREqneYFyWLkAXIJHESe00Cyx5QyeL6F/tyEcDcrOW2n7fX8df0mME+/vQ/PQjhoy3gzo3AISYf80MQaQx1peH9wb7v2mrtmCBkIMMejp3jIJD1MsaxaMZ8v5N/67INAsB3BAYU4JL4DSo1J15AFPAEwuQHZJzkKfUAtOHLJSOQRWndBYQvCQA01cfnNopfsaCJaD2baBn79QjSTiOEP1EcawIpkq2kegBTNgHWEpOKF8Uwq2NRFPM4AqCf46/rA2U9/uVDvurB01zvAJpiiwOl3fEeciCGF+Ij11f+QkbSfMPfIzqw57mEFZ9Dl3Ps5HXWAYByHJAJKV7N+s0cCQQhwSlfm4lGZ0KB8C/rABgZUS6ZHITBSEhCowUYAAksF7cStWREyxRwtuPpOlgw+5s9sq6OaIJIIlUgEhA1edoTgHxa9HVw5jibZNF+j/9yGQA/7pbujZ4bwv2+cWB6tFo0NzYnkxFA+cvEAo43VBoEo2e+48EMXEOmD9F6xhCE8RwZEJ80VblKvDlmzwicfqy93/o+8K8TwB2jVSgW138FrJQTXBNlnJgmrjZwanow9CBP/rL9wF0jwAGWDtFyoN9PHutnIHT05mPXz93dMGQAPniJsjiBXiTbxDZFMF9NLUPQxKR5qezz1Y6/YZDH0D6GkdAkYJIvRalAdHAMmPZoYhb6NhDWvEyf/ma737CXN7R1ZC7hUbPgcFgqt/ZZjADnM1xqEVhYBpb4CUk5UsL7jQvj///5buDrLeCOEeD+YQchYwG9VIfyg1NaZszFiCH6DkRGLze5/dgk8IMWcMCjdCiCzR8od1B8OTwvJM8JEShFut1fzMhi+eRJr6LI7hYP2M/xVLwKNoZjUTwRMAQQmYyhWGQxsSADOflZ4kukj7PhZ75bETjBpkAGahMkcrGgwhsXeCyBHBj1wmOBQwvAwqKzoFeRV8ZaerjKYAuirmPY/o9X7q5Cyr7fAvYMAftCPGAEoYlBiVtFwLjtp2U4irj7yOANbi+crHyrfCbTquJV44O0F1FrwQGIMZFqdQDyP/gGSZ8TC0ZRRsOlVzzgasd/u+zpMByLehAfCgMQCDyGZJHFCCgLZ2f8mgI5qauEcVx9e5vACTgCTwEMWr5TdIpWKJb5MvrnoocDswvAPAG4VLGg6UKeqmi4iuDz4er30oX0FP7u5moMvIf7W8B+jwlUNAzFnlZCIhvGFRCeWzrgXSSIBreXTFZSgVLHAp4UHOFuociEEsn2PJwl/XEk0dzfSojeerFg1IOo5BKAveIBex1P67lgUzgWQaJwLAKRH04i14ItgDKEtGsRnWx49b2Vkk9wUefTGrKCF7R0JxZMqxN8cmPAxWcAcxGABKEAKPA5u9lEaAbCmKMI+sDN1X3z+ro24wEZFc0VEE64ABgT180PF9ZdBcDb6JpqcPtPk+1ACbmKjJnllwyuILunEAWjZHkBsrsRUnfD0qEiC5IJfyisgMhzWhcP2O14Ro4WbASgAMQJ48SJwchmBCDFa8qpyBbSP7OvU4PQ0p2W7+LSnSJUFOrI4V7w5IoBTQQTfJ6oTSYk2mQcpGRyH2syGjIF6EM3V/fM++C1CfwUExhCsmzCaQT43lZC3e1hBpEHh36XEqrB7Scmq5dV0XZxmV8WuDFzAF9iwhow9seAGoBcGtKjqAc+1l9rLb/1igesO55ysmCrC8ei6IxRMAKTWNBi6Xw98xNTFUi0jEcmpYgRAPhddpVi9OIEPP5cYD4CcLkCooHPwaW9kV+iwWrQHT8uA1fd3F7DFvgUHUP2k8jTiogAqLoxFpDgbMj9jXSuN7i9dLIdaxzBp5XVBMIMgFEnFAPKT9qPd6A9BIGI7MfPmf4U+40HzI8nWgq2PBxL4FEkjKJixGRRFyQQPzzd1iAUzCAQas1YOmAEoFjwkecDC/PAwhKw6CxIkCXwOdVJLxTobMjBdyIgfvimNvNJ7Evf4jWtdnRYD1YNGVuG93VWuWs4Jf+mlZCCZxwP/cnJ6mXVKk2+tK8lQQVHRTGc64SDAZB3Ey3JcxyACkToJx4wHl+YwqloGDICmYmTFgMQFBET8yyYzyAG/AfWX8mCGQg0BTRoHwt9KVaPE/HQ890AIfgWK+CRAaMRYnVdxHbhdY8Wslw1V93UDsmPIj9GxgiAioRRMIJNvoti+SW/Ikd0gwAU8+XxJcbGITJPDvI6XdCFREFSknTB83xka40H1PGF9dnycCxFwygkK0bASJQSVAbAYeD98xUAe5U3jKIwBosSgNsuABYogl3/IwgFPrOIg1Xc4ZrpAsSrvruykl2ucykapkMMh4CExD5DwJfWAYAxwk4MKPAJgOIjGSEGwuCakRhemw6Yv0UUwRf7L00L9pnsNx6Qx4feY4O8pDEcixOjsoTKKpMYjSFYYjOC8Eq3Wnnr0YYS+0Tmi2HysrPGLqwASNYzBnT2Mz2QD91laxLB0gs12GAh81cf/o/OcHyJ+qj0S/zxnhUZbSyYWaL8+Rq2S29wowiWkJPan4MvgrDDGAlRe7KIywDIgR3meEDWg9HbJgApNTkXo8o0i7oVgxnEgFr8F7jEdnU5GvqfJQKQKyEOPlsNIQvyvupAGHS/Okv4qv9oh+PHxMLk8ggBCRxvAmEN+AiEzz2iQfQBeNmkh4K52hJBKOaNe/FSLobLRXCz43rQnu2yi9oMSMDxs2jo8303ERz1wsCGZECF4kd3DwEYYwJjhoNlQrgIjlYodbBPrwMAZfEmyzcIv27gs6XDzC/IR1DOgA9a6DRz4wZAsZ+LYXvQYsHoD4ziOFklna6YD3+nnU6dZ7bGDAcBUImIAmEUw/zbJ1i/scGNDJiLXmle3RhQ+l/aq57gUQCWzwwBKPeLsZ/LFrGg/ShRXAe64Ajkv30kALAjF8R11Dy3K7KRwJcsUTaqWScARou3w/INVnCH+A36n8RvM3nB5XP4oD6DATBYwGb5ajlOLOh6X8JaBKRG77+7ygGYp1bn+V25/01AzBnwQ1ypanD7KWfA1QDYC3zJIj7KgOUzc9nFbetX/r+O5biwNhyX5uSEDr5o0xsJwLp8/m4A7GaJUv/j3/5+HQFYJ3oFPPkho/hNeqBcMkcB2BAA6XrxmMBkfFAci/m0JpwzXw0TXvXtzrz+PKc/Ml/ugzM9MDqCAbz/keVjjGcQA/YLvjoguo1mRslRI6RwfsiA5nqhL5D6nscF8gfTdfxpS+/hLzvWfzMQCoB1Fq/8b3VWaPIDZqsRV64DALsZHVHs1gEvsqFAeBSApQC8pHK90Oql4UEAyvCwNeGcBXNLOPMLftgZsI75ouUr9ousp2TEyIJ/sU4AzC1e+WIFshyAHPZREVwItrrD3wGAhibTYBhxVpe/xePyrNBuWaoNp3DgFwC81O+RAepK/a5Lfe51jxr7JwA83nPXYgq1asl0yX5N48+f4VEGLATlK1vAo5YB1gBSRmsM+NFE57lcfPD5pPFWCJImtyvGgGfOAacBYO59zFglgHgPefZsXV6/gPXBYeC0RVgyJNOGYuJjPka9eHWgjL9bWzhWk0/n/wPn+k8bgFNmgYcsVflZnBRmIShtJM/m7JGibGBoOIIez9wKPP4AcNpylfbNlGfdI+9NjBjz8JVzppckZuJ+dBw4aQ44drk6j1LIY9JkPD7P4s2lwVEGLHwJnncscNIh4Nh5YMsSsHm5ndOu1BGFThJ8/K6JrZtoslST2+XHA6ftB05ZAE5crgAups5TfaL6EF+UyIif3gAcOwtsXep82eIYY9JkXpMgMp/AeZQBC2b8OduBYw8C2+aALQvARgJwGZhY7swEzbNa88IRvAVO1qkF91J36DNOBE7eD2yfB45fqphLnevzdGeBKBfL8UX5/CZgyyyweRHYsFwxYHzRNK6oetSBMDLjUQAWTPqPngpsnQK2zgKbCMAlYMMSME4ALrcnR6JYQIwsoUnjpDRstOLy7cBJB4CHUGwuAtuW2nUDVH1EFUhycSwWjGD64mZg0xywcaECoI0z5P3X5P6nWlHdgHgUgAUAfOYOYMtBYNMssHEe2LgITBCADkIzSJZXpCOnIg25uPrhgnupO/TyhwLHHwSOmwW2LVSik2pCrDsQskzNIBGIpBdGI+VfNgMb5oENCxX4yPRjPj4xaJ0+WGeEHRXBDUz2Mx4FbDoIbJypADixUAFwzAFI8KUJChMV2SUaAGc1cE/xFJef3FYRti64nkqWDrqqEhbrsm5zvZCdPCd8nHzJOLZuABRz9hTHZwPL7LnLnoNMIY2VyaKcjtZLHOAbNgNPngKe4BacfGF1pnydD+hphQ/8XV5UiEueLGnDN1tWXj/3/4cTwAUzwGPcRcFJiDpPt3FLmf5vjwE2HAQ2zPrEzDv7OQg5OSM+ScYQy5Xbo8465u/ZfLTJ7fKHAdumKxVh8wKwealSE6inEoSy2MWCdbUHIghv3AqMzwHji9VLZuDzD8cXxxWZs5c7apmW0fMBnIHKn5X7d6I5npvRz94O7LgXuGIReJSb+Xl1tzqflybwRwqf9i97BQRWomWJQ7oZVFtJoqDX/b/oGODsvcBTATB9gsfGqmzdjtVz+G+PAyamgYmZCoDjFE2anCVg1CeJwOMnTRB/DmUINVkkgia3y08BtkwDW+YqAFJFMD1VAAw6XG61R31O9/fdrcDYPDDmY0zjc1UjivBuAMx1QdMB+WAYXU8dhEU16dOSkppbcHFSrng8MHwnsGMPcN5ypURHp2xMIa7zDz2z8Gn/kVe0YomO0wEwBYKujL7v/zHA6C3AxfOVh58g5AsZxx4fZM7sf3h6BcDxWWeGBZ+cMEFiwGEHHRnDzun7ONHs/djkRgBunql0VDOSHIDU3cxSD4aEajhFXS4H4S1bgVGN0V8we7E0Fh9jVDG6Obr1LJMRwn+kOCaTEYT0dsfqZHXl/p7PrLi9wIY7gO0H2yAgCAWCWCowKrYE8nMLn/a7PQn9X7zIJPPkCcK+758y7x7guNsB6l98gZjLLYet3Ay5n0sv4R+fCYxPA2MOwLEAQLIDPyP8uBg2cRYmzFweAYilKkn+OC8/Fdh0CNhEA4nGA40kd6FES13WLO8v1qHKAfh9B+DoYjU2Ak/js/8NAIwg7OUb7LCC+WAfB4CpBJoIiTRNRmS1l13kqWh3Adv2A8cdqqp1MB+aIOSxWv6pq5D2kkIAvt8rF7BLJksN/jMqfa7v+7/Ak4B3A6ceqpasKMq5akAmlLWY37t8ZW97PDB2qALg2BxgAFwANEGcnI5JcrDZRPlkaXL4u1KJUAfAjbTQ59x6dSvdLPXAgGYshZWR6JIRaXB/NwFI8C1WwLMXzMeSwLfcXuKrA2G+wrLCDcN/IIg4ERRn0qvyySAQX6mG1XuA4fuAbTOVwktRRr2MLCoQyvEZ/UY/WwjAj3jtFJZkU79g1ghkgEBf98+0Umb/3A2M3lkBl/fOcdMok2EjkZyv8773LAfgHDDKjwNwxEUw9yailpwdxBAEYhBbAuGzG3aKkQEJwAkCkOCjlb7Y6SYyf2UwlAS+vKYnAXjfNmDEX7DEfA5CjUcsnzvbu1nDtUMmCDkRZEEyGdlAk6G6lQTSa6m0MP6HuY73AxNTlcJLZ6WOJYC5/CNxLpHMgdKIKNl69Qvu6/75AjHOiTU87gKOOViJb748BKCWrnK/maTA+58AjM0Ao7PA6Lx/xBAupoYDC9okBRAmPdBZ47lNA/DhwMRsxX7mPgl+SrmK5EaRNRslXFQ9CKB9DkADn79cZtkHFkysJ103eBbqlh97DpmTQTYgk9VNxu+xYbXKU3lhFoJPOgdFGY+lPkgQxokkgF9Xgj4AvfoFs84eX4Ke9x9fIC+tRfDxvvniif358sSir2LCj5wNjBKAc8CIi2AxxLCzIAGY9L7AhGIKgpATw4l8wToB0JjPrfTkp+SLQbHrOqm5jNyajS6VCMIpApDAWwQ4LrGgXqzIfnq5cv0vN0ZXHTInME5GBNLb1DGdOYQsI7AfGKFjlgqve8wJwG4T+fuFAFytXzCLb+VgWnH/fIGYfc46Hs7iHC8ZkPcdXx4VfVXJw8+cA4wIgM6AHSLKWZCTESfLfg7WsIyRF3ckiRQ+HACXkwHptyP4KHrpJvKVGnOhRF9eBF9wE0mUEogz2wC+WGI/vVxiQQIxAs9+rmHA6E1YFYB8DJwQMZl0OrLZ++i7sfT8zroYHLS9df4RACWKxSZvLXzG/fQLZqk2gqn2/vUCUQ9UZaM9wDaPeSPrC4A5C1KV+NITKwCS/SiCR/jRBDlLmP7nHynsxno1IPwJSyRpbiMADXzuPDYfZfBTEoAmcuVQdiaW0zwXwQsCYDYmMaDA1wG8TBSvaoR0G77EcGSET6hjOvVApfRPAUN0zjr45JzVcSqiTxD+VeGzXku/4Nr7JwDJOkxFIwt6j6+RqUrlkO4bXzp1gCAAv04AzgLDDsBhKugLFUvQUhTwCEKbnKCw14HwJ9cDgGQ9WegRgDI8XEcVEDvAl7lVlglAgi+I4CR+Zf1mLGgMmDFhBGFfDCicRJFERviSABjLS7FC0MFKMU+07wOPE0kGvaoQgGvtF9z1/iODkwn3VWoEXxres5ib9xx1wZufBAwLgAQexbAD0JiQwJOuJBA68/H3Zhk6+3CifqqwWNMKN8wjKgbk6gWJgC+FMaBb5vJVmsUbV2vCqo3cRWZcCIACoax53+ulkqNd7iqOcU1WcC9cxEm5kQBUdZ+sTnSL/jEtTWngi21jhJNJBivZBukXvOL+yYBkcOqxKjJ4AGgxzMrBVwdAMmHrZOAYF2l6y/mwV6xD17zmWo6MbRyeWtOHwxJ91IIhr6rqZS70DPPLXDVUrfBwzHKr1EUp6/h0T/6L/GcCqslt4IhoTcwdAqDSs7I60WQH6R329pHuFyuXDJmEjuOSbdB+wSvuP5bGUjmsA5XoUvcvBXKKAQnApUdXwah0b8jXR2YzJTsC0ZHB33FL+2yiX3h/1YeD1fFZGT81g/H6yqkVa9YEpqMhTADle8erHA6t7Mh6j4ZBXdBGjFyO4CSIm9wGBiBvgqxwIAJQlXIyEJLyI/i0SkAG/FbhaEr6BXfcv+5dLKhCg4z1C1HEBJ8+BODQGZXfk/quAZC6ketAZEQCTWAU8PIJt0fgwHzZvVWNaKqi7JLOmtDWFy42g1FxH/XfqGkII0C+a0tnDkfsGxQjn3VPsk7tXmuy+Xp0JhtoJosAaFcUAJUYKiYJxcqHqKAH9rPlG2cMrmCUbMX9guMLpGTcCMKDlZGhMK8IPnPIn1X5PA2AwegwEEYmDGBMjOI5whGQP3NPBT7VJlRNaKvF4t2IWHbDErtDlSk1p4lJ7/zd246tglGZryIfrFhQ7pU8WCAX0ZENG+57U14Z4YrCeLrSxXdev6TfLwrbxT7znMrfKQXfHLQCnyvmRIv0Q3430ezMmL98P393G3wqz6am1NYzzoGn+svqRmTAU2citctqAX/2EI8F9ACEmLHXLZGoFxtSl2xyK2bAYwrj6Xr12+1noL/jUTCD9vvFrn6u0v1/nvGkaoVBAQi0eummMAuXQHMWJAA7gCixG8U0gFfcXdlBKk4Z6zELgAJfZEKrxpC1xOIl/+Sk7jkcdYlSco90y9+gK6vJrRiADD0piad7RuFo3udNCgft94vCdrGXn+tujgV3QAcHLcFnroelivHkchEL8ue0uQ74S3eubAITS3IQhKkMRjBMokgWG3L//2z3VSnP4VDgQWxUEEUxAZFHL0eR3HDfm3IRbDHkBfF0zy4EIKNhSvr9goGEBdvTz/MIYQLQdVsTwRTFDj5jQmdArRDYJQNDSs961R3tPhx5NXoVgoxleHnarjohgLec3D2HI492yQNvIwvqO9fJm9zKGbAwnu6FhaP5pFuMg/b7tTbpBdvTz68cz/zI8azVj8iAHTqgmFHXDUB89R2dtaC7tUGw4kDOgFb0R2wYRDGZ8g9O8aU4XwPOczhiwGlMjqqLWiFYGu570wADFsbTvaxg8nkow7E8nM/atfKzln6/1mS4YHv6BQ4+Z0BbqHcd0NwwYbVD3+1yWhXJxPBrbq8AqE/XApSqAxiBV2MZ/54DMOZwKE00rnDUWcR5KiV/brjtSAMALIyn+/mCyeehjIYp6fdrvVELth8RAClyHXxmhPi6r1m8FM0ucgk8+y4RHC1kAK/5XgW+2hZYofafWcPq1B5AqDqEYsQ3nepR2gqhV2yiol1COkD0C+aOaoGx4aL7DQCwMJ7uVwomn4fm7VrX2u/XAlELth+5sHPtN+l/Ap6sX2dCsZ/phZkIJgv9l++1wbcq+2WFv2NXIjNKAPzuw7MUAV8DTuynFIEsQy83RgTAhiv+NgBABaQOGE/3mwWTLwAqHnaQfr9GnwUbARgDNBUlkpzQboyYCyYDYdILdf0l4NduW9kGoa4geNdazLElKoA3Prx7DofiETtC6XvE7hGEzJlpcis3Qgrj6d5UOJoYDcMglrX2+y0NPtl5UZUjkfx/Hqbecoe0OZzdF1gHQrln9Bhee4s3f3Zxm4MvAk9VSFdUIw0i+Q2PaBtISiBSSFgCYMjMW00MP7pwvvLDmwFgQTzdHxcOSGvBg/b7ZRZByWYAlOERluKM3Ra9CKWc0q73dTBhMFT4ZwIw9l5Lrpes+HjeBiGCUOKXeuBvPcKTiEIOR0f+RhDBMYi0Lhea4GTaa5NbOQAVDzhgPB1La5RssV3rIP1+7yy5OAADoAchEHBkFbKfGRpiweAPtMs5IFNokyOGk/7rAYC9OhBFwNXVY1at5tftCBHaWVS2AJdEcEinrDNC+Lumiyc1B8AB4+muLARAXTDCWvr93lR4/Z0Xt6ODFQkj8WtumEwHTKDLQejAfN3uds/dfjoQdatGLxb8jQBAYz6/boxiFgAVudzNIc2/s3xLk1szAORoB4yn+2DhaATAGJCtbpkCYq9+v4V+aBgAQ4i66XtaC85YkDog/zdZvzUgfN1N7a633Xqv6fe9msDIHfNaB6Ay2JRE1AHAEDIfI5nzZCLeN4Nbm9yaA+CA8XSsul6yqV0rJ2WQfr+splCyCYBR/HJyKX4phs0PKBZ0lqOYTpvniAiUAmAd+HKjo1cvDjHgr+3wPJQsVCymUZrPMuRsRBDG4AQCsunyJtFGHwAAIABJREFUcc0BUJlxQoH62q8ST8cggpKNAFRGwCD9fkuvbwAkyGgJE3C+Nz1P1q9/T3F1EZBxvZh50s6AEYC5yyUHXt5/Q8zI5/KrAmAIkkipkyGPYwXz1aRT8v5ZO6jJrRyAvKOvNXlLazsXs9bo/ztc29Pohgotp5J49Rcj/pzfIwGS//3OM4CNd1dpntQpFUmjEH4LYIgnyn/OLjL8FeDGhwJbNgFjI8DIEDA8BAy1PFK7FSKf43cNKrvHx+8C/vmxwMgmYHgEaA35J0StpvvzL/nP8RbLAfhyT207TChgDRiu/ZL9DsfWNABvYzbhCDBKoBAk/pEobGWTqp819hzQ1/0k0PoaMDEJbJjxVZFgDad0SaUO5LksWVj+XScDmw5UEUDJ6U4d0nVbC91S3ovfVHp5al64cgC+k7mZAP768KCA0WD3A/ieLz090CDceVmlAuhBljLgrfcAw6PAyDAwPFwBkCAbItM4a/FiNtERjBl76W9ffD2AbwJDdwFj+6syImRXrd5Y2FjIYcnzWPLEqnsfC0zsr6qBMQmfIDR/pyJ6xMhKyMrSDiKD2xja6TADTt0/AGAs1KcAUCFrOLF6tbtiRVFavT/wuMCa7MfVTlH098YBeBcwNAIMEYAUlS4uBULOmK3LCnwOPANlEIOSoF9+C4DvVoWXhvdWZVOYqWgi3vOXDUQhgieB0EElViMYJ08HxqeqnG8D4IIDkAzo51DKQQJvBKUmKACzbM4+5hUivwrgiwC4LzvjmgCh6nBcgiMTcv9Abo0D8E6g5eCjfpUA6AxoQIzgi8ALmWwC4z//DxcPPwBak8DQFDB8yJPpPZHeGCyC0KN5DFCByfh9/+OAsekKgEzCTwD047X0SCPM1IYQjCv2E/MJoGVwUUQoPboq0MdqkWVn7RtDDMahB4g+P6qhXFpjVtkDtRGA2nKjos7IyOyHFUbIrXe0FXsTuzIYfNb4O2M3ATGIYQOmPn6hG6gi3eUkQQAeAIYOAUOzALMVh2pAlESqGFBAXAYOMQVjxll03iO/yYKRAT0FQXkwZkjp1pz51LO2XAT3KtD3AIAwj4Wg05kfiuUHYlsXAJLVnP0INLM0OYFx78AzcRySeTsw2AJueI+Dj2Fne4EWKz5MA0MzDkCCkAByUWqsJzarEanzj2zXwjEGFHuGY+pYsMojzZL1G9EBexXou339IRBrC3lJGmNDuSHX+w7WC4Cm6wWxm8DngLTImgC8pBcGBuTXf/1fXnyTugnFwxTQOgi0CECyIFlsvvJfEnh0mhsYI/s5uxFYi1xZof7oOqSAawwYjRGBzYGXbtWXaCIrlvHUagX6SP/ruMVYCEbEqECXAMjfree2HgA0ESur1/0vtnNwGSsG0RsZME20/+/XWH6Mugk/yngPAGy5GDYALjiIHIgRUIrsZjM7Ax+BSx1S4pfffQVIep8dL7dMDsTGjJB+CvQxTHmdtrw4l0CovFruC2NOe975egDQsCXRK/eK634JhBK90q2C7I1i+Gt0jxF40k1cPJAB7UP2m3MGJAAFQrGei9iUTH9yBUDTHfU3B5+BOIKQ43BWtNtPcWIOzEZE8FoK9K0DCGNxLi3FqaKA9gTgeoFwPQAoI0OulWT11oEwiFz7cwbErzNxWtEYBB+VY76Vh4DWrH8IOoGQ7Ocg1CqMRLPltmxvs1/SHaP4dcAJePYyyUCRIzrTB8tE8FoL9DUMwl61kQQ87Rmy2PS2rgB0a1ci18RudEJH57OsY02y/+83/sZdBKr4FXQTApBvprGgQCg9UEAM+h9F6ugJDkC3gJPBEvRGrYoYCBX9IxEcS5K4i6cZAHIw8oXQ4mLBb35YH5d7OekadtTV1UZSjaEIPH4nQzYNwgjAHNwDuWGYpZc7lzPfX1cQur5oBorfzDf+zi0yVTuSkuxBI2Q+PhQDIUEnMLo1TBCZLufGw/ixbQa0KB8CTODjPohdY78IQmfDjmW7Yo/doAX6GqIiAtDHaYswSmeMubV81kp11L6hy2PdAcgblfslOKC1IiKRmyRxZgV/8++DS8BFrxXi5Hd/U6MeSKdqEsEKhpBRsgRMbAtuG4KU/+9ry5brzP/lPVMv1EPOQegharrVcgZUhVHFxNPcp9VFtlOWkL437C0WABWypFRGsV0sb5Hn2zYBwvUGoKl10v1knDgo0y7XA8Pfv0UACnjaK33Co9gJQAOe64FkNvtZAHQdjz9v2Nz2GSa3jYej2W3KGuZ9ixGdIVSoKT13B2s5AHkGheST6qn0erHv5AIgAAU+LVfw/wq3CEAV7clBKDDGZG9/5oVXx/oyYARczcqH5GyH8eFplTawFvAtrtXLGpNrQDGbejupB3omlIHQGc/ErzOcGSRs8zrhAbbuL1Tco/JfbLlNwHOmi2kIcs3owbdwNpYtynDQhsFcgvuG9/YapGFvYX22zZcAU0/GwA2LJ/4AmGF9mwEbBu98Y3cMF+uAGQCj2HVp3BbPuo3IlqxAy5wHAq4OfARmEBXGfNIBa0BIsG0ecwC67merHgRpZLwocrWaovuTxew/V0txJQ2DWeae3WAGbdhb2DB4+wRw7w5g8Qpv88liyGtoWHzMi4C9fAEHbBi8kwUKu2xNAdBxaGBLbJdZux1LwAGECYAEm6wyfpelJrEgFnRDxESwgyUxIUsVMwjVy5AYO0bG89Auu1/5BF38KqjBHlUAYXsteNCGwTeWNuwtk4JMkrlzGNizA1hm69g1Nix+zDOBW0aBeRZZGqBh8M4emfWNADDT+zqMjQyESdQFHfDbZECCLRgdHeCTe8CBaKJY1rDnBRCIAuGW4TYAZeFG8ZuMkGiQ1IEwGCJtHZBmy1obBsvVMnDD3jIAerti3LEBOMjGcOpa3WfD4ic9t6oveDtLfw7QMHjnH6wPAybW6yaG4+8D4HIQfvtDIVtLejpBFsVvUI7NIBHw3DUjRzL3rDVtsYPOkAScuX3coNDynT2VYJCkn+PjqvUD8hVbS8NgjphGxcANe8sAGNoVY/824BCBtIaGxRe8pLKZdpMkTvXiJ2toGHzSNHDPScAyq3er4qPyGaNc7JCRXWLT2TjwGmCOeQashq6+qSpZmp8vojQpheF58ncdZVjLnjWPHr4VWKTKxrHGUqq97qXu3jp0wPy+eEC/DYNZsZAO6IEb9pY9lNCuGPcNV830ZmkM9dmw+OKfbdcXvJMPdY0Ng0/7GnDXKcDMccBS7MwdKz8KCAKQIgY0MWGCtr4TOHAasMwOkTqf6unyuLykfd254nkb7qsw/iVg7jhgmSX31Vpd9yRHeLx+zRhjEGRbB6wDYT8NdymyubzDzCCGfpMJWfSRYfr9HP/aMgBm7YoxNQHMbQHm+ID6aFh8yS93tAvGQb7da2gYfPoXgbtPAqaPA+a3AEubgGU1RM6B060fgkRoCzj+TcD+04CFE4BldZdRc4/YxlxgjJMewSiwN1zWfsOngdljq3EmY08vm5i/7j5yIMqpvupKyGoNg9lngYosl9wY/0dZdrMzYl8Ne8sAWNOu2MA3zw/F2CoNiy99XbvftrcLriz6PhsGn3U9cM9xMODObQYWCMANwPJ49UliuW6SaqqBn/gGYP8pwPyJwNIxwDK76ahDeN6uXYCuYyABkEza4LbpY5WEWdSLxjF26/dQB0SJ6r4ByAN6NQxmkWcqrnQ00x1DEDJFjR8CcNWGvWVPp6ZdMQ6OVOCb3wAscPJ6NCy+7PerkP5Q3tBY1PrT9tEw+JwbgPu2AlNbgVkCcCOwtAFYcgAuiwWlM/XqDjMEbP9t4MB2YO54YJFMo/5gHIcALV1TRZ17FXOhPtvgtvkqf9H4kvHDlyKK4l6VzvVSBF22uwjOb7pbw+CfcwBSkyeFEHAUx/yw9JTyEbo27C17Ol3aFWNuAlgIn9QxO2tYfNlbK6MvaxeMRYquvL9rTcPgJ30TuH8LcHAzMOugX3QALo21WXBZLEHwRF1OgHS2eOgbgIPHA7PHAezNu7QFWFZ7JnXJ5rnqxHEulvlzwyVNN3+wern5Yovl7SXLGwvn4riLWO4fgMRJXcPd/+pmOymELEhRzBxJAo9gVL4kwVnbsLccgHEpWi3epocCAMeBRU5eTcPiy/6qtl0wpvhA+2gYfO7NwOQm4OBGYGaDs+5ExYDGgqP+ccAkINaVpB8GTv4d4OBxwNw2YGFrxYCmV0YxLNYheCXau7EhV3ga3Lb8g4+R45uoGLADgHWqhsBXA8K1AZADyRvuvtkBSArh+i9DsQhCOtf0UUgW/7aiYW/Z0+nRrhizoxXwFhyAi5y4rGHxU66qAFhT3rDSIVdpGHzencDejcDBDcDsBDBP1uX1CMJRwFiQIBzxieL3KIY1YW5MPOxNwLRb8gs0aghAss1GZ1O+SFHsdRPt0i/PLHu++dFb/x4mXfhcbWxhfCtYMFr/uWvKxfDaAcg7ipPCvFOVpuo3HrCjYW/ZA+rRrti6TS6MVQ+L4NPH2nx698GnXF0BsKa8Iab4dFZpGHz+JLBvApieqAA4J8CPOQuOBBAOV0CUYbIskRkAecrvAdNbXc/aDCxSpyT4CEIyTgRgneiLIp3nP6fs+a4A4N8B8/48CUC+ZGJA29fpuLmxJW+5h5kNFg2jiWHSi0r0Uv4pCoZsxw8DUfnhd4Vk0XGdGvaWPaBV2hVjdjgA0BlpkQ/K9bmn/HOVqtClvKEBqlfD4AtmgP3jDsBxB6DA7tdbcvYzJvQJkii2n4NOeMpbgJktbYPGACiF3wFoEx1ZMNe/4jnPLXu+KwD4t/5SO/iMBcXuesHylyACMBPDgzGg7opM8mEHIGdwrfGA1rC37AH10a64Yr4APvvOSdwEPOVbKxu+K2pdKRTmdI3dqkPPVgbSTBGAY8AsATjWniBdx0QxJylOFCcr6HBiw1P/CDgU3EgEIMW52M8YkLolQRddIN1AyKWiBretf9MJQN6HsaCPxe4rvgDdHOcOxDIAcmDFDXvLnk4f7Yqt63gEIB/Yoj+4p9xaAbBHeUPM8qF2aRh84QQwNQYcGgdmx4C50WqCFngNsgSvQ+Dxu4MuiawhwIAXVk1O+e/A7CZgThY1dcno1nHL2oDIyZULpBsAFTBZ9pjT0QQgn2V6ufRicS8QRgbs5ZYpEsENDejBfpoLrwAOjgIzZMBRZ0AHoUC+SOA56xJwNlEyTFw5FxBPeWvlzpnbANCdQ1eSGTRybMuydgMggVBsKmtYoC6Mt8znZxsZMLzAxoAOvsh+ydDqtXx4FIDl8L/omQ7A0QqA82S/ERdTI22mNfaTuBIIxR4BhKe+y61punQC+MytI/Zz/c9EuvyBeetLAfGZ5WOMZ9j2/gqABB1fMLsHAVBqhfTcyH5d9MByEdzs+B50Z7voGZX+NzNSsd8cwUcG5ASRKYbdHRNYwhhDIHRgGmO0gFP+HJh15jOXjnyKblVT5Cbfoq+yJOszF8P8+VnNPlICkMAzds/YLxlYznrJwIpO6egTPMqA5ZNDAB6iCCYAyYBcBqTRQ0e4630SxZyQJQIvMJ8mSeLrYe+p/GzGfnTpEIBy6US/out+K1wg+brs88rHmDOgAVCMnrEfxxMte1Mt6j7u9zzKgIXzczEBOJIB0BnCJoqgIfDEhM58SWzJEPGJe9hfVH42un/Mfxl9bgSiBySIBWnAJBDGEDAB8QWFA8wO3/a+wH4+rg4RLPYLul8tCI8CsJmJMQAOuwFC9qMI9g9Z0CxhZz65K0wfFBPqu7PEyVdWAOTHVlTcpxhXHZLz1w0ZA6EDLhkCskRf0sw4dRYC0PQ/vVSRAYPo7QCdj7GqVOSMeBSAzUzMxZcDMwLgcKX/zbv45SQlHXDIgagJc+bjZBqAWhUoH/Y+B2D0J7rFa6LYDRmzomsAaOeKqxEvbWacHQB08JkRIteSXiSBLYJOLB+X4xrzAzY7vgfd2S4RAKkDDgPzNEAIxMASSWF38WsgkuXLyXTRSRCe/DduSZMBMwe6ObTd8JBj24Aot07uDObPP9XsIzUGFPs5+JJ/M6oT4buxHv9X7BeY8KgOWDg/Z58GTC9Xq5FxTXOw9c3Cm6k5fPcjgbHbgAlvVG2tH1T3Oavoq6BlniZ+12n5u/2sDbOvasqoFg8x2Lnbcd1GdhSAhXN+7qMrAC4sA8sORJ6yHwD28z+Ft4fdv8UyqUDrDmCEBcpZ39kLS6aq9l4D2rLb/KYsFTPWdfbvh86vQu2s1K/K+zIjTsXIVQ9a59Egs4Y6sZfIA/EcSp/jEXv8BWcAhxaA+SVgSQAkGAMICcwVlNLlqTc9Gbv/HAA7MrL4+f1VlXwrUq7SvCoyGcrrWpGhuur2fNGYwM8YT67hT3s1LaZvqn5MLM0bzmHMmIFSgdFNj/mIBct63NhFZwEzDsBFgpDPeanNgATfCtGsX9TIKwNrg9tuVkhlng7TI/YArX1VkXKrEe1l2SynN1RCsFJsqnQv3UIMxhwIRjU5AGN9QUteVz3BUAvahuNgjC3HxLAND7nBp/cgONXF5wCz8xUDGgCjKPbvevlzcKUHH2ag6cnYzepYBB9Zi2FxDJdjoXJv1WDFiLJ6MKqKZUzoQFTfj2HmwTKcTpVWvcxHKm6kKgoORAEvVclPD6NdzLXpMT8IYNPcLV7yJGB2AVhYrAC4SNA5AxKM9ryDPE5fs6eeVKWGZ2M3S3MQfEyJUKV8L1ZpJXpVJ9pLilmlAxWkVJHKwIhjjD9TtVXVm1HdOy/pJiaMFRWM+bo0rWl4yM1N7oPhTJecC8wRgAttBjQWdBBGESwgSiV0Pb9DRgu0TY19N+M1mRKh8niqFx3rRDsLqjgl9yaGXT80vcL1wnE252PAZCzAHQCoiqoW3yYWFIt664fUpKaREr1NPakH6XkuOQ+YDwy4FMSwgU8GSRSz0UJx3Vx/5vFNbrs/EiLRY+v4ACITww6iJEodQKwBIyBRv9vwhKzUW6z66TUGEwhDS3ezqusAyNxnJn8xa1KRPSFts9YfFB/QDZcAm78CnDBT5U8rCqjfc3yh8Gn/hGd/MsKf1+QzYJ4891Jye13iy1cAE9cDJ+6FpYrEkidxDN3OtXR+FwBGMezoMmxJLOumAuD4J4rxJrfdH/XCoLGFVKiUbw+LAPQqWWaMMLrd6/+JycSIm85w9lOpt1j1MwAwFTiqAWEUxeYH5ENn/jInUVHeMXQ/f/jRePvCa4DhTwLHfBc4frGqqaNJzLPw6iZxV+HTplFGvZrXZT45N39+HW3TujlZv8D6fp8HRq8Dts9XIOR5YtakgBgdrrrt5Qsq8Ssd0BhQ4HMwmVitAWHAY/LbLDQNQDaTVJ8Q6W4qVB51OOqDZDPVB3TLOBepW5jmqaLbec3jGgBGMSxvvemDYkQ9GoKF1ShUCSKCqBeQrvmfVZPC1keBjXcCmw911tTJ8q5XgOLaQgA+x/OdWA2EGZ98gbjleTHdQHQN+2iwls3nK3/Zhj3VeQhovYzdxmArSwQgDRA3QiSCJUrTnjfl4KozRCSCCeYmt90EoJJbVCk/1+FiCwFZxLk4dRfLFia6x8LbYkD9v9cXtLG6+O4AYQRfrgPygVIcqyhTXcWFOJH8fh3rz7EKwnUArq8mcGwK2MCC1i7WY7Zenh56feHT/jE3yliE4TZncd636gPFCKWavGhcRx2J+cvs9MlSw0Ty3cCm+c7n0G0MExdW4BMIbTXE9UCynvyCCX+Ovm4gbByA/xisVgJPpXrzLj4EoRJjJIZrWHArS9iprK+KcefgiyB0XVKGjOmCmW9xhRVMUSyRFnNeFGEdI2q+/HFXclkp9WsAbgTG9wGj08CI64WxRk/OTDcUAvBHXSLQxcVCDMQSWbzv+1e7WVbz+k5w2tJtsbcCYV6WJY7hmAsDA7r1Sz3OgOgoM+KTOJbcjSI5yGIaNE1uuwlAAU/MF+tF5/0sIghVLdVdM2S0bSzHx2Mi+FTxXf8X925NC4BycK8QwfmgVX1LlcFiykEMcL2BndJJ7aQfijKfxLGDwAhByM7aC5U4qwPzNwufNnNuOH4VZaCPlPo2AahqFqoPVFc14ga2m+WEEL0cAz9kdPrOmMu8r1o/rTsXz7f9oswFs+jO6LAqkvC3Ggg5Fg6mwW03CUI6X12h8lyfcz3QHqr3DIl64DbqaQKc9mI87QXACD6vpJqY0EVxz2CEyCI5eMSGX2e7VtI5J4yTRyZhscrvt1nQuivOAaNLlYESwcySgiVbr37Bfd0/u31yEgg2FVaiPCeVOguqAfGov0iR0R9JABJ0bnwk9nMxw+fOh55EbgRhzozrBUA1polN9CLwok5HEEUQBjFMQB7D+j656PW+IrJ8O/bBCo4sGFdGejqiyYCx3mKe9/JtTiBvmI5OFiTisg9LtJFF7gZGDrUbHKs79+hyu5hSaUvh1foFr3r/6vZJCiXgCDwVVFJ7MVmRLsrGltuFCc68yFdACMDAflwR4QM3HPoKgIExt4gz42SuaQb8hBOE2oZmlu+KFlKR3QSssMJxDPWbbjpfLoJrxG8CYT8MKGZSVTCxYFTIb84nkCxCIPLDiby30gXFghaF4c2ReR466Uu2fvoFr3r/fKAEFxvpqMcd9yonIrkuK5LLV7MVCM+/uDJCyIC2J8a0z1iwqyESgMl15Sa33QKgmtPEBnp11mwuXgO70Ud4DHWzfgDYC3zBEOk7HlA6XKyHQzb8HgGoCSQLqsxorIy1Bxie7Wx0rFaf+wr9Xv32C+56/7HbJ5VHtRYT+GJrsehHcya57PyKAQk6+vBkBZPpjPEExlwU59awg3C24W6KBsC6tqHR+MidyVG3i3rdAnAsH2T093XT+zLr197MTA80h3SfsZP2UqpCrPQ46oF317VrpeiKXTJ9MhMLkgGdCacKG/mupV9w1/vnwyGgCDCKWzJe3lqsyzLWZWe6/kc/oKzgKH4jC7oolhdC4jiuzM0WPo+cPQ2AsX1obFCTO5Jzn566PwbReiwnfTWjI4KvDoh1juh+aT+WKSYD3i8Aql2rJk+VsVQly5kkddv2FvHT61icqO7Fr71/IkLNXOi0FQjV0046oBy6wZ922Q95ICqDEaL4XWw3COcf9Mw73DFB9AqE6wZAAS8XuzGQIDKf+oVkqxt00ttAc+YT0PJ9qRFSB8xoye5Xu1ZVeCSgCLbYLVNswoncHxoeLwCzBGjBNki/4BX3z9lXgUCyIIGmhova83cRgO5Te9yLgP3MfmsBS8xs8/U67ePQOqy9umBUruDchqo8sHSd3PMfT5ifo+ack8eFHI6QEcnT5GvdOnVdXof+ptJ+BVPWceiaRHA8Us/nkACo8mzqlqmWrbFDppT5A5UIZm7CPA2Vgm3QfsEd909kKIqB1qJAKCBG8ZstZz3xHOAAiwmpDIdng1maZQAkZzsHZ537YfQrwNyxoQ+HakrnS0h1mUA1C96TdJTmORyhC3oeqdwROi+GDhkFI6bYNrcNDEDeAkXwQizPRpmnIs3OdqZPSaRFUcbchHlgie6agq2kX7Dd/+d8lUJVXuUzk8ERmS+2vfd4uvN2VOV5rSwb0y3JhgIh9wJeN3YMQCIgR78Q+nDEVYBYZUrUpbXFnM7COSdf7N4IPvtDnT2BY/h8Chh10MXQeYGS+7GGjaQiABpuNIFiECnzdWJMIUHcazLptC7YivsF8/7FgLFMqpiQL5TuNbKfA/DC46rqqAbAwIKWK+timRUBEiNGsOQsyQm+Gpjd4n046hbT84KPuYjOmHHyp92gcgDS2OoIuVIeh/xyUkaVwyEWdLrewHE3uBUDcKIwnq40HpDXL+n3CzbaKdguel5VnFJl2awaghLQBTzteZ0cjLq2A2n0M6EPh2pC57Wg41poLzZsAZNso0Hw6eVR/J8bF9YjWGmVCpGKwQLBRCcrbiSxNLgVAxCF8XSl8YDHHFPW7xeFBRwv/rGqOKUBkODzqgdWPYAM53vTASMQu4Bx9J+69OHIF+N71F1O1gUB+AsBfFqKC+4Wi4BWX+CYgOTAU36wdMVNVKka3MoBWBhPxyiuko3xkSX9fvGMkqsDlzzHC1N6SQ4DoINOe7KelWWTheziObeKCdARApD1AdVnRH048gKUAmAEYi6Oh4DJV4VoGDWqjq4XLbO5o1jBoimEPhPJmwu9FvnTLgdgYTwd2wyXbMyRKen3i2eXXB245FlVYUpVxUpGiLtmGBlrTEhVUwV8dEkVKAq3MHJ1uzRbRx+OOgDWFX6MsXJU/36lJoEoA2AKvw8+uwTEDIBbStdOs8ddDsDCeDom7ZdszBIs6fcL9ror2C75US9IxJJsEsHdGFBil4yYuUwknofJgF4XcEUfjrz+X7fKo4EJJ//PkMORO6FrVjQMeL5kJhZMMXzLwNZCt1nzDFgYT8cQwpLt4hDON0i/X7ys5OrAJVe0S/ISgFY7j9ZvnQ7I3+lyqpYaL98CWp/N+nDkZdhi6bW8An1kP3fRTLKVWlwF6RZCH2L4zDDR0k1IqeTNb2OQSYNbOQMWxtMxeqtkY6I+ny9VEz6btfb7xc+XXB249AoXv85+tIBVgJJ6n4lf6oV+mfjdDJNMH0wAVFX90GMk1f5TxlS3Fggh92DyN0IORy5665KIfCktsl+K3VsGtpVOWOMiuDCerlSnjQ2rB+n3C+pIBdulz8wqonrNPLKgwKaC5B3s53qhXVq6oDNg6sOhqvqhEr3V2VNLBjmnSSNdrOLJ1zkAu6VPRjFcFz4fXDJ8i45hG94Gt3IGjOFYA8TTlQZ/qGH1oP1+8ZtlT1MAtHK8mQg25zOZUSCLIliWcbw8wfW5Ln04ssqnHX04euiCk6/3de66MPpuAQVZAEFkw2MKFw6a1wEL4+lSBvmAOMhD8vkOkFX77feLNw14YT/ssmc4A6oOdHBEkwXlgjH2k4Nal6wB4fIuX9LzZjAmorNeHMo5Tc0OewHwDTUh9HXxfGJsYkAbAAAgAElEQVS/uvCpoAcew6zBBrdyBlQwwoDxdLZWXLDFkHyF8xGE/fb7xR8XXByAAVC1oB18HQYIT+8uGfP75SCUs1o64he8v4j6cIQ+IqkPhxrBCHjdjBH6AblQkAeY1ondukSiELmsUPpjbyp7XuvDgAXxdNZVvWCLIfmKg6Bbhrjup98v3lVwcQLw8gqA5v9zC9jErutltg8gMxDWWMBaMVkmANWFyEV6R0uH2I1IzW7ypbkQOTP5f2ch9KsFkwp0kQlDAOmxzHpscGuGAQvi6VD4RgmAg/b7xZVlT5MATNXwqQc6KGwf2U2uGV2uzg3D4ua7fDnPwZcKgIdq9GaIBPZb0YdD7hgyIFWMXiH0eQ5vXS5HcMkc++9lz2t9GLAgns7KxxZsCkgdtN8vWD+vYDMAUpcja7lOR9eLVcIP4tcuob/3AOHCdW02VTX62ApB4Mv1v24gnPy9HiH03fJ366KYHYTHsgBBg1s5AxbG0+HLZaOp65i+ln6/YM5EwdYBwGj1cmUkE7+8THLNdAHhwrUOXtcrO/pwhF4cct2oN68BMDCfmsJM/n6PEPoYPp8bH3kCkbtjji2tJJA962YAWBBPZ0WBCrbYsFoOf9pDAiENk179fkuvf9nTXewKcBSjsn7ldonWbgQpx+26otaLIwAlfi2QQSJY3Yjy5i9dmsFM/oEDMM/Z7Uf0RiYUA7J+ToNbOQC3e0WBBm9qLad6HICG1ZK1XB5PoxnuOOIcxSXe/Of8xHV/P+FpwN47gKUpYHmuSve0pKZgCKSq5wqniWE1WZz/xouBm74KTMwBI17lVBXwtWSs+8/vL45Ff3vhpcAnvwos8d48DZX3M2hx9XIAnu0IIO0chu35AOgLL0yuG/jOmwbg028G/mNz1YWdETbm4I5BrFlov+EtD2wIo7l+Atg8D2xY7iw3V5diEqO54mnj6XdMAYcU+6gon7A3NSO2qFjlyZYDkAX6uD5Iam44YaUfVNDNxaJcLIPXcGGpfi6PnZdVD1wPspQBX/wl4OaNwN6Jqg+xwrxslcVFuYJblehkcYYZGPS3L20BxueBcS8nwg5H5kZkx6TQSbXFZcCQKadx5Cz5mPurAFxrRaa17pAR2PFC+ElSHKQ/0QjQcgCyGyM9v3SnsDBRJgL6msWCf6IfWeUJac8UFlpY8500DcCfvgb43hiwZwyYVhd2D/VSrKGAmIDnBkiafEcN9cprHgKMzgNjS1V7rRjRlceyrqif6KAkMgXIM+6tAnDl+zSL36O9+U8p9jGHQo285/2XA/AnXeNnKAorDXH/AILwbSvLEz6Ql2+cAf/3XcCdw8DkKHBwpOpFbE2wadzIdyh3jjNQirYWEwYq+/zJwMh8pf+xKNSwM6DZMmzNRRbM2K+2Ii6TlFrAWfd5V3i/F7IgT2LBF5LbIdkqxLPWvtzlAGQ3RpU3Y7AiixMxLOUB2t7pKQ8M0qCTnp8HkojJgNqaMEJesQv4AR3Iw8DB4QqAs+6SWRiqgJgY0HVDAdBA4Ba4xN7ndlSFAAjAYX4IPO5dBDMAdS2i+Jx7XTf1eEdTDfgAQnR34p/wQkRmjNAoByDT/ugFphXAmjAEn8qaPQAgZCs0lSckCNmVigEbFMsPBBE3DcBX7gLuawH7hoAD7EM8DMw48AhATrjtQwiXoqkTEwWd7LOneXNCbz6Tiq/TInb2M8ZzIFrTQbGiy92oGz7pXl/7jvdAJnb2470IbB3T77Sai+hyAP5voTqW6sKwFAc/TAdc5+3dvcsTrvPVYSK4SQb8xV3+6IaAqSHg0FDVh3iOIFTIFxtit9orL5Z/LD1Q4s+B8OnHVuXwhhdd5DoLGsgCCJ04q66X/Ju/vSaeAxDPvbdtmdtKDV90gVEPIl/xySkviOhmAEjrlzSkwj40SlQZYZ39I+8JBMx8mZryhOsKwqYB+KpdVSDFvhYwPVR9BD7uyX4SwRS59nNI+bRck/DzJ05v12M0nY8fAk8iWL5BB5qASPGRCi8EVjzv3mqpkC9ACrrwhKukB67GhpqRRowQMqCiYbj8oOoHeUWpdYIBAUj8c8WjrjyhNIJ1unzjDPjqXdUjJAAP8TMEzLYq9uOHICQALe/EwWe+QgddAqCzzD8+vgIgg0qp+5nYjaDzCgjmnCYone0klqP4JSgvvK+6LoFPoFMlkPGh+0rPWta4RHTNJJQz4M8EAGoNTPVU8opS64CC9zoAWTFChcq7lCdch6s3L4J/2QFIEBKA1P9mHIBmhPh3Ai354RyAAmWsR/PRs6vOR8Z8FMPS97yxtIlYgVB/I7jC0rIKSfLXF1EEB+BFFjQ3jCLA49OWsRTTEPzvzQEwry7VrZ5KwzAQAPssT9jw1dcHgCrORQCS/bgn+1HsCYQSveaHkzvGv1scgU/6R55Y1YIxhvOm1EZekQWl8wVDxJgwc88QiJc6AKX/meHDawX9z16M/Em7bO8Q08GBP/jEkAEVjMBoAFWXUjRA3KtNwOBXW3EkAZhrALktpC6lKtTV4OU7RHB+3kHWgv/zrnYZl2kCkF4uF8MGQGc+MqEYUCA0n1tkwxbw4ScHAHr71Q7W4++c8czwcBAmHVB/c7Bcek9b3FuwbdD/kjGWgzJjQ3thGmVA3jhfOyU+RxB6FamOFp8NrhsTgLy8Cpzm5QlVptAU+6CiNgXCaIQ0BcDYV8b0P4pi30vfIxD5+w72C9aliegW8MHzqrmh/meuFhYi0pKbs6D9fsh/n1XFMrYMbPgUByCZz6J+uEknDA9AornWFRb01WZEsACoHhOqyC7wdetT0QAK2KqOb5MCUvPyhLE0oQxzqaYNXL5xBvyVXe12vByLADjXAvgxBvSPGFGMIjCmJbEW8HfntxtQmxT0cmxp9UPAdKAZ1upA6EB7qgDo6oCUxXRtPVSpAwJpnUhuxAqWCCYK1MBExZljY5S8SYr+pxAFAuBayhNG26jw8usCQLX0SAAkwwcAEngyQizaXoziIli+Oe7/9kJvNk1LmBMe9ECO3XRB7aPeF0EYHNVPdT8gj016YBcWtBfBVYJuz7mF7VgGY/pO8f5WdQ1/7U67nIKNS7j0wIbDPFZsyNHHY7od/xdlEHj8CcC3TgCWHgGAPSxiSdt4312u/8SPAl8/Dlh4pDeZW2PD4J1c9+uyDaIDkgEJQKnTfG/N8nUAmu5HUnMW5ARbPfEuIHy/ACjRK7FL5pOR4RaxgTHofKl8r/S1ZWBnAGDKefbn3AFIPRPXB7sFiVQimKVgGdl5ooNwLQ1/1U+DQGSXQ9r5Evy1q9rZbP1lGQDZsPpzI8APHgXgod7qUx11YtBbFzC+/C+BL7SAWwhgdoLkONSLqy5oLogYft3ZI1F7EAC+phsAnekokhP4HIzml/PvthQWmPB9LJ7jxkcSr14jWj4/0wFlgJD5eoDw6fe4DzAYPHokWhHJZ3TFSkn4h7YOSOBwEtiMTv1aY0uktFYTmI2/43EMQmCuAJmUE0gmVD8EFdPpdnxhVhqzDr8F4NMtYM9Jfg98EVTeNu9Q2OFZBX7vr9vtgm/lcezczZ61ZNN8DCvilYCdPXqNDQpAlfGTKm0M6AA0PTAyoMSx64cRfPQHXsniOTI+fEWDFGp+Qb9BeySRBV2kpl0QxxGAlHDmkI56X6z+EP7UDYSdRgh/IouwIZ36lHabBE0GJ0r10Rgb/xA/tt/j/6aMAf+7R4CxzuBXWRGULwBfIrY6UNfpvLae7n0I+LO/reoLMqiVMbW38oUhkNkQIzZO7tIweGePcmWlAFTjAYHPVGwXxWoLYblEDkLuTT8MDPhXLJ4jALpaJB+ggU6xfgJknT7IKXIQXh4Y0FZCog+wxiUTwSkXUbSMV1rB/A31OXWuFpPUda/mRHKi1e6U+hA7Zq7l+A+UAfDtHg/LrptkQpZ727cRWOL9542Pa3rOvuOqagUltgtmJM08j4/PILbIDKz6w5PAHsbraTnMGdZWIwIzxIfeK0rn578J3LAVuH8CODRahV/FFQ/1IumIvXP1QudNfyNT8oVqcHviPcBd48A0g2RDuoDqHdb2SalZAdG9dnfDkAE0gXnH5ijWCDbKCq5/MRiV0QD8HgHQ63jG0hdsLGxA3x9Bw1Asli7hO3BwApgng/Gjvq01IHrXJ7q3Cz7E++YziF2rs1ZLZ+8H9jJsSoECWXj6igmR87aLgfbGq4GvbgLu2gjsHwdmCEIPSI1h+SkCRjpfUC3iNWcpoRrcnrYbuGsUOMBo7QBCxSTG/igxVcBIVGPWM1h1JYQPnyKNExGZMDIJ9b66eEBGxPDY1Y5nv+GCjfGAxD+DDpiawphABWZPjwNzNLAEIH4XCH0M7/5c93bBfI8Yk2cgVAdvdT10ifDkBWC/r9lGH51NhIsnsWHOfPmEUKT94WeAG8eAO8aAfWPAwVEHISNQlKQUglJjJExqC+H6Nq93kOpUg9szbwLuHa66QzFWkaFieXxi6hgVHOMCYGRuJ+5V4jYJIDKI9KlsAvFDq8QDrnb8NWVPh9EwdFkQ79TlSMIsN0Mi5s9MoOGno4U6f3YAvefL7Y7rvdoFLxOANSA8f7xSgWmd0kCQbmZ6mTLEnJ0UqWLhUkxlrBn6n3wWuGkYuGukCsufGq2iojnRFpafsU7MDxErJuZhYCsJosHtWTcBe1oeq+hxigJgXBrMmTBPnJKLrr+VED54ibHYvZos8sO+DNcrHrDX8YVVyglAKud0LtMjFPtNMz6QLDY7VomLJd671AEH4Xu+3g7nWq28ISvX58/hguOBg8vtFQvV/hEzxfqOevuTfpjri8vAWz8L3NYCfjBc6ZYHmBcitnFd06pxyb8W4gPlgonBqffTtdTg9pybqiVNBssyUsdUD7eGO9amnf3sXtxQipl7Wg/sD4A8AwHIyZMYky50Tp/xgN2OL8y051qw2hXzwRCEdT2nmck1RxHG+w5jeO9NFQBpR6ldMIMXlFWgVndqF2dVFsJzuOgRwMElB6DcI6rznemD0RnbwQiSRS3g7Z+tVIl7PC9kahiYZm6IizuLigliT/VoUog+p8P9l3wJ7qGEanB77k3VczroUToWLCsABud4ypaLCUoxf9i/9w9ADiICULrQRWuIB6w7nuZrwaZwLBGwClSqSyz3AhHbaRGEFGOmC44D72UVgjW2C2Z4lIF4ArjodODQcqUGqAxfcpG4mJVuVqcL5tbs2z/veV0tYK/nhTAqesYNHdO5PCJZos+WuzxHJIViuXFyJxupNLg976ZK2lizUKodilGUgzyGhokF8yw5Mf+qRkjdjfuDtwkkm7DTkNaBaQ2ox1q3eMD8+B6O3H6em8Kx1Ccx9ptWl9iYIUAAWrI3I3nHgPdOtsO5eOuxXXBdj0V1vOL/so3Cxef60tlSpYwveKf0pAu6ohfdJ8k4CUqgvr5jV6VGTBKALeCAh+VbZLTnh5gu6D44A6H8cVlkNK95O1WkBrfn31R5HSy+JCwPplAxRegE/2T+AloGncNmbQyogUQx/KwB4gHj8YWNTwRAOW0FIIIndoqNkTAxz/bd09XDGLBdMM6/pLKi5whAX60gCK2ujxzEAqGL2pQ1Jis5AJEAFHvTujYAKjRf+SEugm1d2COQLU/DAwQ44caEw8AtZzSIPgAvuKkdrWMM6M7xCMBoiBn4YpCE2NCfxWAA5MEuwvCCEICwlnhAHV+YORfDsWJGgPpMKwg1b9QpFnzHbD2BK2JGul9s8KkYW17vLALQRTCBpzXZpS4gtCXXMAkduuAy8E7PijPWprXJ5CR38ygw1fJDohh2BlRAgq2OeN7uTWc1D0AFNtmL54ESBsCaJcLkDajxj5ZXRiCIGA0waDwgjy8sk5+HY+X9ppUbJSCp6TnFCMXwny1WAFQ8rUAc2wUrRL6mXTAefWnFfnz3FpbagQKLAqAzoZjAKkkpXkNO5GCEvOMLFXOnnC4xIKOjnQGNdWSM+GqHQGd7JSsxUf+JzQLwhTdV4je1nQvr1MkPGtlf9yP2Dy+gAqZ6rQytfvdHSDxgLwBF8AmAYjHWluEDiKGMiqOVvtejXTBOuRSYJwDJAARgZAGWL9Nk+IM3SzgTydE4eec1nZHbtDaNAf1Dpd/SMx2END6kD0oXtFhBXmcY+OY6AFChnKnzl7NfdMR3qCAae2B+VVMYXASvDs3/X/zHJZcB84vuiqABEo0QPnhnwqQLyRURmZBPytnwHde0M1vN2lR6picoKULaxHDIEdHkW2iWg4/7b5zb7DSQAVd0/griV2JYojfpwRGEYsGBrOBmx/OgP5sAKANkcbFzNWTRnX/GSGImMYH/LYlk+gGvdT+bW+SWH+Ig1GqL5QeTtR2EYj5LVHfjw/ZDwL8yJ6TB7UU3VVoTjTYxYDK+Ivv7dzNAZIxpZSiU8jjKgIWTcykZkBawDBBnQdMr5QeTKI5iWCB09AmEb7+ucnOQ/aTPWn6wuzyS4u+R0Ob6CUGqJpIDA97AdqINbgRgBJ69CG4Jp6q/ckjXqB/RKla4WpkO2ODgHoynigA0JiLwaNiEt95YQKJ4FRC+7brKzRH9jZbN6iJYuSHm9I5iOAOhHNJfZkh+gxsBKPbLu3+JgaWDdojhMO5kkDWSlNTg4B6MpyIAjf3IggJgMD4MCARjFMU9QCgAykhSKnUCYHB9JB0wy5aTRUxmup4h+Q1uAmDs+hpXgFLnB6ULONOn5xACNJqxghsc3IPxVBGAiQG9aLeilWUJW1FvVXEN0TKp1C6At19TMSCBpz1dHtT/JH7N9yaxp6QkF73KBxYIr10nAMproB44qQGTj6sjUrtOFPtLeFQHLES9AdDFrq1E6M13MaxVCTNAXNFThIylLcor40zxtgDAPKuVwDMrOKw+SBTbtR2MND7sZwC7Qvm4wqHa4T/uIrhb+7n0EgbQdTijoyg+agWXT8llDsAFWr/B8qP1K7bT0pvtVwHhW6+t2C/m8svvZlawi2CKe37nhFtapkDnILRqBQA+v04AjMyn79EIkXO/DnzyCBwVweX4wxs9B4rRZgyPVFqykgDd+5JSpBU5r0vHyHz+jsc3ub0KABsZMCyQgeExKyFPVIz3lmcM6OfPAGCADYPE67Jfs6h7G0o+xvi7oyK4cLZfOgpsXwC2Lq9MwuuVERonKn4nSJrcXnQKcM7dwMMXgYcsVxkSebJgzOWPqdB1ad2f3gpsnwK2LXWeR9m3danUIV1lBSCPArBwtp+7DThuBti6UDWDmWA/DvXk8LRptfPtNUlihYZTOPCi04GH3wFsnwGOW6iAs5n3GeJJ+KLoE+9VDClQ8R6vOQHYegDYwuY3S6H/iJ8jb11ck0q9Qhoc9QMWgPBZJwFbpoFN88DGRWBiqQIgWyJY3lPozaGJ1KTEPh36zpTkJrcXPRE44S7g+Cng2DlgyyKwaclfFoIwvCwx9Zn3Q1DmIPx/2/sSaMuusszvjfXq1ZRUElJkKsBEGQyYhJCBSkUqAW1tsBdpuxEVaBzowXZqe1g90G2LotjQdmMjKqtBxQERdAWUAkUlZNBGkQRNyIAEMAkxpFKpqjfUG3t9//m/c/+737njPq9uVeqcte66b7jnnn32/s6///3v//++Tz0dmD0KzC4DM6vAFpd/0L3Gh6yTDgnvLwKzAWDGiH/ThcC2OWDrErB1pRgQisIQhAa+AED+HEEY6uNLyrRnZLSl6tSbrgLOeBQ44yiw8ziwfaV4UGbdegmA5QMTLFlqsfn7XecDW+eAmePAltXiXnkuZSBkRcm4UGXtU2uo3xsAZgz6y54JzMwDWzkgBOAqMMVBCSAUObh8QuN/CiTgcWAuyWhL1amvvBbY+VgxbW477paa7gIBqCnUrbUBiQuhAKDUot13IbBlDtiyBEyvtO5VDxvvVfxW/JkWNFrCeK8NAGsY7BsvKQC4hQCkJNaKy2LRIsg6SJ3IQSe1onKKC2CsOYMeN+0Dtj0ObDsGbFsEZmWp5S74g2Ir2uA22BScAJGA+dJFwPQ8ML0ETAUAkgDTPq9zdK/+sMWpPF19NxYwA4g3PtsHxAE4SQC6FdSgmGWRRIJLZJll8EGKjHiX1jwaN10HzD4BbD0GzC4WrsKMW2pNobZoCu6CLCDfCTqzgg6sr+wFphaAKQfgZHKvpRSYg7HN5XCL2AbAZwPrZGaj6ippXhgn0kqmU1woxnHedg5AATuWHig2FE1uVRwoxoX+Wcbg89S3AqCKPONcCi8oPtVP+9++G3j+oSK2xRBFDElUxbTS+3nvc4FpDsjxllXQoJg8FgdCQoGJJTTicLcQ6vPL6wbg9cDM4cJv27oAzFA5ky9/UOSvmg8oP86n0dICBn25JwjARWDSAUgBHN6vfdbv10AbARh8X91vDM2ss+NvAECKPVLCsHoyUgRqrlbnRwB933OBc+4DXrIC0IEmiLnE75di8HsyAcjzWUVGUi6uICMpVwwJVMXdeOk3XAxc+Hng+vV2esAYw+sWoP31r3eLcLwQBeQUrEHh4Jo2h4vDmJPuAyMLGAeEn7uqbgB+I7DlSWBGCwe31Gb9aL20kGDb/EGRxY6WTz8f2wtM8l4pgL1SgM8esHCvsuylME4nn9cfQLtldg6TZ0kUKorAfij23vAPCmqp3fcCl60XFINid1PlZrf41/dnApB6wSQjutUfIDJR8CGIQOwWEH7DywpKrWc8CFzqRLHkVYrB2jS2FQH5vkuBycXCAlIUUAAkCM2iRBA6+ARCe7DjYmQduLYTleiQ/XTTS4DpI+6nLhZW2nzVCEBaMLd+soIGqjD1ampdugiYWCpeBKA9bBJC9ActAk8LES26SqsftInLZ44dQif4Igdhym5WLrPDyuYH/7HTCNwDnPko8LXrBccjQaioe6BiKad3+QY/MGTH6rS3OBvCnQDuAIyqhiDkQ9RX+29yE3on8IwjxQPI8zkTiApGU3oVkD/4fGDieAuAdMw5MFQjEgg1DYsUku+a3uI0TGBfV7PotwHwaOEmbHEATvuDIutni6UAQoFRIFRYhfe/dhEw7tbe9Of0Si1g8HkrwRcevDajz07gIJ7n05rYyWIpb4ya/7vv8PRdFpj/LXDmkQLAnA4jCCOlTBRN/rFMAJKgkkVHpGUjySSBSFeg7/azqk8EgbSEq8UDRACLKDXSyaQ7Br//DcA4LSCtwnKhTEkQcmAIQhtM+Uaajl0uS9NatITXWzpzfcdNB4DpY+6nBgDaCtanYLN6fCj4u1ay0QIqtML/EYC61wSA9tAJeP6eWsAoDysFpg1eB0HIQRCIIkVeCqQf/05P3WCB+UPA+CPAzvmCaFWDKEuYcl1yMN+Y2dckqGTeHPEvvWDSNhOAfbefX0A6rS8CUw8X9066bFIfdqMHJID++DJgLACQumyc3gyAEYRRKFCLD1eu5ODLF6QvXedx0w3A1BwwxdAJLTXjd8seQnGrZ9bPFxLyA7WIKON63tYtCQBN/sv9QPm6BkLp0vl9t/m6ietR6fbyBA4gnXtORwRRpNnTtPpW6gWLH83lKqcOFTEnDiKtoHwy8RNFhrefyeztbnrBfbWfgttsP+kIyO32ELD1cHHvInrlvWs6TsnB7qAUlg/suFtAWkE55zYQ0QpqcALoNCXTEt7A3KoaDwGQfqoAOEUBa7fUbKctltwCajVbxvSiyvoasM0BaBKwwdKb9fN7NfcqBWGiSWykWXER0umeacUEonQgCKRfIgDFjya5yq8Wfsfs8dYgiuMxgpAg/vnMzu6mF0z6Zj5APdvPQec0TEosnvQosGOhaLuIYvnwEYSithE52F1XFAA0p5yigD4otCqygFKnpHUpLYP0OcKURYv6Mj4MNR433QhM0gL6QongawOg+6rl9CswKoSkEIxPyTsuAPigCYBmAXVfYcVf+n0SRYw6dP1YwNgHsgSajiJP429RrpWOM6cxDiJB6NINM4w7LbUGMQUwB/M9mZ3dSy+YVG0EoBiDBST5ddZ+PkCsAiIlQZDa3LVatJ0WXG2PbL98AB+4omB3oP/HgTUhmGgBfRqWf2TTrUSjExDSP/qWzQDgfAFAWyzR8rkFtDAKX75jo6nUguZxZ8NByHbvvqBQ36T1swcsBaBAGGRg40Ir+rt9WUDhQ5ZAU7Es2e9LLzglqHRxNkbeuW+oQRRls5jaMjnK0a9ecNf2R4LAwO829kQB3LTtEYQPUwzQAWgW0AGo8AQH0ljp/V17pm0KRcEifGuNOnocO1rACQbKPXhs8TtNwVr5uh+n6Zf3wDgu29g2FdMtOc8B6PdpFj08ZFrplw+ZA5FTvAQQ0/BT36FPDkRqBT9Jag7xYlQItY0f88j78sZzCcKPZlrAQfSCK9uvB4h577SCotUiEJ8opq8IQFl/PUBPEoBLxbRE62LSqG4dFB8r5bHcOtiOQSqT5T7RKzYDgJx+BUCCTxZQCwhaQc9oKcEnEBKknj5FsJ1LAPo9xoWWPWDy+6IIoqbeaO0VA+zHB0zxIQDKkn1GgtXiRxMIAx0Vn0Db+lkuFjLRCt5WEwD71Qvu2H5OfekD5FaciQay/GIbFgBXriwAyGmJADR1ck3DwTE3TQ4B0LetzBJErTYAr2BBSI3HTS8tLKBZPo/fWQDZp197Z3scjGb5BDp/L3+njMweB6B83Gj9wj3atOsPWin9WgXCFlVO/3ctf4iD8XkBkH5USlAZlNPZAQqARr5vxu1yjmH0givbX0UQKI63o0Wun/xHuR8E4VnPK5JQLd4VNttTBvK2uoiKOUf/f+GjwMNBh0NMV6J0c0NpcRv7mrYv3kh8/uHxYp+bVpwLp3R7sts2YzouSq3KGa+q7+x7Co4nazAerRKsVlV1QitF59dyyFZaYY0HMu9mWL3gtvZXMbymBIFMZ1ov2h0B+LTLisxgW+Eq5uU92iZ72ud9vvR+4JFp4NjkRh2ONi0OB1/UBCkvEYRhfuNs4OmhhiPKnFQlx6aAjMnSXJUAACAASURBVPjmz1w41nnwO4cCIBvBwZgTAOUHRq3gyDExD4zRGVYEnpm5LqmQc0M5esFt7acFl0SlHiBxuTkYxxdaihUC4QVXFu5FCUD5QtJl85sjGA0ziQxqeu/fem+hw0F2fLLQGxFlYMRvo7v1WmIVtpt1DFkXvOR7LwJ2HSkyoZmEypoVVe8p7b6qEMnidGG/Vl/L2aPOIwuA1pAIQE3DAmFa4j9f7CPaFpCHKujr5xzZesGdHqAqKz5X+FLRAl58le+jui+kTBALMcgZ73CDBkpN2/7+bfcWOhwUyCEAjQTcAVhKdjkPc2RajewKyu/n1//qJcA2uhBMRGXQOcn9U6JIOjXHQqSYOsVoQp1HNgAvz8yny80H5PVz9H6RqVd849WtXQ/zA0Ow2ayGLJ474L0G79vvbulwkJi8BGCg4S01SKqofoNvSIC+5zkhFUupV8rUTpJN06KpaBkFQm5M1HlkA3AyM5/u9Zl38zrk6f0iU6/4hmscgK5ISUtCTowyDqb7UxwsqFJW3fo/vbuIBJEZ1YRgyHwQKNi0KEl1OKTCZJdxtPDn//v8ooaDaVgqFyiTD2IKfcjZS4Fo+7g+HXOPv84jG4DIzKfLzQf8KVfI/FNKrQ6h94tfz+vOA9cGAAbrpylY2SDlVTTt+uCnV3/V3a7DQQAysJAwobZJgUXi78Qayhd812WeiOAZzEyUiAkHMeu5BF5FwZQAWLPwknkLQy9CrPMy8+lIHZFzvN3T+YbV+8X7c64OHHix74V6zIxB+RJ0wQ+UU992tYoFy3fcXcTDxQkoPsCUhFIczKVCegSg5B8A/PILN9ZwxBSxtiKiUAOi7JW0dLTustF8AGbm0/1o3vjjnSGdj+lYlGwdRO8XN+c1wABIoHk6k61yuSCJITq3jDY9Vx0BqK++uwAfX6JkI/hME0SC1EGguiQ+isqcQRLrF6/0jO2w+6FMnZhyZYsQ1W50qOHgPX1NXndtODsfgMwHzMin+0+ZN0S9YOllMzWfLwKQSS396P3iY3kNOLDPM1y065H4gOW3p4uTDkB8zWdb7FgbdDhEgJkCUDRvogTmd/vPv3BVAUBuvylNzAAYi4hisVQnEHoIqWblrxqm4Mx8ujfljT+YjsWBYgIOc0oJPsq1slCpH71fKybJOEoAuuVTRSCnYlmU6P/Z4iSJEcbLv+Yu9/1EAh7JKEXDKxq4ChUiKymRbwjgHdcUWTARgLYXHSr2LOU+BV7MVwzxwOfkOWybYAGZD5iRT0edjpxD6VhcOQ6j94tP51wdOHBdMeXa9OqWRcmWXA1XLUIUH6zyCwlAs3z+YBkfs1u+VIejJEF3ckrjI9T0y/aMA2+/tgAg08VURKT8vbKMUgAMIGzzAcOi5HknHQAz8+l+MW/829KxhtH7tTz+jIMAJPCYMULAWd6fvi+EY9ouoZBM/Kx/4LUBgFLgNC5o16FrE8JJVJgkiFhaQQBv3+dVbMrWVsC8UxFRkjjaVsW2DtRdOJ/vAyohVYK7A+bTvTdj8HlqTMcaRu/XxHkzjgNkIOWuDr8jnYYDKDutgpUhra0uAlAyCCUAK8BXcjBXgLCk/h0D/hcByDxFAdAzoFUqUBYRJTUcMWdPP7ONL6i5bLQeALJRQ+bT/W7G4AuAOXq/lsGdcRgAY+glLkYclJVTsa6ptCX3uQjAKINQstFrAZKIwWxQIhIJuovB/Nx+r2LzFCwlj8Y0evl/MYk0kieVtcvrwGUnHQCVjjVkPl3mItQsIPuElx9G79dOzDgMgGkAWlNyBJn8xKprBRC+zgEo4LWRgcdVcOCjjlNvmx84DrzNAahaFZWLygKWxUNibIhTcPD9BMLLa65bzreAMSGVoXvJ/Cgh1WUfO+XTZS5CDYDs9GH1fnOrIDcAkABTTDCCLYK0Cwi/586WcKJUiEpC8CCBYDsiiSplqUIUmOjf+o2tIiKVUJbgU5uSWl4DWwX4+PcXnrQATBNS+8yny1yEopdcay+930y5YhgAg+9n2OoUeI5TdQer+32fdhmGoOBZanBo+g1yEKU4dYgFSvqB//vZBIBt9RshkTbW8ZZZ2hUgvDL3iU3uux4LSBM0ZD7dPRnTH08VAIfV+2XAOucQAMuVcKfFSD/+IAABsEoGwYAoHZIKEEYxRIHwLS8pUuhjFVs6/ZZhIVWyxVKBBIRXnbQATBNS+8ynI4tBzkEACv+chlUVIKE/5cRGsWmlKfIzudc3APLQSlg3E2OCyVRc1kpU3DgBmKoQsWtlBcswjPu+nfTYtBL+GQdgOf16GCZW6pXlBCqWSgqJypoOAFfXXDifbwFJLvi5HAjlnUsiIe6AjOp4iQNQHRlT2PlgJCUbbc2s+v/hFwFb/q7gm6HlYpBbmTV2sscQyy/qFBj2v0/cAdz/HGD7NDA1AUyOOU+1CwWOewNjKj6/O03F1/WuugW4/XJgfBoYmwDGdH7IxB5kLPIB+I8AfNwZgga5ck2fJbEm8V9zNWPfrasbgMuPAcuseJ8Exsb9FdBhA+7gaQNKB6TfcgCYug+YJT+g89aoBDMmIMScP12uTKj13uDv8zsKig/uJ1uQOsnojm3qB5P5ACRBH3OhPuzzRN9DV88HqQLEWPJnvTy5nm/t/1s4BcuSpRZtGAu4fi+wtBVYEyccrYwn6hF8/FkJp9bKxAKVFsn/d8urgbHPA9NPOEOWl4+2cfoFHhfVrJTZPKHSj5daOtup6JyCpPx8rHWRVQ7WOlrYCMx8AHIzlxkALPD9c0VB+x/A3E/+E2fUYHXdF7KTGwdvTd0AHP9r4PgWYG0KWBdfsBdsMPfPrKKsoL9XAVLAvO2fFylCE4cKliyrDVZNcGS1CqEYhWFiAZV+XntaURdTLmpCEbpchTYLqi6NrkMCzLzt5Xc4HwyJmmkJ+Z73jQOh4NWeDUZiK1K08f0EXt7CMHVawIk7gaVpYJUA9LI1Ao8bzKX1cytoFtFfpdCIWz7rgzHgth8u0oPGDwETc8CEMySUzFaikgtlpW1Ta8JqNba7lVljSRgW+Q6ZP/57WQvj6fydBjXfAjKbgEvMLwWCvhNoipgNpnQshlS4IGFWzIk6ylWwAz93ETLxGWB5ClidLABoIOS7pmGfG+33YAG5mND0G8F4678vkiPJczNOAC4UyQm2N8w94kirFlfIAl7i402d6dbPWWAtrsjOFiuCvAJZOQE0pHTFsckHYDeCvhNgipQNxoAz8/8IPr5nbvH2jd+6AThJAE4AqwTdZKEBLDoDgU4+YVkPHIBoPwareOt/BkDexsMFAFnbzNJYm0IDnVwbt4uyur1kwL7Tp+iZM/08WT9Rc7DHUmuYTr/x+6o4ovvu9fjBbgR9JyA+omwwxvZI5ULg6ZW7y9FPf9QNwKm/CgCcKABovh8ByVy/UCtJq2f+X1yYJPGU27lIZLbuEWDsWBHesZeDz4iURLUWa1TE47LqK12fZmd3OXidFctqm92KatVs1jAEsNv6sdymaa2g8+xUL4I+Pn2beCgbLGWHI/h8G3oTr45iK86POlbBU9yKI/AcfLR+ouQwH9BfmmbLlTHboOnZ/T9+5vaf8FUaAThXsFOQ45mUcgZCWTAxe0UQ+urYMO1/37GtxQmoLCBtRSp30LrDp2SFdzYMgk/R+VNwvwR9mwQDsaspGSfJgYDYNTbp8psCQFJxEIBkQjDrxt8dXCUIY+COH5MVFPi8SOn2n/QYLZ9Gp0cxANIP5IvAkzVzxivRydnKNzBa8fddM84b6AFyAriMF2pajk9kYIeoClXmA3AQgr5NQEHMBqMVFMNaIOayNRL/vhlH3RZwmhbQQUcAasrVVGz4EtjCu/3dfb/ID3PbT7uKAZ/MhcIC0vqRTo4W0IBIEAmEtFwCYqjW03bcmdwBYeoWgetUbrR8snrloiR2drpACf+rD4D9EvTVjIJu7HBV+781X752Czj9lwUZkTEgcPoNPp5Nv4oBRhCG6dd+1DkMz1JIhR1BAHJ7zwqO3fIRRM5tmDK5CoQKsSgOeBYBKFZULTqcB9r6Ni5KYmd3WKDUA0BlhNLM8EbT1QBXBU72aI5ZjUcVOxz7WLkQ8d37vsart/uA6RcPsxNSAtAXHDYNC1AEpf9s01kKwuBwGU7HgVt/1jtD1e60fgQigSe/j5bQp+KYpGB+H62jT7P8/ZypBIC8Dhcx8eY9wF015abhmnoAyJ5WSrKeNgKO9SHxnT/LSasJBim5lRjWBEIVeROInKL1qunybRawLgASdEy74qjaNNzJCgqEEYzBGvK0297mAFSHEIB6ebKDgc8J1ksmV8t29f1en6L5v6cxIK5iK6Xne/5jCTiFcTqVn/r/tWDPWwXnEPTVgIKUHU7ljASawKefIwDpMdRxRB+wFgD+RREDJABpwSzz2c0LfxczVjkVKwaYgtBBezu3SvX08d39P5uO3QKahXMQciourZRAGKZWar/YZ1xXRPe8wQr2AUK7TvbOVTZBXx4MBECRnConUBSFEXT6mf/TK+/qmzAF/0UBOPqBZYF52HrTFCw2LH5G8UCzJEko5nZqmRnPh/uCXmpnVpDTsIPPwKApOaSA2QLDLSHf97iPx0tpISLfz7bl4iFfsUsnj+HZWEeOYDCDnDmCvZkEgedcCjxGseIhBYt3vx049HwMLRh8gA9gh2MoH9ABqKJzxf0McO7XlSAU4HzhYYFq+5D7hwBu/98OQLlIBCKnW39SlXNY+nqeiq2dkQg+gnGPb9/ZpT0lq6MV5D96gLCwgDmCwbdnCvZmCgY/dxy47xxg5SWuUjigYPHFbwA+fyGwfr2rXrMvPB+vp3L3GHCgi9JOHQCkRVPppeUBigXLFymyejYTB4YsgfA20ofRAlYB0FfAlvQqP0/TsX5PLOB5DNu471cmIwiBaRww/F01J+mz2pqChxUMZvpJlmBv3iTocsW4dzewfhkGFix+2febXDAeJO/YEILBB7pU1g8LQFo98QASVGYNQ6DZfEG3fnEqrgLhbf/HV15anbkFNCvohWSl9XPQ2XTM/2s3I4DwPIZwBEDfgitH0Ek6N6x+u/iD7T4g/YdBBYPpWHEaHlqwNw+AQa4Yj54JrJO+aQDB4pt+oCAyYvOPEIQDCgYfeF/9U3AbAMX7ItAlVtAspKZdz5SOlvA2pstxjES3wJ+92NgAGK2gwi78QoVfEhBeQACqNNP1RdoA18kKdgDhxkUI/zKIYDCnqyzB3jwAJnLFOEIW7QEEi1/1Y21ywVglCAcQDD5/Efj7M4CVrZ5AKlkhxeQUaxBI4nvFzxf8IfCVC4HV7cC6ZEX5nen3VX1vAGLZq8ysrvHY+QBwbGfI2E6JpLvdX+ksthpUvQrmX/sVDGZVUJZgb17vJHLFeGQcmCdVb5+Cxd/5xjZ6QzzMLOQBBIOfTV2Ps4HFHQ7CLQUQmUrV0rgKJMsCjsxGAqTn/hzw0EXA4tnAyg5gbTYBorKkUyLnkB9YVhTxu+kT13iccwtwdBewPAus+b2ar9xJAafqfgMQO4dh+J9+BHe5gqZZZzYok1JJUcpaR6bp93P+W/N6p0KuGIemgEWKgPQhWPxdP7NBLhiHKYHUp2DwpZ8rLOD8tmJQVplOLxAqmbRKC6EDYC7/CeCRPcCx3cDSrsISrs04CPm9ArZk55UvKAspYLqPaPdR4/H0g8DRHcDyVr/X6VabLHk2PhjpPVZY7d5xwF6CwS9y/4LbbVyQsEKIufGiKe0p2JvXOx3kinF0GjhOQY+oNRtljji9TQPf/fOV9IZY4Gq4D8Hgy/4W+Oo2YG5bUUy04vUcLCqSJVRWszJbNgxSmMau+q/Ao2cBR88EjtOqbgNWWaTkIFz3YiWrF4nAjtN0nBZrJnU+/8PA3CxwfMYB6LUra3oglL0tps6wlVha5rLiqd9AdDfB4Je6U0s/0BXTDYh80Sr2FOzNA2AXuWIszABL1JaKWq1R+nwGeM17OsoFY5XTVw/B4Cv+Djg0C8xvLYqJCECzgsxmZlq9T8e0XGUyaUizavPtxoFr/zvw2BnA0Z3A8e2FVV3x6c4sqwObckeyhiXAowUSADhD1XhceDMwx37lvU4XxVN2n3rJIocygkr/Vbs7fe+EdBLcfaXXQ3IPWIrpBB6XlnwpR76jYG9e7/SQKzarxM7qJFj8mg8UarMV9IZ4gvNDD8HgKx8HDs8A8zMFAFnPYQPDl0Co2g4fpDZLqKCxT0/7fhJ4fCdwbFvhRiwRgJruCOwUgCpeCvUjZmEFxhfk9W969kW/B8xvKQqnVgg+B6CB0MsI7P70AHgmd2n1NQ0rv7FvALIlVYK73MnQCDLThSGZoDpuP7uCeuX5n8zroB5yxThGnQ0CgyBMxY63Aq/5aBHG6EBviDlOLV0Eg1+0AByZLgbl+HRxnZXJoqqttA4ODovlJZVuSjTQFtq+NwNPbHMAzramdVpVs6wEoPtdNg37wJfvsYiJP9NFqvHY+7vAwjSwxAeNxVO8T6aNVRRRlT6hHrJ0Ovaw0WDJCKng7g86APvNB9wg2JvXO33IFWOBgn8EIf2nRLD4tbe1+AU7yAWbZeskGHwVdd2mgAUCcNKnJgLQrZ/V9/Jnn5JUYmnAE3hCmv3+t8AWQfSzyPK/POOgJgDdsgqA5nfJAvLdLV+bz0kK4RqPZ3wQWJxyAPqDVhZQyQr7gyaXI9axWCFVAGLvRUhV46PgLnUWBs0HbBPszeudPuWKsTRZAJDTo8l8ui/42juL5veQC7ZpsEow+OrZQlqVVuH4FLA8WVyDAOTAmHUQCAWQkOlsQAwDt/9/AE8SgPQpNa07+AhAA6HLXbb5Xr4IaAMfv/eGvP5NzyYA7UGjBWTWjh40v9fSyscHLtaxhJWxFVsNNAXH1khw983+DYPmA5aCvXkdNIBccemfceooAfhAAcA+6A2xLuAGucxrzgKOMexDfV9OwbS2BB/BEoqLSrBoYGgJ3E8qLcIEsP/ngCPuUy7S13L3wb6PU56/m/Xj4Ps0TKCXQA6AXuNeZY3HMz5QANAeND1kwcKXlj6wOZQ+b7R+Pi0PD0DeFAfk590CKg8qncfoFzIRVWVqfFfBhgn25vXOAHLFWCDbvPstBsJZ4LUPt+jdesgFg+qVptWq11bg2gtgfuLiRAAgQeg+oEmsOujsXb5SsAoCIN/3vx04OlNM6Yv0tdx1MKvK7/TFjVmeCD4HQQQhf159eV7/pmc/kwCcKABoeYvR0oept7SEoZQ0Tr1lPuPQFlAtO0nyAcWhpzw/FSjFzGjLx+RGvxzoSeC1hwsA9klvaFN5FAy+9mJgnhaQ0qqagglADo4c9AhCDpJPl5ZommQ8738HcGw6AJBW1VecZv0cePwOY0/wl1lAD/WUCx0mMlDLr8bjmb+Dwp3x4nkDYbD0thIO5aNtfmDi/xGEeRawxhs7Vb/q2huABQJwAlhyy2cC0xoggjAAUCWWAkksOiIY978TmOOqeqqwqAx3WGhHK06n7TDwOcAV/iipPAKjwgrZm2o8nkUA0gKmAHTrp+o9MTrEYvq44o9pZIOtgmu8mafCV72YAKT/RwAy5OPOuVlAAk9Oule6xQRTWUKlWtkU/IvAHAHti5oIwDK841ZPFtCmdr0U8PaC9hVultd4CIC8P2Ztt/m5/qC11TJXlJDGGpfGAmYODgFoCxACkLpuWh3KCgqE8gNVZK4KtxgjJAB/2X1Krao1rfN7CWZf3LSBT4uAEIyWBVpipL7GgwA0AW25GbGENBTRx3rm1M2w39mmrFVwjTd1Kn+VAZALEE5LtIDyMWUBvbLNLGHgd5H/V07BDp7r3uU+Jadgn3ptxekA5MBri0/Wp4wzBjDbCnkMWMqVpE8GJwLQqvfc0pqbkVj5aNk7gbCxgJno30cAjntowtXNaZ1suvSKNhsYTcVKmw9F5xGE+94dfEoP+JYhD/8OC8eIPUsUHokVVKB78XszbzAF4Pvd//PCKVGIpOAr78mn4DZOm8YC1jco+w6EFTDDPJqeCEBZBa5GffVbhmQ8DtZW5TYOvPhXip0GTuu22lTMLSw+aAVl9QhEWjurI/aQiLJkTMLsX9R3r/ymZ73fp1+37OU9hunXSkdl7T3QrhKCtlCM59k2i5CMMSIAGdqxEIwrmptzTsCEut5yilKoJLAcxCq3fe8tLCDBFwO+tKjyuxSCMdYEXoeDrHcHvu0tTwLzmwHA4N/Gh6zNCqqeOSxC2lb8tQSiMwbuqXIqAcjFh2JjBKGJyShQG6ygVbfJegULWBYcMR3rvb6oCRaQwFPgl1M5rR7/JtBZOIZWx/0+s4QeY5z/1/X2tFnAxPpFELaVkdLN8MWGVr4pCBsfMHN8bmTKfCjZ0Ncp456/x58zLzfw6Qf3ABd8pUgEYmqk5bGyek06IQl1bkXScnlN/u8L24Gdx1qVq91KQvrpgwaAAw9p+wnXPw1YjyWMGtDo2ASOFGMU7SIEUzdYD34vMPmXwLbHgdkFYAtlGiim6DpxJtvq9LtlVr/aWKEB8pUXAOOPAFPzwBTZ9r04vdQ9Ts4pAZ3cd+yHxgfMAOH+vcA69/9Uxijmz/AerYpdar1lNSMYzV+vWY/34I8DY58Gph8Bpo8A04vAFEFIknIHohGVR62QhFRSYjQE6qFri2z3iaPAhHNNlxKwArI0Q1IAxwfReacbC5gBPp66/5ICgLKCtqnsrKKlrFZUFPKOr7osMTtdsxzqQRZ93Q1MPARMPllohUxRqkEK6gShOP0S+dY2hlRv99y+ovRi7IiTnTvLqmg6xDPYpqAUgRgsoR7MxgJmgHD/c4E1FXu7FRRbvEgd7evXWlbPpp9EgUjiJpwe6zwOMlvpAWCMVusJYPIYMOlSDZRpoGiNxKzbdIQlXONMWJbGtw4svdgz3El47nzTRvPrrKptAJT6ZrzfintvAJgx4vsvdQvIXK5VYF3sUZxmJUvgA1FOvwF8spKyBtM1y6EepI4LqVMedbEaTp0EIKdPKh5FqYYqSxgo2jgFr13j6XXHnOiSZOeBVSvyC8qC2r05FVvVw9cAMAOA178AWPMp2LJaaekiCPXExwHw660n1oB/niGQazwOkkSepbJ/72I1x4CJ+cJ6lYI1riccrVicUuVSmIW82pkwnHHVOKbFsOozQGkFkwewnBES37ABYMaAX39ZAUCCb82nIlo+40p2gNnvsoKunxH1xGwA/LOzdQOQJPIuHzV2GBg7Cow7AI0l33XfjOsv6oVodes6ISbBsAZMX+kJxU56KY7pkmFVhOciuvTzSt05v0+ryuT/9gDrZNe4wPMsI7VJP3GcP7gUOOdvgL1rRYJ0ZI5IV3hV4/wrGYPPU3/AiRhYusy2K7mU999P+z90ObD7LuBZK0Xdkeq9NSX2+o4HLwfWlopFCC0fgciBMtAFC8CGrYXVoVjnU2G7rTXrzh4kfRzLY1kyGwBoeiGcPiXb5eAzdXWnazPCSScb4j3xfmav8Cx2p50lAMW0VXINitCogl2r9H2dcctWwQxQsn6ZTBbMNtcgdKIbiZj51VcBk38CXPxoQcfCUg8pjcYgZScw/momACnXyr4leBhs5QaBTHpf7X8dMPYJYO8XgAv9e8QJlAZZq8D4xSuANYKPJQn0AR2AHKy1MACKe9nfFI6IEqduEWoHIJ9wlsVKLekoMCa9EAegSTYQeM4TXco2SEMkAHEbBZoj4bbYtdyCVrFqGXgTSxgXYTZeHLi9AMjEQRCVUXP/n4KUaaT8vVTi+Rtg7GPAuYcAWlMCgUVkQfJ2Q12yBvPXMwHImhDWwf81imsTiLSEvHZkr+jY/p9CQRD4p8DOBwteItai05qn31FFdfLlFxYWgCDUIkRkj/TxbCEi/89jfPZ3X2VqYSJQbmUNQY3HQT7hbv2sLoerVwKQHNEEoCsm8R4MhPRjXUGzVEIKIoY7yaEYuY4dgGb5RXruoSgtSCLLarkICQ9f6QNykGjFdjsIBaI4kGlt8W+Rg5g0HJ8qAp47nihAzFpuWtPIMBZJlASILvR6fQ0DCVbJCkJOJCqnk4pGpb99tZ8MopyiKDX7WWDiwYKXiEQOehCrgKh+eJQ+EQHo1Lby/zRlyf8TIbf9XS5ftIb8I92YugH4ay2pLusorl7dAoonWtMwQSTdOFuQSLTGHyIC8kxSIQuA4hwU2WUAoO4/grBcDbsfWElSzg+JCoYDoEGM1ixSkHzgF/wG7y8sIa3J7JPAGWuFJSQIaU01iJHUiYP4e33BrPOHmG/JMaOfTZVYRhwGav87vWKPJ9/rSH4IOGO5sITqg/ggxXs4TOaBAECbeoOsgfl+DrQShFqcEIhyyt0MbMusEkx76iAZXKM8BvXiZAGlF+KaIbaadYpem4aDgpJZQz6YJABV5VcHAJZ0v4FxX6KG5UpYs0KnqjhRuagEVgPglYAl9ciHf8mdUrJh0Qx9vkDBzBywfbkYQIGwahA/kglATsHsDzKA0BATiPyZ4NEDwIeoa/uFYKKXL2f24nQoIgd9R3yQCMTFqwIAfdBWI7+yB5ZLECYLETd85YJl+2YAUNosLIel/xYlu4Jsl6bhNhD6it4WJCvA2Zc4Gxo73RcgJeOqFmGR6rcChLYACyGojmEYdj59KnZ+tIQRhH9IvWA2hiREjDeRI9Cly7fMF3EtWRFawhQIf5IJwE56wdTIYdt7tp9ys1K8JnoJvod9Wn682PNkP4hUy1ndWgstAtBDMLYN5/6PAc5DGNoF4SrZfN+4+IhT8jqwg2Cp8ThIJ5vfSWBXAVCrWN9SMxDK+skaOvhoAc8me654pmUB3f0wyt+E8FyRAGmPlOEoiSD2qgvmAKoOm52fAuiTDHSyIRxx+lI0QxxADubfF5vffMmSajrWlP7nmZ3dSy+4r/ZzAUEHnQ8R70HsXlK+PgJsW68G4XYGZj0EY2EYATCAT6tAhmE0DXcC4faapcwMgAIfLb0kuzT9Qmw5uwAAIABJREFUSi+EfeALkSrpBovbrQDnkm8wAo8/E3i+CCsZ98NCpAp8cUekZyBavI4ET/TnaAk/RQCyAXy6uNSPA0i+wMeB6ePA5HFgZq2wpNGK3FUDAHmv3fSCe7afX8CB4UNEEOolVi/3obastNwJ9cO5BOBKEQMsAcifHWzRAigWWAlCn5K2bQYAOe1KMjTIR2kRUhKVS7IrLia0v+3xwHMZMCbYNP0KfG79zAqK5DxOvyEuWu6VD5KSHy2YAEQAfpaRdl5UkuUctIpBnCIIl4psD03FtIIP1ADAlBuJM47EqqUX3LX9kSBQcuuyftK78xUkHyQ+RLqHZ3Fv1KcgLj5kAQ1s0Qo6IA1nHhNLQzA8ZxvBXuNx8DcS5UYpNnoYxsCnUIqvZo0F3wPTMa7Hv53HOJVbS/l+5bumX7d+5WLE44hxIRJB2NMCqj9ixwuE90svWCaIA6bAp959EKeWChAyA0PTOV2unGMQveCO7bfqHbcS4rJR7Ewqnw5AWhLuImg2uFQAXAVs8RGmntW4+g2hB3P79L/EJ9zGvqrxOPibiVihAOgrWQOf/EBfBcsPNBBqW9Hv6zzGqFzmoXz3B9AePgXiq6bgiv4YOB9QHS8AfpkAFMMjrWAcQA0iO9XJiQyAnos2vV7ESHOOQfWCO7Zf7F40mZFQScRKAYBaSU6vAVcTgN7xXHiUFpDTMK2dFh56912BTiDcvpkATIXzCL4g3WXTZ4jpGfjoF/oihL+fx+0yWUABLwIwtYKKIabgCzHQvi2ggBKn0McEQDaKT5cGkIOo6SuyYzEfjQB0EM5nZgAPoxe8of3sgSqCQM3jkdFLvpRvR13+7UVRuhUFSavNO6otwp88ZZ3+t4M6HLtch6OT9AG/q9cmtf//gV1JDYcnQ2zY6/YakfSrU+Pg1M45NqPt3IEtoM7WFHokyrWKkooglCMWLYjiUXMtK3g8Uzd1WL3gDe3vRRCoUEYCwGtYFxxqgA2E/jI20F5hhmQod98BHNnlxOTig1aGiDanO21yV4DygWuB8YeB6fnC9WEtiKVVKeE0ZGiXWczeJoWMIig5a9V5DA1ANoKDeDylZ9NSXxyAsiKawrQqmCv2HVf5e8aRoxfc1n7xs+khItAUvojvyWryxVcWJZksVSyZoQRA3dcAoHzax4Gj2wtu6FVKM7gMgti02jbV476oUJJs1j/AbA1mQ3Pm8eTRsoZDtR+xZKCiEKmMXTIeXHPGdhYArX8FwG4DGMEnAHIK4yvT58nWC2b73cexaZgWWaEKgU1gjNbPP7PvOYGsUSBkv3hBtmRWNzxjTk9RWktvxp6POj0vARjY9sWkFel8RWxegjIF4RjwAOnZWMPBTGjqvHmszxJOBUD3xyznL2bqROvoP3N3q84jG4C7M/PpcvMBef0cvV9k6hXv+2Yno5QfGArRbaCC0mWv2YtF3ecerNDhkNZIIsXQRv5dlTtGADJSz2gEE1EJQM//026HdIEZLC8B6A0tk0g1Ja8DuzJdphS82QBEZj5dbj7gxZN5er/IZI+67pscgE7QaDOUMyC0Wb8+gXjuR4F5J6YsaXnFhBoAGEVvUhb60jISgCQnoh/OLBgvIrL8v7DdFkEYM5dtNg97tvz5zJqzdfIBmJlPl5sP+DJP5xtW7xffnzeh7H+Z+3+RpkyWT1YxuURJYVtx6T0fCTocouQV85VkHRIGegEuEv/YKpkA/JceVmL8kv6t5/9pu62tfiPWcFQVEa0DZ9WcLJEPwMx8uvfnjT9IgZyj94t/ldeA/S9tMaGa9SNdmsIxbvVscVJ1GScoMt4UPwhAsmMZ0aXzQBsvdGRBjQz0FUpEJRAJQOq4KAnBdz+sfiPJ3bOYn8fsykyVWMfiN3BOzckS+QDMzKe7OW/88aqQzsfE5kH1fvGjeQ0wADodmVGwOeiMsUqHrGOnS4UFy9P/wAEojkEnI+IqOIJQNLgpCXhcmLAtD/D+kgQE235L93tj+YBqgTX9BiCeW/NedT4AmQ+YkU/3sbzxBymQuZhm8g1T+QbV+wWFdjKO/Te2mEFNlCb6gPF708VJ1TXHgKd91GnZpDfi1k/gM2vqU3DUnCuBmNQe3P9vw6pe229KOvB0K1k+ZS+rnrfM2AlA3JMZtah/EZKZT3drxuDz1O/yxAwu9JgJxr3lQfR+8aa8Buy/wdWQZAVl+ZzCrG3q9c/YrkmHy3IRYryAAqAkEBIlopJxNNUbER+fA/H+/+AAdP9PmS9dazicJybm7mlB8nR2dI1HvgVkOlZGPt2nM29GCamcGZjAwlQ+vvrV+8X/zGsAAUiLVPp/wd+zaTMFWw+/kAA0GQQnpCw5mDsAMIrcRB5mC/+MAffTwgfwKY2KfmCZ6ZIkUShrxXxBX4yYaV8Hzmcn13jUA8CMfDqWYeQcSkhVOl8U6uxH7xekrsg49h8oiCENgC5TUG5vKxxT8f2aRtOtcAKQ1s8soPuOVUIwpchNlEEIOyNSIrrvv3hwnckWIZPZsnbcDyzTpvg3lU8mpZQqozyfK74aj3wAKh1LgrsD5tMxiz/nkGD1sHq/YNFOxkEAcuW7oqmXlisuQOT7VV2jwi/kTgj1RkoZhBje8Z83SCAEEJZW0C3gff8tADCt4VASaWIBK0HI9q8BF5yUAMzIp8tNx5Jg9bB6v/jdDPSRns0BWIZeUitIo9IhHmhXTvzCPQddccnZ76U1V/IvC4SBCFyg26DFNg7c++Mhhb6qiCikT7WVUmr6lYn2nRKyrdZ51GMBlZIc07GUBdMjny6XCiUmpA6j94vMZbgBMFo552pu27PXAqXTyAUQcitOQjAm9xX0N9pIwIPmSCmH5QuPqER0L4kDYgp9zOUL6fYxkbZcFceyAreAF3GlV+NRDwAz8uksnT3jiILVSmpWNlhMze+k94vMZfgGAPJeHDjpCrgM01Tdry9OzvmYAzAqLVWIwEShwzbRwwSEn+MqP6bQK5tZlWyhjCCCsC19Xv7gOnBRbgp7cu/5AOyVjqVMmA75dJZ9nHF0yohWNlhMxKnS+0XmMtwAmFq4imnYbrEqNJPc+9kfd62RKh0On8qV9hXZ9askEPgAfI56ziocUgVbzGT28lEtRMoKtg7lBHtznfZNA+CQ+XQWM8k4uglWK/NLYKzS+8U9GReXD0g/Tyvh4Ne17Yb4Zbr6g6y7/aNWcoPpjKRTsJIags5IJwkEAv6en05S6GUBfRWsUExZyVZVQCQwrgN7Wfdd41GPBczIp8ODeXfTSbBa6YYxlY8/p3q/udc3C+jTbtvqt2oadnB2m4oNgMn0W0p+hYWHWbwg9yU/0Kb9EIy+5y2hiCit4UgKyTeAkN8Valk4Le/ldlONRz4AWWBRM6fdIPfHstw/G+SE5rMnVQ/kA5AkLHS0ak7V7reXfhgACaBqDtD3e/nmc5k9kA/A80JReq+U38zGVp3ObJo/BvAOD3dtwiWar9zEHsgHIGlFubqSx7+Jja36anLLcDvvgwA+NDpDfILv+qlzuXwAXuSjrkKemlO2e3U1uWUYnL8dwB/5e2apca9LNv+vsQfyAUheX4VguB+mzIsaG9ntqxhF4Xbe3QD+n7/uHLAW9wQ1tblMRQ/UA0CaHC7plXEh+q4T0OWcfhleYTSHBK0EH/mi+fcRuKQn4I6fWpeoB4AevCz3HOOm9yb3F5mBlZBNclYCj1aRfyfrbgPCTR6AzK+vD4CyglX7jpmN7HY66d1E0ctdIrEEE4wEIMlam+Pk7YF6AMj7EwAVbU82vTerCwhAXopJN9zVI+AYrOeULLZgErY2x8nZA/kAJGWr0naUWdFpy2cT+oCWjpdjLFxE5UzYIBBpEUX5nLnlvAktb76SPVAfAOUHpiAMm96bsVtCAMaKALICMyxDq6cXfycA+b/mOLl6oF4AiqBRIEzBp7/X2Af0+fi1XIioMIlAI+AIPIGPmeROWV3j1Zuvyu2B+gHoFfZiDS2lC0LiY52WUADkQoTTMH1BFSYRdHoRfKSu5v9qrizMHYPT+vx6ARhSuDcAzzmDo5ZGHT1PAKYMwQxME2jiSo/gEwBrrq+u41ZOy++oD4BaCcsXTPiSI3ey8s4KGoG8QwCMFM+0ggQhLR0BF19SXuD/ayakz7uR0/TsMcxg3SjfqWNA0hsrga/ojaq/8WPcC+YIk4Ke4CMSuB2XVht1Oj8zIfXlU8BtU8DhmYRXWdfrdF1fgr3+S8At48CD04DVjXQSDO70PTUnaJ5uOCwsIIFHSSFy1pKPWCDsZxCpw8UVgKSPxLXM937OzxxAljzcPAbcswU4Qh4V3UN8mKoeKm/bu78IfKJQa8VD48CylHQiL3O3/qg5Rf30BKACMtJXjXKQcfBSK8Dfqc3KVCwuN2VFGRnm/yKZtq4Re5ifyQQgM2A+BeB3GHaZBo5MAIue0l7Kt3cC4xhw+5eL7TuCkJk1jBtyerbUfYG5ExjZ/pqrxE5fAOrOq5SmowVIrRp1IyT2R6+fg0bgVYG4CsyZe2UsaiOGKXr4Sfp9k8CxCYAFSKyvXeY1o1BxQux91yMtfsHPutgnnyUuUvhc0ZsgUXib+nVkq6+ZKaABIHsgVZnuwD9sVo66rrR4ImdhLGSQ8zPL/JgBQxeU1ouWkO9PTgDzbgmXxrzMkatl3keivfG5x4r4IRcz5BfkO5vEZ0kgpIfBZ8yKjlL17syy0tMNcOn9dl4Fy6dLFabj1Mpvow9Ify+I4Nlo9Xt+ZqU9VdJpqZh4QDDyxUyYOYJwHDg+DhgI/WUVZl7aSEt93+GO9Ia2iuZKOfA7lhp9JpvAVy61w2mOwO5hmCgMHC1H9O24gu6UD9jP+ZmbtLRaSsei9SL4XDPbAEh/kGQ/pSUcc0lbApFWb67lQUhpVnLBsoKqqZclFMmUtrxPcwxl3X7vOCAtYLSCcugFQmqhdssH7HU+RznjiOlYXA8wqkOfkItTAom+oKygca4ES8jY+N3z7fSG4hfUtp3ihUHruVSsFy1iRvNP+1N7A5BdJACmVpAgZPhGOyCigEjlPLudn7kvFtOxuB4g6OjD8UWLRkCZFRwrLCEXJQQhp2K+37lQeBCRX1A7KPQto1prFEmSYn2mB9EAsO+kYfk8KQhZF8yjVz5gp/MztyOUjiW9bCUhEBhKRCCgSis45uQ/PhX/xfFWMgOnWu2gxB0TF/o0kEZ/kCDM1Ts+3RHYnwVUL6XhDFrAswfIB6w6P1MrTulY0sum1VICglKwCEACqvQFCUK3gHcsFQCM/ILayqP1k9JshVqrncMalOYYvgcGAyCvIwuod8YBJQmZpmGJeyRwkGw4n8jJOJQNw3idLFhMRNB0SgASTJyKoy/4ieXCeFfJBUeV2SoAclFyR0bbm1OHTUiN0/DTAwD7zQeM52dqj8VsGEkVE2jKetG7AEhQ0frJAv6RC0trC1skl+IWlNinGLbSaZg7Mc0xfA8MbgF1LQV1z08A2G8+oM7PVF9Ms2GUE0gQyp+Lwu2yagLgR9ZaYpkSypQ6a6Q2DCqzpkvietXIFdoZfuieGmcOD0DeP0HEbBhNwYPmA/L8zJQsATAKnguEqS+XTqkE4YfWWwCUFZTksYAYwZfIBeN9Tw0cjOwu8gDIZqsoSSvhEeQDiiGYFoyWiSDRypWgi69UP5sc5fIcquSCNeXqe2X9ZAHfM7Khe2pcOB+AT41+aO5iRD3QAHBEHd9ctuiBBoANEkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cvAFgg4GR9kADwJF2f3PxBoANBkbaAw0AR9r9zcUbADYYGGkPNAAcafc3F28A2GBgpD3QAHCk3d9cfOxqYJ2au9RdPtdp/khoEOlglDYT39V1PzQFXLsMXAlgt9PCxJKPbufyf8/KHIPfBPAZABf79Xc5XQ0ZQ1Q7360NbxoHrlsDvs5ZRsgo0une06by6X1mZvtP99PNAp4F4LsBXA5gjw8EGTeqaGF4QhzQF80CX7cAvGIdeDYAfhdZ2sTKUcVrpE7nd31N5gj8e2dIo2osk7NZpMdK0Z19tv+bJ4F9K8D1ACj8yfNSikHeg+5Z969m57Y/8/ZP+dPLKZhP/rcA+AYAF7g1oRUhEMUzFMt6eSJfX78b2DkPfM0i8GIAX+uWlAMppreUUErn8p2gzTl+2flg/sDbTkvIOik+CP20//mzwAXzwDcCuNTPJeFXpEpM6QEjIHm/zTF8D7T5gATYNQCe69aAloRTGulfBESBSYNyxR5g/Bhw7hKwZwl4vk9LnM5JmsBzUyDGAX3B8G23Mz/g9BuUa/0IiutfMkj7zwKmngAuXSvOpUvAWYBtF4BTnspIj/O8zPaf7qdvWITw6eZA0JLQEhKEGgxZhUj/dz3NzSKwbR44exnYvVKcy+mM5Km0JhxInUtrGkmzCPicg3W5LMGkQiZZTm9xS9Z3+4m2o8C5c4X15pTKW2Lb+fCx7WLtjYxzqiql29Icw/dA5SqYf6RTTilg+lYCIXmICKQ4IK9wxfSJY8AZK8CuFWDnanEua9ZTAMsaCog3Dt92O/MvnRGBtGwkqKRmMEkqCaa+2k+0LQDTh4rP88UHj74kF1WaATo9QHQ7mmP4HugYhtEKj4PB6ZQ+FS0hQahpldPya1kXTOqNY8DscgG+HavAttUCvBxInitrkgL4lcO33c7spBdM3kAuSnq2nx9gQfAh4JyVwvrxwel2z3p4aMlzH6DM2z/lT+8aB+Q/OT4EEqckWQSBkGD6EQKQnDCLwBSnYgcf32fXioGUFawC4esyu7CXXnDP9tOCsyD4KLB1rmgvX7zfbu2WG/Jtme0/3U/vKxBNAMoi0KcjkATCN3HOEr3UAjDrwOP71rXixYEkeKMFlSX8ocwR6KUXTJ7AaNE2tF8WfA4Ye7Kw1mwvX/yZn+eKnvcrfzC6IK/ObP/pfnpfAGQnySoISBqUXyAASS1AK0JfagWYcRDOrAF66TxZQU7jBOEbM0egH71gcgXSFZAV54NQtj9YcNIpbONCyh8Ygi8CVospApDuB63g92W2/3Q/vW8AsqM4gLIKBBIH8bcJwMCNMX68BTqBb8s6sGWtsIA6jwDk662ZI9CvXjA5A6NVa2t/IAicnC/aGV+8T74IQPm/AmGuBc+8/VP+9IEAyLslAKMV/LgAyIUInfnjwPQqMOOgI/DstQ5Mr7UAqMF8V2YXDqoXXNl+EQQ6N9v29aKdesUpWJZbAPyPme0/3U8fGIDssDid/pUASCvCaXgJmFguAEfgEXT27gDkuwaUg/nbmSMwjF7whvbLhSDL5TwwvdRqo9oqHzACkCB8U2b7T/fThwIgO01T1IMCoAZxGRhbKoAXQUcQTjkI+a4B5e5FzjGsXvCG9gdqrLGFYrpVG/UuHzBOw2/LaXxzbh43DKeoJwlAHqLndSs4udoCoIBHQE45EPk3DuitmYOQoxdctp8+rFwIWsGFYiFFoLGNchcEQC6e+OJC5J2Z7T/dTx/aApYdJ37AyJK/DIwvFxYvWr0IwEn/H1Opco5sveDUhSAAF4HJpQJkWixp6k2n4IYfMGf0amDHev2I8+l4/UbvNw8Eozw72wJePOJ8und7EkKj9ztKGA1/7WwATo44n45pWI3e7/AAGPWZ2QBkYHCU+XTMfGGQmYIxjd7vqOE0+PXzATjifDrKtTZ6v4MP/MlyRj4AR5xPF+VaqZLJF1UzKdPV6P2eLDDr3I58AI44n07ZMARbo/d78gMubWE+AEecT8e9YOn2Uheu0fs9tUCYD8AR59MpG6bR+z21gKfW1gNAz4geRT5dTEZo9H5PPRDmAzBmRM8BJzqfLiYjSKKr0fs9dYBYDwBHmE9XtRfMsIz04aQZ1+j9npygrA+Akqs8wfl0BCCTWRq935MTYL1aVQ8Ao1zlAnAi8+kEQGZTNXq/vYb75Pt/fQAcUT5dBGCj93vyAaxXi+oDoFLyT3A+3Rcavd9eY3xS/z8fgCQX/LPR3SOzkon55jg1eyAfgD8M4NcAPD6aDmBtB1e4NMDNcer1QD4AbwbwxwDe4UvRE9wHZG1gNSXDLlwLNcep1QP5APxzzwj9IIAPnXhT5ORc5EYCA9HNcWr1QD4AmRH6FQBMTSZZH98ZmD5Bh5g1FopiNns1x6nTA/kAvAfAEwDudnI+EvQxPfkEzYfaCXRSBluQMB7YHKdGD+QDsBNBH/9+AkAobqTADGK7Inw1x8nfA/kA7EXQt8kgrGAGMfBxZ5Cv5ji5eyAfgL0I+r68uR0QmUFoBQU8vfNvzXHy9kA9AORoMw7CdGQCjoUZDwL4kv/+8OZ1gJhBIjGDgMh3vTavBc035/RAPgD7JegjODfhiMwgoqeJwNPPTaB6Ezq/hq+sB4AcXeXEP+ZhGVo9vRimIQD5v5oPAZCupgDI9wg8/qz/1Xz55usyeyAfgMMQ9GU2Op4eAchpOIJQQEz/VuPlm6/K7IH6AMjgGzdl6QtyX5jWjpQFevF3lq3xf6yhrOlIAUgQCojR8gmE+l9Nl2++JrMH6gEgR5UA5KYsc+AZmCbQCDi+IvgEQMob1XBEAHIajgBMLV+0kCdws6aGu3zqfkV9AGTwjftg3JRVVRAtHQEXX/wbAcoXP5d5CID8GoJKvqDAloKOoIz/y7x8c3pmD4zhaqwjRzCYyQg5gr2ZgsFTLweWr8XQgsXjbwLWrnNtMlKgNoLBmZAa7PTCAuYIBlMvlWQswwr2UlUw45jdDSx8HbD+Ctd+HVCwePKbgJV9aASDM8Yg59TWFDysYPBtmYK91IbNOHaPA/M7gUXKXA4hWDz79cA8+W0aweCMURj+1HYfcBjBYO54MMY3tGDv8I3nmWSHOzYOLJ0LLPGXAQWLz3oB8MQUsEa16kYwOG8whjh74yJkUMFgbsNlCfYO0epwissVY34bsHw2sEIRkAEEi/dcU0SP5qhF1ggG5w3GEGdXr4L5134Fg4kAjuDQgr1DtDqcUmZETwArZwAru4BVqsv0KVh8/o3F4v0QXZBGMDhvMIY4u3MYhv95Zh+Cu1xBcxuOU/HfeDIq5cv7FuwdotXhlCBXjOXZAnyrO4BV6in0IVh8wStLuWCsUAyvEQzOG5ABz+4eB+R/ewnu/kOP/3G/l4kJTERlljQtIot2e53/IwO2OPl4FLtcnCqAp9cahT56CBZf+LpSLhhz1N5qBIPzBmTAs/sLRHcTDKbiNHdBGGymOC/3hglEvgjAnoK9A7Y4+XgiV4zVWYDAs/etxaubYPFFP1QkLtCIP8neaASD8wZkwLP7AyC/tJNg8L/xLNBu+YBdBXsHbHEFAINcMVamgdWZAoRrfPdXm8KitLdmgYveWAq+2y7iMqfuRjA4b1AGOLt/APJLqwSD3+y5T1yI0AoSbAxMMzGV1o8/My2ro2DvAK2t+GgiV4zj4+3AIwDXtwBrVJeuECze+9aW4Dut4PxkIhYsdetGMDhvoDqcPRgA+SWp4O4veQ5Uv/mAGwR78+6rQq4Yq9PAOi2fA4/vBkKudKVU7VZw77uKvWFuZbtcMNb5v0YwOG9g+jx7cADyi6Pg7gccgIxlcA5TKhaD01yYKBmVFpBZMfx/m2Bvny3t8LGqoqTliZbVI+gMgHwnMAnCIFi897cLAAZ6QyzFzzSCwXkD1OPs4QDIL5XgLmk5JHk/SD5gKdibd38VcsVYGmuBTaAzEHLHgyCcaokB7/1IkUET5IKxwF5pBIPzBqbPs4cHIC/AaeqvPL9pmHxAE+zts6VdLCD/lcgVY3UyWD0Bj1ZwqgCggXA7sPfWAoAJvaEtZBrB4Lyx6efsPADyCtmCvf00s/NnOsgVY3m8BTRZPZuGBUACdArY+5lWDqGmYbIrLHEx0ggG5w1OH2fnA7CPizQfaXqgUw80AGywMdIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0BxoAjrT7m4s3AGwwMNIeaAA40u5vLt4AsMHASHugAeBIu7+5eAPABgMj7YEGgCPt/ubiDQAbDIy0B8ZYNMbkX+ZekpuIiOQrPar+xs889HJg6jZg5jAwvVZ8B+ll9PlO5/Fc/o+ECjnHfi8zYfkvM5ulmp4qJXVqx5deD4zfAkw/CGxdAZgoHfuh131QkaI5hu8Bs4Ds8B0AWLnIRGCBsFfn87JffDMwdjOw5R5g8giwZa34jnQQUwDo99wBfJ4TM7COiNdlaj2rA/jeV/vfDeATAP4UGH8I2Lrc6gc+SHqY4oMZ74VSKM0xfA+UUzB/oBUUCKMl6zSQ/PsXqZD5KQC/A0w/DEwcAcYXgYnVwppwADuBkefnCim90FmBWXwnK87Uen53BI8sbuwqaz9p5UgnQhBS+ZN1zE8Ak0utviCwq8DI8/nx5hi+Bzb4gJzKZE1SEFZZgS9/2pWR/gTAJ4HJQ8DEMWB8ARhfBsaWCwDquwQKvvNgHXvOcYVbPFJPkw+dDxC/W1Y4tWDpw/Rlgo4lo1T4/KxTihDNpJwj3/UiMLXemprjffC7eWpzDN8DlYsQDiKtVxzEqoHkyX9HRizW+nIgaQnvAiaeBCbmC0s4tgSMu2rMePAR9X252jXklaTFU108K0MHav/nvJ6ZxVVk9OI7GR2IZoGQNc/HgbHgIwqILIVujuF7oOMqWFawCoRxkfEIB5CWgkREBCNf9wMTc8A4QciBWyoGz16rwNgaML5eWKpctYZL3N+TWLX0gvtuP0HHk2n16JDyxXmVhfU0qywbJbr5GSuXKxA/sV5Y9UYWdnjwyS3qKKgarWA69Wg6fjQOIK0HadnIjPVFB+AiME4AuiUkCFnESyCSkmAuU7Cjm15wX+2X2ifBRn9A8mKcW2UFjULVQcgVDl80u40SYh763FfvquhLCxitoBYUsoJfjXKttByMq9CKcHn4sPuCbgXNJwyWkECcz5Q376UX3LNncZyQAAADEklEQVT9fFgIJs6lBBwtn3Tt6FpIz4RWnuQxPh2XIGzm4CwQ9hWIFgBTK0gQHiIAJddKq0ELQh+KL1qUR4MvSEsoENIKrgALHNiMox+94K7tl9qnnMio8MSf6SNwGpYVjCDk/Ju7isq496fCqX0BkDeqlWwKwic1gAQSpzGREnFgREz01eALLvvq2Kfi45m6cf3qBXdsfxRbJMho8dimqOhEK8cXQRr9QVpvPoDNMXQP9A3ACELFxPh+jACkP0fLIKFCCRRqKuPUdqjlC9o07JZwKVNHeBC94DQcZO0XAAkmgotAk9QYrR9f/BvByYfMSATDVMzwTXMM3QMDAVAgVHCZ7/MaQK4QZUHiNCbBQlqUw74YCb7gcmYkelC9YFlwvVv7RRAorTuBkECU9asCID9/x9B935zYzyKkqpfiNHxcA0gLQgvBAaPVkCqm3h2AtC5m/RyEqzw/4xhGL3hD++MmslgqCbgUfLKAcRrmTlBzDN0DA1tAXUlWcDm1IOIIJAjlT/Fd05lbFQFwjdtgGcewesFt7Rc/Gx8iWjUCjGCT1YvWT1MwgUqrf3NG45tTbcu0aximWx9xENcEQHGbcYAEwtSXSqY0gnCdgeuMI0cvuGx/FUGgFhwEYrR80QckWN+X0fjm1DwAWv8RgJFilJZBznz0pQg+AZAAlVWh1GvGka0XzB0cCQi30aSGVa9AF62fLOB7MhrfnJoPwPER59Px+o3e76mL5Kwp2G57xPl0kxc3er+nLvyKtLmhfUC78RHn081ONnq/pzcAR5xPR9mRRu/31IVgvgUccT4dNaobvd/TGYAjzqejumqj93s6A3DE+XRUg2VSCjdaGr3fUw+I+VPwiPPpqJjO8J1Nw43e7ymHwHoAKMFd7QErAeEE5NNJMb3R+z3lsGcNzgfgiPPpomJ6o/d76oGwPgCOKJ8uKqY3er+nKwBHmE+noqRG7/fUA199U/AI8+kEwEbv93QHoEhZTnA+nYqSGr3fBoAtaiqBUImdm5hPJwA2er+nKwBHnE+X1gUzSbnR+z11wPj/AeCpPDD3t7rvAAAAAElFTkSuQmCC";
			new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array(3), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([1, 0, 0]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([1, 0, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([1, 1, 0]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 1, 0]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]), new Float32Array([0, 0, 0]), new Float32Array([0, 0, 1]), new Float32Array([0, 1, 1]), new Float32Array([1, 1, 1]);
			new Float32Array(2), new Float32Array(2), new Float32Array([0, -.25, .25, -.125, .125, -.375, .375]), new Float32Array([0, 0]), new Float32Array([.25, -.25]), new Float32Array([-.25, .25]), new Float32Array([.125, -.125]), new Float32Array([-.125, .125]), new Uint8Array([0, 0]), new Uint8Array([3, 0]), new Uint8Array([0, 3]), new Uint8Array([3, 3]), new Uint8Array([1, 0]), new Uint8Array([4, 0]), new Uint8Array([1, 3]), new Uint8Array([4, 3]), new Uint8Array([0, 1]), new Uint8Array([3, 1]), new Uint8Array([0, 4]), new Uint8Array([3, 4]), new Uint8Array([1, 1]), new Uint8Array([4, 1]), new Uint8Array([1, 4]), new Uint8Array([4, 4]), new Uint8Array([0, 0]), new Uint8Array([1, 0]), new Uint8Array([0, 2]), new Uint8Array([1, 2]), new Uint8Array([2, 0]), new Uint8Array([3, 0]), new Uint8Array([2, 2]), new Uint8Array([3, 2]), new Uint8Array([0, 1]), new Uint8Array([1, 1]), new Uint8Array([0, 3]), new Uint8Array([1, 3]), new Uint8Array([2, 1]), new Uint8Array([3, 1]), new Uint8Array([2, 3]), new Uint8Array([3, 3]);
			new Map([
				[K(0, 0, 0, 0), new Float32Array([0, 0, 0, 0])],
				[K(0, 0, 0, 1), new Float32Array([0, 0, 0, 1])],
				[K(0, 0, 1, 0), new Float32Array([0, 0, 1, 0])],
				[K(0, 0, 1, 1), new Float32Array([0, 0, 1, 1])],
				[K(0, 1, 0, 0), new Float32Array([0, 1, 0, 0])],
				[K(0, 1, 0, 1), new Float32Array([0, 1, 0, 1])],
				[K(0, 1, 1, 0), new Float32Array([0, 1, 1, 0])],
				[K(0, 1, 1, 1), new Float32Array([0, 1, 1, 1])],
				[K(1, 0, 0, 0), new Float32Array([1, 0, 0, 0])],
				[K(1, 0, 0, 1), new Float32Array([1, 0, 0, 1])],
				[K(1, 0, 1, 0), new Float32Array([1, 0, 1, 0])],
				[K(1, 0, 1, 1), new Float32Array([1, 0, 1, 1])],
				[K(1, 1, 0, 0), new Float32Array([1, 1, 0, 0])],
				[K(1, 1, 0, 1), new Float32Array([1, 1, 0, 1])],
				[K(1, 1, 1, 0), new Float32Array([1, 1, 1, 0])],
				[K(1, 1, 1, 1), new Float32Array([1, 1, 1, 1])]
			]);

			function J(a, b, p) {
				return a + (b - a) * p
			}

			function K(t, e, n, r) {
				const a = J(t, e, .75),
					b = J(n, r, .75);
				return J(a, b, .875)
			}
			r.bb, r.bb, r.bb;
			var Z = n(218);
			class $ extends r.bb {
				constructor(t) {
					super(t), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register((function(t) {
						return new st(t)
					})), this.register((function(t) {
						return new ut(t)
					})), this.register((function(t) {
						return new pt(t)
					})), this.register((function(t) {
						return new at(t)
					})), this.register((function(t) {
						return new ot(t)
					})), this.register((function(t) {
						return new lt(t)
					})), this.register((function(t) {
						return new ct(t)
					})), this.register((function(t) {
						return new ht(t)
					})), this.register((function(t) {
						return new nt(t)
					})), this.register((function(t) {
						return new ft(t)
					}))
				}
				load(t, e, n, o) {
					const l = this;
					let c;
					c = "" !== this.resourcePath ? this.resourcePath : "" !== this.path ? this.path : r.cb.extractUrlBase(t), this.manager.itemStart(t);
					const h = function(e) {
							o ? o(e) : console.error(e), l.manager.itemError(t), l.manager.itemEnd(t)
						},
						d = new r.D(this.manager);
					d.setPath(this.path), d.setResponseType("arraybuffer"), d.setRequestHeader(this.requestHeader), d.setWithCredentials(this.withCredentials), d.load(t, (function(data) {
						try {
							l.parse(data, c, (function(n) {
								e(n), l.manager.itemEnd(t)
							}), h)
						} catch (t) {
							h(t)
						}
					}), n, h)
				}
				setDRACOLoader(t) {
					return this.dracoLoader = t, this
				}
				setDDSLoader() {
					throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
				}
				setKTX2Loader(t) {
					return this.ktx2Loader = t, this
				}
				setMeshoptDecoder(t) {
					return this.meshoptDecoder = t, this
				}
				register(t) {
					return -1 === this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.push(t), this
				}
				unregister(t) {
					return -1 !== this.pluginCallbacks.indexOf(t) && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(t), 1), this
				}
				parse(data, path, t, e) {
					let content;
					const n = {},
						o = {};
					if ("string" == typeof data) content = data;
					else {
						if (r.cb.decodeText(new Uint8Array(data, 0, 4)) === mt) {
							try {
								n[et.KHR_BINARY_GLTF] = new yt(data)
							} catch (t) {
								return void(e && e(t))
							}
							content = n[et.KHR_BINARY_GLTF].content
						} else content = r.cb.decodeText(new Uint8Array(data))
					}
					const l = JSON.parse(content);
					if (void 0 === l.asset || l.asset.version[0] < 2) return void(e && e(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.")));
					const c = new Jt(l, {
						path: path || this.resourcePath || "",
						crossOrigin: this.crossOrigin,
						requestHeader: this.requestHeader,
						manager: this.manager,
						ktx2Loader: this.ktx2Loader,
						meshoptDecoder: this.meshoptDecoder
					});
					c.fileLoader.setRequestHeader(this.requestHeader);
					for (let i = 0; i < this.pluginCallbacks.length; i++) {
						const t = this.pluginCallbacks[i](c);
						o[t.name] = t, n[t.name] = !0
					}
					if (l.extensionsUsed)
						for (let i = 0; i < l.extensionsUsed.length; ++i) {
							const t = l.extensionsUsed[i],
								e = l.extensionsRequired || [];
							switch (t) {
								case et.KHR_MATERIALS_UNLIT:
									n[t] = new it;
									break;
								case et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
									n[t] = new At;
									break;
								case et.KHR_DRACO_MESH_COMPRESSION:
									n[t] = new xt(l, this.dracoLoader);
									break;
								case et.KHR_TEXTURE_TRANSFORM:
									n[t] = new _t;
									break;
								case et.KHR_MESH_QUANTIZATION:
									n[t] = new bt;
									break;
								default:
									e.indexOf(t) >= 0 && void 0 === o[t] && console.warn('THREE.GLTFLoader: Unknown extension "' + t + '".')
							}
						}
					c.setExtensions(n), c.setPlugins(o), c.parse(t, e)
				}
				parseAsync(data, path) {
					const t = this;
					return new Promise((function(e, n) {
						t.parse(data, path, e, n)
					}))
				}
			}

			function tt() {
				let t = {};
				return {
					get: function(e) {
						return t[e]
					},
					add: function(e, object) {
						t[e] = object
					},
					remove: function(e) {
						delete t[e]
					},
					removeAll: function() {
						t = {}
					}
				}
			}
			const et = {
				KHR_BINARY_GLTF: "KHR_binary_glTF",
				KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
				KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
				KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
				KHR_MATERIALS_IOR: "KHR_materials_ior",
				KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: "KHR_materials_pbrSpecularGlossiness",
				KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
				KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
				KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
				KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
				KHR_MATERIALS_VOLUME: "KHR_materials_volume",
				KHR_TEXTURE_BASISU: "KHR_texture_basisu",
				KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
				KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
				EXT_TEXTURE_WEBP: "EXT_texture_webp",
				EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression"
			};
			class nt {
				constructor(t) {
					this.parser = t, this.name = et.KHR_LIGHTS_PUNCTUAL, this.cache = {
						refs: {},
						uses: {}
					}
				}
				_markDefs() {
					const t = this.parser,
						e = this.parser.json.nodes || [];
					for (let n = 0, r = e.length; n < r; n++) {
						const r = e[n];
						r.extensions && r.extensions[this.name] && void 0 !== r.extensions[this.name].light && t._addNodeRef(this.cache, r.extensions[this.name].light)
					}
				}
				_loadLight(t) {
					const e = this.parser,
						n = "light:" + t;
					let o = e.cache.get(n);
					if (o) return o;
					const l = e.json,
						c = ((l.extensions && l.extensions[this.name] || {}).lights || [])[t];
					let h;
					const d = new r.o(16777215);
					void 0 !== c.color && d.fromArray(c.color);
					const f = void 0 !== c.range ? c.range : 0;
					switch (c.type) {
						case "directional":
							h = new r.z(d), h.target.position.set(0, 0, -1), h.add(h.target);
							break;
						case "point":
							h = new r.Db(d), h.distance = f;
							break;
						case "spot":
							h = new r.Vb(d), h.distance = f, c.spot = c.spot || {}, c.spot.innerConeAngle = void 0 !== c.spot.innerConeAngle ? c.spot.innerConeAngle : 0, c.spot.outerConeAngle = void 0 !== c.spot.outerConeAngle ? c.spot.outerConeAngle : Math.PI / 4, h.angle = c.spot.outerConeAngle, h.penumbra = 1 - c.spot.innerConeAngle / c.spot.outerConeAngle, h.target.position.set(0, 0, -1), h.add(h.target);
							break;
						default:
							throw new Error("THREE.GLTFLoader: Unexpected light type: " + c.type)
					}
					return h.position.set(0, 0, 0), h.decay = 2, void 0 !== c.intensity && (h.intensity = c.intensity), h.name = e.createUniqueName(c.name || "light_" + t), o = Promise.resolve(h), e.cache.add(n, o), o
				}
				createNodeAttachment(t) {
					const e = this,
						n = this.parser,
						r = n.json.nodes[t],
						o = (r.extensions && r.extensions[this.name] || {}).light;
					return void 0 === o ? null : this._loadLight(o).then((function(t) {
						return n._getNodeRef(e.cache, o, t)
					}))
				}
			}
			class it {
				constructor() {
					this.name = et.KHR_MATERIALS_UNLIT
				}
				getMaterialType() {
					return r.kb
				}
				extendParams(t, e, n) {
					const o = [];
					t.color = new r.o(1, 1, 1), t.opacity = 1;
					const l = e.pbrMetallicRoughness;
					if (l) {
						if (Array.isArray(l.baseColorFactor)) {
							const e = l.baseColorFactor;
							t.color.fromArray(e), t.opacity = e[3]
						}
						void 0 !== l.baseColorTexture && o.push(n.assignTexture(t, "map", l.baseColorTexture))
					}
					return Promise.all(o)
				}
			}
			class st {
				constructor(t) {
					this.parser = t, this.name = et.KHR_MATERIALS_CLEARCOAT
				}
				getMaterialType(t) {
					const e = this.parser.json.materials[t];
					return e.extensions && e.extensions[this.name] ? r.ob : null
				}
				extendMaterialParams(t, e) {
					const n = this.parser,
						o = n.json.materials[t];
					if (!o.extensions || !o.extensions[this.name]) return Promise.resolve();
					const l = [],
						c = o.extensions[this.name];
					if (void 0 !== c.clearcoatFactor && (e.clearcoat = c.clearcoatFactor), void 0 !== c.clearcoatTexture && l.push(n.assignTexture(e, "clearcoatMap", c.clearcoatTexture)), void 0 !== c.clearcoatRoughnessFactor && (e.clearcoatRoughness = c.clearcoatRoughnessFactor), void 0 !== c.clearcoatRoughnessTexture && l.push(n.assignTexture(e, "clearcoatRoughnessMap", c.clearcoatRoughnessTexture)), void 0 !== c.clearcoatNormalTexture && (l.push(n.assignTexture(e, "clearcoatNormalMap", c.clearcoatNormalTexture)), void 0 !== c.clearcoatNormalTexture.scale)) {
						const t = c.clearcoatNormalTexture.scale;
						e.clearcoatNormalScale = new r.hc(t, t)
					}
					return Promise.all(l)
				}
			}
			class at {
				constructor(t) {
					this.parser = t, this.name = et.KHR_MATERIALS_SHEEN
				}
				getMaterialType(t) {
					const e = this.parser.json.materials[t];
					return e.extensions && e.extensions[this.name] ? r.ob : null
				}
				extendMaterialParams(t, e) {
					const n = this.parser,
						o = n.json.materials[t];
					if (!o.extensions || !o.extensions[this.name]) return Promise.resolve();
					const l = [];
					e.sheenColor = new r.o(0, 0, 0), e.sheenRoughness = 0, e.sheen = 1;
					const c = o.extensions[this.name];
					return void 0 !== c.sheenColorFactor && e.sheenColor.fromArray(c.sheenColorFactor), void 0 !== c.sheenRoughnessFactor && (e.sheenRoughness = c.sheenRoughnessFactor), void 0 !== c.sheenColorTexture && l.push(n.assignTexture(e, "sheenColorMap", c.sheenColorTexture)), void 0 !== c.sheenRoughnessTexture && l.push(n.assignTexture(e, "sheenRoughnessMap", c.sheenRoughnessTexture)), Promise.all(l)
				}
			}
			class ot {
				constructor(t) {
					this.parser = t, this.name = et.KHR_MATERIALS_TRANSMISSION
				}
				getMaterialType(t) {
					const e = this.parser.json.materials[t];
					return e.extensions && e.extensions[this.name] ? r.ob : null
				}
				extendMaterialParams(t, e) {
					const n = this.parser,
						r = n.json.materials[t];
					if (!r.extensions || !r.extensions[this.name]) return Promise.resolve();
					const o = [],
						l = r.extensions[this.name];
					return void 0 !== l.transmissionFactor && (e.transmission = l.transmissionFactor), void 0 !== l.transmissionTexture && o.push(n.assignTexture(e, "transmissionMap", l.transmissionTexture)), Promise.all(o)
				}
			}
			class lt {
				constructor(t) {
					this.parser = t, this.name = et.KHR_MATERIALS_VOLUME
				}
				getMaterialType(t) {
					const e = this.parser.json.materials[t];
					return e.extensions && e.extensions[this.name] ? r.ob : null
				}
				extendMaterialParams(t, e) {
					const n = this.parser,
						o = n.json.materials[t];
					if (!o.extensions || !o.extensions[this.name]) return Promise.resolve();
					const l = [],
						c = o.extensions[this.name];
					e.thickness = void 0 !== c.thicknessFactor ? c.thicknessFactor : 0, void 0 !== c.thicknessTexture && l.push(n.assignTexture(e, "thicknessMap", c.thicknessTexture)), e.attenuationDistance = c.attenuationDistance || 0;
					const h = c.attenuationColor || [1, 1, 1];
					return e.attenuationColor = new r.o(h[0], h[1], h[2]), Promise.all(l)
				}
			}
			class ct {
				constructor(t) {
					this.parser = t, this.name = et.KHR_MATERIALS_IOR
				}
				getMaterialType(t) {
					const e = this.parser.json.materials[t];
					return e.extensions && e.extensions[this.name] ? r.ob : null
				}
				extendMaterialParams(t, e) {
					const n = this.parser.json.materials[t];
					if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
					const r = n.extensions[this.name];
					return e.ior = void 0 !== r.ior ? r.ior : 1.5, Promise.resolve()
				}
			}
			class ht {
				constructor(t) {
					this.parser = t, this.name = et.KHR_MATERIALS_SPECULAR
				}
				getMaterialType(t) {
					const e = this.parser.json.materials[t];
					return e.extensions && e.extensions[this.name] ? r.ob : null
				}
				extendMaterialParams(t, e) {
					const n = this.parser,
						o = n.json.materials[t];
					if (!o.extensions || !o.extensions[this.name]) return Promise.resolve();
					const l = [],
						c = o.extensions[this.name];
					e.specularIntensity = void 0 !== c.specularFactor ? c.specularFactor : 1, void 0 !== c.specularTexture && l.push(n.assignTexture(e, "specularIntensityMap", c.specularTexture));
					const h = c.specularColorFactor || [1, 1, 1];
					return e.specularColor = new r.o(h[0], h[1], h[2]), void 0 !== c.specularColorTexture && l.push(n.assignTexture(e, "specularColorMap", c.specularColorTexture).then((function(t) {
						t.encoding = r.pc
					}))), Promise.all(l)
				}
			}
			class ut {
				constructor(t) {
					this.parser = t, this.name = et.KHR_TEXTURE_BASISU
				}
				loadTexture(t) {
					const e = this.parser,
						n = e.json,
						r = n.textures[t];
					if (!r.extensions || !r.extensions[this.name]) return null;
					const o = r.extensions[this.name],
						source = n.images[o.source],
						l = e.options.ktx2Loader;
					if (!l) {
						if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
						return null
					}
					return e.loadTextureImage(t, source, l)
				}
			}
			class pt {
				constructor(t) {
					this.parser = t, this.name = et.EXT_TEXTURE_WEBP, this.isSupported = null
				}
				loadTexture(t) {
					const e = this.name,
						n = this.parser,
						r = n.json,
						o = r.textures[t];
					if (!o.extensions || !o.extensions[e]) return null;
					const l = o.extensions[e],
						source = r.images[l.source];
					let c = n.textureLoader;
					if (source.uri) {
						const t = n.options.manager.getHandler(source.uri);
						null !== t && (c = t)
					}
					return this.detectSupport().then((function(o) {
						if (o) return n.loadTextureImage(t, source, c);
						if (r.extensionsRequired && r.extensionsRequired.indexOf(e) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
						return n.loadTexture(t)
					}))
				}
				detectSupport() {
					return this.isSupported || (this.isSupported = new Promise((function(t) {
						const image = new Image;
						image.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", image.onload = image.onerror = function() {
							t(1 === image.height)
						}
					}))), this.isSupported
				}
			}
			class ft {
				constructor(t) {
					this.name = et.EXT_MESHOPT_COMPRESSION, this.parser = t
				}
				loadBufferView(t) {
					const e = this.parser.json,
						n = e.bufferViews[t];
					if (n.extensions && n.extensions[this.name]) {
						const t = n.extensions[this.name],
							r = this.parser.getDependency("buffer", t.buffer),
							o = this.parser.options.meshoptDecoder;
						if (!o || !o.supported) {
							if (e.extensionsRequired && e.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
							return null
						}
						return Promise.all([r, o.ready]).then((function(e) {
							const n = t.byteOffset || 0,
								r = t.byteLength || 0,
								l = t.count,
								c = t.byteStride,
								h = new ArrayBuffer(l * c),
								source = new Uint8Array(e[0], n, r);
							return o.decodeGltfBuffer(new Uint8Array(h), l, c, source, t.mode, t.filter), h
						}))
					}
					return null
				}
			}
			const mt = "glTF",
				gt = 1313821514,
				vt = 5130562;
			class yt {
				constructor(data) {
					this.name = et.KHR_BINARY_GLTF, this.content = null, this.body = null;
					const t = new DataView(data, 0, 12);
					if (this.header = {
							magic: r.cb.decodeText(new Uint8Array(data.slice(0, 4))),
							version: t.getUint32(4, !0),
							length: t.getUint32(8, !0)
						}, this.header.magic !== mt) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
					if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
					const e = this.header.length - 12,
						n = new DataView(data, 12);
					let o = 0;
					for (; o < e;) {
						const t = n.getUint32(o, !0);
						o += 4;
						const e = n.getUint32(o, !0);
						if (o += 4, e === gt) {
							const e = new Uint8Array(data, 12 + o, t);
							this.content = r.cb.decodeText(e)
						} else if (e === vt) {
							const e = 12 + o;
							this.body = data.slice(e, e + t)
						}
						o += t
					}
					if (null === this.content) throw new Error("THREE.GLTFLoader: JSON content not found.")
				}
			}
			class xt {
				constructor(t, e) {
					if (!e) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
					this.name = et.KHR_DRACO_MESH_COMPRESSION, this.json = t, this.dracoLoader = e, this.dracoLoader.preload()
				}
				decodePrimitive(t, e) {
					const n = this.json,
						r = this.dracoLoader,
						o = t.extensions[this.name].bufferView,
						l = t.extensions[this.name].attributes,
						c = {},
						h = {},
						d = {};
					for (const t in l) {
						const e = Nt[t] || t.toLowerCase();
						c[e] = l[t]
					}
					for (const e in t.attributes) {
						const r = Nt[e] || e.toLowerCase();
						if (void 0 !== l[e]) {
							const o = n.accessors[t.attributes[e]],
								l = Bt[o.componentType];
							d[r] = l, h[r] = !0 === o.normalized
						}
					}
					return e.getDependency("bufferView", o).then((function(t) {
						return new Promise((function(e) {
							r.decodeDracoFile(t, (function(t) {
								for (const e in t.attributes) {
									const n = t.attributes[e],
										r = h[e];
									void 0 !== r && (n.normalized = r)
								}
								e(t)
							}), c, d)
						}))
					}))
				}
			}
			class _t {
				constructor() {
					this.name = et.KHR_TEXTURE_TRANSFORM
				}
				extendTexture(t, e) {
					return void 0 !== e.texCoord && console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.'), void 0 === e.offset && void 0 === e.rotation && void 0 === e.scale || (t = t.clone(), void 0 !== e.offset && t.offset.fromArray(e.offset), void 0 !== e.rotation && (t.rotation = e.rotation), void 0 !== e.scale && t.repeat.fromArray(e.scale), t.needsUpdate = !0), t
				}
			}
			class wt extends r.pb {
				constructor(t) {
					super(), this.isGLTFSpecularGlossinessMaterial = !0;
					const e = ["#ifdef USE_SPECULARMAP", "\tuniform sampler2D specularMap;", "#endif"].join("\n"),
						n = ["#ifdef USE_GLOSSINESSMAP", "\tuniform sampler2D glossinessMap;", "#endif"].join("\n"),
						o = ["vec3 specularFactor = specular;", "#ifdef USE_SPECULARMAP", "\tvec4 texelSpecular = texture2D( specularMap, vUv );", "\t// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tspecularFactor *= texelSpecular.rgb;", "#endif"].join("\n"),
						l = ["float glossinessFactor = glossiness;", "#ifdef USE_GLOSSINESSMAP", "\tvec4 texelGlossiness = texture2D( glossinessMap, vUv );", "\t// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture", "\tglossinessFactor *= texelGlossiness.a;", "#endif"].join("\n"),
						c = ["PhysicalMaterial material;", "material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );", "vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );", "float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );", "material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.", "material.roughness += geometryRoughness;", "material.roughness = min( material.roughness, 1.0 );", "material.specularColor = specularFactor;"].join("\n"),
						h = {
							specular: {
								value: (new r.o).setHex(16777215)
							},
							glossiness: {
								value: 1
							},
							specularMap: {
								value: null
							},
							glossinessMap: {
								value: null
							}
						};
					this._extraUniforms = h, this.onBeforeCompile = function(t) {
						for (const e in h) t.uniforms[e] = h[e];
						t.fragmentShader = t.fragmentShader.replace("uniform float roughness;", "uniform vec3 specular;").replace("uniform float metalness;", "uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>", e).replace("#include <metalnessmap_pars_fragment>", n).replace("#include <roughnessmap_fragment>", o).replace("#include <metalnessmap_fragment>", l).replace("#include <lights_physical_fragment>", c)
					}, Object.defineProperties(this, {
						specular: {
							get: function() {
								return h.specular.value
							},
							set: function(t) {
								h.specular.value = t
							}
						},
						specularMap: {
							get: function() {
								return h.specularMap.value
							},
							set: function(t) {
								h.specularMap.value = t, t ? this.defines.USE_SPECULARMAP = "" : delete this.defines.USE_SPECULARMAP
							}
						},
						glossiness: {
							get: function() {
								return h.glossiness.value
							},
							set: function(t) {
								h.glossiness.value = t
							}
						},
						glossinessMap: {
							get: function() {
								return h.glossinessMap.value
							},
							set: function(t) {
								h.glossinessMap.value = t, t ? (this.defines.USE_GLOSSINESSMAP = "", this.defines.USE_UV = "") : (delete this.defines.USE_GLOSSINESSMAP, delete this.defines.USE_UV)
							}
						}
					}), delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this.setValues(t)
				}
				copy(source) {
					return super.copy(source), this.specularMap = source.specularMap, this.specular.copy(source.specular), this.glossinessMap = source.glossinessMap, this.glossiness = source.glossiness, delete this.metalness, delete this.roughness, delete this.metalnessMap, delete this.roughnessMap, this
				}
			}
			class At {
				constructor() {
					this.name = et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS, this.specularGlossinessParams = ["color", "map", "lightMap", "lightMapIntensity", "aoMap", "aoMapIntensity", "emissive", "emissiveIntensity", "emissiveMap", "bumpMap", "bumpScale", "normalMap", "normalMapType", "displacementMap", "displacementScale", "displacementBias", "specularMap", "specular", "glossinessMap", "glossiness", "alphaMap", "envMap", "envMapIntensity", "refractionRatio"]
				}
				getMaterialType() {
					return wt
				}
				extendParams(t, e, n) {
					const o = e.extensions[this.name];
					t.color = new r.o(1, 1, 1), t.opacity = 1;
					const l = [];
					if (Array.isArray(o.diffuseFactor)) {
						const e = o.diffuseFactor;
						t.color.fromArray(e), t.opacity = e[3]
					}
					if (void 0 !== o.diffuseTexture && l.push(n.assignTexture(t, "map", o.diffuseTexture)), t.emissive = new r.o(0, 0, 0), t.glossiness = void 0 !== o.glossinessFactor ? o.glossinessFactor : 1, t.specular = new r.o(1, 1, 1), Array.isArray(o.specularFactor) && t.specular.fromArray(o.specularFactor), void 0 !== o.specularGlossinessTexture) {
						const e = o.specularGlossinessTexture;
						l.push(n.assignTexture(t, "glossinessMap", e)), l.push(n.assignTexture(t, "specularMap", e))
					}
					return Promise.all(l)
				}
				createMaterial(t) {
					const e = new wt(t);
					return e.fog = !0, e.color = t.color, e.map = void 0 === t.map ? null : t.map, e.lightMap = null, e.lightMapIntensity = 1, e.aoMap = void 0 === t.aoMap ? null : t.aoMap, e.aoMapIntensity = 1, e.emissive = t.emissive, e.emissiveIntensity = 1, e.emissiveMap = void 0 === t.emissiveMap ? null : t.emissiveMap, e.bumpMap = void 0 === t.bumpMap ? null : t.bumpMap, e.bumpScale = 1, e.normalMap = void 0 === t.normalMap ? null : t.normalMap, e.normalMapType = r.Wb, t.normalScale && (e.normalScale = t.normalScale), e.displacementMap = null, e.displacementScale = 1, e.displacementBias = 0, e.specularMap = void 0 === t.specularMap ? null : t.specularMap, e.specular = t.specular, e.glossinessMap = void 0 === t.glossinessMap ? null : t.glossinessMap, e.glossiness = t.glossiness, e.alphaMap = null, e.envMap = void 0 === t.envMap ? null : t.envMap, e.envMapIntensity = 1, e.refractionRatio = .98, e
				}
			}
			class bt {
				constructor() {
					this.name = et.KHR_MESH_QUANTIZATION
				}
			}
			class Mt extends r.N {
				constructor(t, e, n, r) {
					super(t, e, n, r)
				}
				copySampleValue_(t) {
					const e = this.resultBuffer,
						n = this.sampleValues,
						r = this.valueSize,
						o = t * r * 3 + r;
					for (let i = 0; i !== r; i++) e[i] = n[o + i];
					return e
				}
			}
			Mt.prototype.beforeStart_ = Mt.prototype.copySampleValue_, Mt.prototype.afterEnd_ = Mt.prototype.copySampleValue_, Mt.prototype.interpolate_ = function(t, e, n, r) {
				const o = this.resultBuffer,
					l = this.sampleValues,
					c = this.valueSize,
					h = 2 * c,
					d = 3 * c,
					td = r - e,
					p = (n - e) / td,
					f = p * p,
					m = f * p,
					v = t * d,
					y = v - d,
					x = -2 * m + 3 * f,
					_ = m - f,
					w = 1 - x,
					A = _ - f + p;
				for (let i = 0; i !== c; i++) {
					const t = l[y + i + c],
						e = l[y + i + h] * td,
						n = l[v + i + c],
						r = l[v + i] * td;
					o[i] = w * t + A * e + x * n + _ * r
				}
				return o
			};
			const St = new r.Ib;
			class Tt extends Mt {
				interpolate_(t, e, n, r) {
					const o = super.interpolate_(t, e, n, r);
					return St.fromArray(o).normalize().toArray(o), o
				}
			}
			const Et = 0,
				Ct = 1,
				Rt = 2,
				Dt = 3,
				Lt = 4,
				Pt = 5,
				It = 6,
				Bt = {
					5120: Int8Array,
					5121: Uint8Array,
					5122: Int16Array,
					5123: Uint16Array,
					5125: Uint32Array,
					5126: Float32Array
				},
				Ot = {
					9728: r.rb,
					9729: r.X,
					9984: r.tb,
					9985: r.ab,
					9986: r.sb,
					9987: r.Z
				},
				Ft = {
					33071: r.n,
					33648: r.qb,
					10497: r.Pb
				},
				Ht = {
					SCALAR: 1,
					VEC2: 2,
					VEC3: 3,
					VEC4: 4,
					MAT2: 4,
					MAT3: 9,
					MAT4: 16
				},
				Nt = {
					POSITION: "position",
					NORMAL: "normal",
					TANGENT: "tangent",
					TEXCOORD_0: "uv",
					TEXCOORD_1: "uv2",
					COLOR_0: "color",
					WEIGHTS_0: "skinWeight",
					JOINTS_0: "skinIndex"
				},
				Ut = {
					scale: "scale",
					translation: "position",
					rotation: "quaternion",
					weights: "morphTargetInfluences"
				},
				zt = {
					CUBICSPLINE: void 0,
					LINEAR: r.P,
					STEP: r.O
				},
				kt = "OPAQUE",
				Gt = "MASK",
				Vt = "BLEND";

			function Wt(t, object, e) {
				for (const n in e.extensions) void 0 === t[n] && (object.userData.gltfExtensions = object.userData.gltfExtensions || {}, object.userData.gltfExtensions[n] = e.extensions[n])
			}

			function jt(object, t) {
				void 0 !== t.extras && ("object" == typeof t.extras ? Object.assign(object.userData, t.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras))
			}

			function Xt(t, e) {
				if (t.updateMorphTargets(), void 0 !== e.weights)
					for (let i = 0, n = e.weights.length; i < n; i++) t.morphTargetInfluences[i] = e.weights[i];
				if (e.extras && Array.isArray(e.extras.targetNames)) {
					const n = e.extras.targetNames;
					if (t.morphTargetInfluences.length === n.length) {
						t.morphTargetDictionary = {};
						for (let i = 0, e = n.length; i < e; i++) t.morphTargetDictionary[n[i]] = i
					} else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
				}
			}

			function Yt(t) {
				const e = t.extensions && t.extensions[et.KHR_DRACO_MESH_COMPRESSION];
				let n;
				return n = e ? "draco:" + e.bufferView + ":" + e.indices + ":" + Qt(e.attributes) : t.indices + ":" + Qt(t.attributes) + ":" + t.mode, n
			}

			function Qt(t) {
				let e = "";
				const n = Object.keys(t).sort();
				for (let i = 0, r = n.length; i < r; i++) e += n[i] + ":" + t[n[i]] + ";";
				return e
			}

			function qt(t) {
				switch (t) {
					case Int8Array:
						return 1 / 127;
					case Uint8Array:
						return 1 / 255;
					case Int16Array:
						return 1 / 32767;
					case Uint16Array:
						return 1 / 65535;
					default:
						throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
				}
			}
			class Jt {
				constructor(t = {}, e = {}) {
					this.json = t, this.extensions = {}, this.plugins = {}, this.options = e, this.cache = new tt, this.associations = new Map, this.primitiveCache = {}, this.meshCache = {
						refs: {},
						uses: {}
					}, this.cameraCache = {
						refs: {},
						uses: {}
					}, this.lightCache = {
						refs: {},
						uses: {}
					}, this.textureCache = {}, this.nodeNamesUsed = {}, "undefined" != typeof createImageBitmap && !1 === /Firefox|^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? this.textureLoader = new r.K(this.options.manager) : this.textureLoader = new r.Yb(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new r.D(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), "use-credentials" === this.options.crossOrigin && this.fileLoader.setWithCredentials(!0)
				}
				setExtensions(t) {
					this.extensions = t
				}
				setPlugins(t) {
					this.plugins = t
				}
				parse(t, e) {
					const n = this,
						r = this.json,
						o = this.extensions;
					this.cache.removeAll(), this._invokeAll((function(t) {
						return t._markDefs && t._markDefs()
					})), Promise.all(this._invokeAll((function(t) {
						return t.beforeRoot && t.beforeRoot()
					}))).then((function() {
						return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
					})).then((function(e) {
						const l = {
							scene: e[0][r.scene || 0],
							scenes: e[0],
							animations: e[1],
							cameras: e[2],
							asset: r.asset,
							parser: n,
							userData: {}
						};
						Wt(o, l, r), jt(l, r), Promise.all(n._invokeAll((function(t) {
							return t.afterRoot && t.afterRoot(l)
						}))).then((function() {
							t(l)
						}))
					})).catch(e)
				}
				_markDefs() {
					const t = this.json.nodes || [],
						e = this.json.skins || [],
						n = this.json.meshes || [];
					for (let n = 0, r = e.length; n < r; n++) {
						const r = e[n].joints;
						for (let i = 0, e = r.length; i < e; i++) t[r[i]].isBone = !0
					}
					for (let e = 0, r = t.length; e < r; e++) {
						const r = t[e];
						void 0 !== r.mesh && (this._addNodeRef(this.meshCache, r.mesh), void 0 !== r.skin && (n[r.mesh].isSkinnedMesh = !0)), void 0 !== r.camera && this._addNodeRef(this.cameraCache, r.camera)
					}
				}
				_addNodeRef(t, e) {
					void 0 !== e && (void 0 === t.refs[e] && (t.refs[e] = t.uses[e] = 0), t.refs[e]++)
				}
				_getNodeRef(t, e, object) {
					if (t.refs[e] <= 1) return object;
					const n = object.clone(),
						r = (t, e) => {
							const n = this.associations.get(t);
							null != n && this.associations.set(e, n);
							for (const [i, n] of t.children.entries()) r(n, e.children[i])
						};
					return r(object, n), n.name += "_instance_" + t.uses[e]++, n
				}
				_invokeOne(t) {
					const e = Object.values(this.plugins);
					e.push(this);
					for (let i = 0; i < e.length; i++) {
						const n = t(e[i]);
						if (n) return n
					}
					return null
				}
				_invokeAll(t) {
					const e = Object.values(this.plugins);
					e.unshift(this);
					const n = [];
					for (let i = 0; i < e.length; i++) {
						const r = t(e[i]);
						r && n.push(r)
					}
					return n
				}
				getDependency(t, e) {
					const n = t + ":" + e;
					let r = this.cache.get(n);
					if (!r) {
						switch (t) {
							case "scene":
								r = this.loadScene(e);
								break;
							case "node":
								r = this.loadNode(e);
								break;
							case "mesh":
								r = this._invokeOne((function(t) {
									return t.loadMesh && t.loadMesh(e)
								}));
								break;
							case "accessor":
								r = this.loadAccessor(e);
								break;
							case "bufferView":
								r = this._invokeOne((function(t) {
									return t.loadBufferView && t.loadBufferView(e)
								}));
								break;
							case "buffer":
								r = this.loadBuffer(e);
								break;
							case "material":
								r = this._invokeOne((function(t) {
									return t.loadMaterial && t.loadMaterial(e)
								}));
								break;
							case "texture":
								r = this._invokeOne((function(t) {
									return t.loadTexture && t.loadTexture(e)
								}));
								break;
							case "skin":
								r = this.loadSkin(e);
								break;
							case "animation":
								r = this.loadAnimation(e);
								break;
							case "camera":
								r = this.loadCamera(e);
								break;
							default:
								throw new Error("Unknown type: " + t)
						}
						this.cache.add(n, r)
					}
					return r
				}
				getDependencies(t) {
					let e = this.cache.get(t);
					if (!e) {
						const n = this,
							defs = this.json[t + ("mesh" === t ? "es" : "s")] || [];
						e = Promise.all(defs.map((function(e, r) {
							return n.getDependency(t, r)
						}))), this.cache.add(t, e)
					}
					return e
				}
				loadBuffer(t) {
					const e = this.json.buffers[t],
						n = this.fileLoader;
					if (e.type && "arraybuffer" !== e.type) throw new Error("THREE.GLTFLoader: " + e.type + " buffer type is not supported.");
					if (void 0 === e.uri && 0 === t) return Promise.resolve(this.extensions[et.KHR_BINARY_GLTF].body);
					const o = this.options;
					return new Promise((function(t, l) {
						n.load(r.cb.resolveURL(e.uri, o.path), t, void 0, (function() {
							l(new Error('THREE.GLTFLoader: Failed to load buffer "' + e.uri + '".'))
						}))
					}))
				}
				loadBufferView(t) {
					const e = this.json.bufferViews[t];
					return this.getDependency("buffer", e.buffer).then((function(t) {
						const n = e.byteLength || 0,
							r = e.byteOffset || 0;
						return t.slice(r, r + n)
					}))
				}
				loadAccessor(t) {
					const e = this,
						n = this.json,
						o = this.json.accessors[t];
					if (void 0 === o.bufferView && void 0 === o.sparse) return Promise.resolve(null);
					const l = [];
					return void 0 !== o.bufferView ? l.push(this.getDependency("bufferView", o.bufferView)) : l.push(null), void 0 !== o.sparse && (l.push(this.getDependency("bufferView", o.sparse.indices.bufferView)), l.push(this.getDependency("bufferView", o.sparse.values.bufferView))), Promise.all(l).then((function(t) {
						const l = t[0],
							c = Ht[o.type],
							h = Bt[o.componentType],
							d = h.BYTES_PER_ELEMENT,
							f = d * c,
							m = o.byteOffset || 0,
							v = void 0 !== o.bufferView ? n.bufferViews[o.bufferView].byteStride : void 0,
							y = !0 === o.normalized;
						let x, _;
						if (v && v !== f) {
							const t = Math.floor(m / v),
								n = "InterleavedBuffer:" + o.bufferView + ":" + o.componentType + ":" + t + ":" + o.count;
							let f = e.cache.get(n);
							f || (x = new h(l, t * v, o.count * v / d), f = new r.L(x, v / d), e.cache.add(n, f)), _ = new r.M(f, c, m % v / d, y)
						} else x = null === l ? new h(o.count * c) : new h(l, m, o.count * c), _ = new r.k(x, c, y);
						if (void 0 !== o.sparse) {
							const e = Ht.SCALAR,
								n = Bt[o.sparse.indices.componentType],
								d = o.sparse.indices.byteOffset || 0,
								f = o.sparse.values.byteOffset || 0,
								m = new n(t[1], d, o.sparse.count * e),
								v = new h(t[2], f, o.sparse.count * c);
							null !== l && (_ = new r.k(_.array.slice(), _.itemSize, _.normalized));
							for (let i = 0, t = m.length; i < t; i++) {
								const t = m[i];
								if (_.setX(t, v[i * c]), c >= 2 && _.setY(t, v[i * c + 1]), c >= 3 && _.setZ(t, v[i * c + 2]), c >= 4 && _.setW(t, v[i * c + 3]), c >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
							}
						}
						return _
					}))
				}
				loadTexture(t) {
					const e = this.json,
						n = this.options,
						r = e.textures[t],
						source = e.images[r.source];
					let o = this.textureLoader;
					if (source.uri) {
						const t = n.manager.getHandler(source.uri);
						null !== t && (o = t)
					}
					return this.loadTextureImage(t, source, o)
				}
				loadTextureImage(t, source, e) {
					const n = this,
						o = this.json,
						l = this.options,
						c = o.textures[t],
						h = (source.uri || source.bufferView) + ":" + c.sampler;
					if (this.textureCache[h]) return this.textureCache[h];
					const d = self.URL || self.webkitURL;
					let f = source.uri || "",
						m = !1;
					if (void 0 !== source.bufferView) f = n.getDependency("bufferView", source.bufferView).then((function(t) {
						m = !0;
						const e = new Blob([t], {
							type: source.mimeType
						});
						return f = d.createObjectURL(e), f
					}));
					else if (void 0 === source.uri) throw new Error("THREE.GLTFLoader: Image " + t + " is missing URI and bufferView");
					const v = Promise.resolve(f).then((function(t) {
						return new Promise((function(n, o) {
							let c = n;
							!0 === e.isImageBitmapLoader && (c = function(t) {
								const e = new r.Xb(t);
								e.needsUpdate = !0, n(e)
							}), e.load(r.cb.resolveURL(t, l.path), c, void 0, o)
						}))
					})).then((function(e) {
						!0 === m && d.revokeObjectURL(f), e.flipY = !1, c.name && (e.name = c.name);
						const l = (o.samplers || {})[c.sampler] || {};
						return e.magFilter = Ot[l.magFilter] || r.X, e.minFilter = Ot[l.minFilter] || r.Z, e.wrapS = Ft[l.wrapS] || r.Pb, e.wrapT = Ft[l.wrapT] || r.Pb, n.associations.set(e, {
							textures: t
						}), e
					})).catch((function() {
						return console.error("THREE.GLTFLoader: Couldn't load texture", f), null
					}));
					return this.textureCache[h] = v, v
				}
				assignTexture(t, e, n) {
					const r = this;
					return this.getDependency("texture", n.index).then((function(o) {
						if (void 0 === n.texCoord || 0 == n.texCoord || "aoMap" === e && 1 == n.texCoord || console.warn("THREE.GLTFLoader: Custom UV set " + n.texCoord + " for texture " + e + " not yet supported."), r.extensions[et.KHR_TEXTURE_TRANSFORM]) {
							const t = void 0 !== n.extensions ? n.extensions[et.KHR_TEXTURE_TRANSFORM] : void 0;
							if (t) {
								const e = r.associations.get(o);
								o = r.extensions[et.KHR_TEXTURE_TRANSFORM].extendTexture(o, t), r.associations.set(o, e)
							}
						}
						return t[e] = o, o
					}))
				}
				assignFinalMaterial(t) {
					const e = t.geometry;
					let n = t.material;
					const o = void 0 === e.attributes.tangent,
						l = void 0 !== e.attributes.color,
						c = void 0 === e.attributes.normal;
					if (t.isPoints) {
						const t = "PointsMaterial:" + n.uuid;
						let e = this.cache.get(t);
						e || (e = new r.Fb, r.fb.prototype.copy.call(e, n), e.color.copy(n.color), e.map = n.map, e.sizeAttenuation = !1, this.cache.add(t, e)), n = e
					} else if (t.isLine) {
						const t = "LineBasicMaterial:" + n.uuid;
						let e = this.cache.get(t);
						e || (e = new r.T, r.fb.prototype.copy.call(e, n), e.color.copy(n.color), this.cache.add(t, e)), n = e
					}
					if (o || l || c) {
						let t = "ClonedMaterial:" + n.uuid + ":";
						n.isGLTFSpecularGlossinessMaterial && (t += "specular-glossiness:"), o && (t += "derivative-tangents:"), l && (t += "vertex-colors:"), c && (t += "flat-shading:");
						let e = this.cache.get(t);
						e || (e = n.clone(), l && (e.vertexColors = !0), c && (e.flatShading = !0), o && (e.normalScale && (e.normalScale.y *= -1), e.clearcoatNormalScale && (e.clearcoatNormalScale.y *= -1)), this.cache.add(t, e), this.associations.set(e, this.associations.get(n))), n = e
					}
					n.aoMap && void 0 === e.attributes.uv2 && void 0 !== e.attributes.uv && e.setAttribute("uv2", e.attributes.uv), t.material = n
				}
				getMaterialType() {
					return r.pb
				}
				loadMaterial(t) {
					const e = this,
						n = this.json,
						o = this.extensions,
						l = n.materials[t];
					let c;
					const h = {},
						d = l.extensions || {},
						f = [];
					if (d[et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
						const t = o[et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
						c = t.getMaterialType(), f.push(t.extendParams(h, l, e))
					} else if (d[et.KHR_MATERIALS_UNLIT]) {
						const t = o[et.KHR_MATERIALS_UNLIT];
						c = t.getMaterialType(), f.push(t.extendParams(h, l, e))
					} else {
						const n = l.pbrMetallicRoughness || {};
						if (h.color = new r.o(1, 1, 1), h.opacity = 1, Array.isArray(n.baseColorFactor)) {
							const t = n.baseColorFactor;
							h.color.fromArray(t), h.opacity = t[3]
						}
						void 0 !== n.baseColorTexture && f.push(e.assignTexture(h, "map", n.baseColorTexture)), h.metalness = void 0 !== n.metallicFactor ? n.metallicFactor : 1, h.roughness = void 0 !== n.roughnessFactor ? n.roughnessFactor : 1, void 0 !== n.metallicRoughnessTexture && (f.push(e.assignTexture(h, "metalnessMap", n.metallicRoughnessTexture)), f.push(e.assignTexture(h, "roughnessMap", n.metallicRoughnessTexture))), c = this._invokeOne((function(e) {
							return e.getMaterialType && e.getMaterialType(t)
						})), f.push(Promise.all(this._invokeAll((function(e) {
							return e.extendMaterialParams && e.extendMaterialParams(t, h)
						}))))
					}!0 === l.doubleSided && (h.side = r.A);
					const m = l.alphaMode || kt;
					if (m === Vt ? (h.transparent = !0, h.depthWrite = !1) : (h.transparent = !1, m === Gt && (h.alphaTest = void 0 !== l.alphaCutoff ? l.alphaCutoff : .5)), void 0 !== l.normalTexture && c !== r.kb && (f.push(e.assignTexture(h, "normalMap", l.normalTexture)), h.normalScale = new r.hc(1, 1), void 0 !== l.normalTexture.scale)) {
						const t = l.normalTexture.scale;
						h.normalScale.set(t, t)
					}
					return void 0 !== l.occlusionTexture && c !== r.kb && (f.push(e.assignTexture(h, "aoMap", l.occlusionTexture)), void 0 !== l.occlusionTexture.strength && (h.aoMapIntensity = l.occlusionTexture.strength)), void 0 !== l.emissiveFactor && c !== r.kb && (h.emissive = (new r.o).fromArray(l.emissiveFactor)), void 0 !== l.emissiveTexture && c !== r.kb && f.push(e.assignTexture(h, "emissiveMap", l.emissiveTexture)), Promise.all(f).then((function() {
						let n;
						return n = c === wt ? o[et.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(h) : new c(h), l.name && (n.name = l.name), n.map && (n.map.encoding = r.pc), n.emissiveMap && (n.emissiveMap.encoding = r.pc), jt(n, l), e.associations.set(n, {
							materials: t
						}), l.extensions && Wt(o, n, l), n
					}))
				}
				createUniqueName(t) {
					const e = r.Hb.sanitizeNodeName(t || "");
					let n = e;
					for (let i = 1; this.nodeNamesUsed[n]; ++i) n = e + "_" + i;
					return this.nodeNamesUsed[n] = !0, n
				}
				loadGeometries(t) {
					const e = this,
						n = this.extensions,
						o = this.primitiveCache;

					function l(t) {
						return n[et.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(t, e).then((function(n) {
							return Zt(n, t, e)
						}))
					}
					const c = [];
					for (let i = 0, n = t.length; i < n; i++) {
						const n = t[i],
							h = Yt(n),
							d = o[h];
						if (d) c.push(d.promise);
						else {
							let t;
							t = n.extensions && n.extensions[et.KHR_DRACO_MESH_COMPRESSION] ? l(n) : Zt(new r.l, n, e), o[h] = {
								primitive: n,
								promise: t
							}, c.push(t)
						}
					}
					return Promise.all(c)
				}
				loadMesh(t) {
					const e = this,
						n = this.json,
						o = this.extensions,
						l = n.meshes[t],
						c = l.primitives,
						h = [];
					for (let i = 0, t = c.length; i < t; i++) {
						const t = void 0 === c[i].material ? (void 0 === (d = this.cache).DefaultMaterial && (d.DefaultMaterial = new r.pb({
							color: 16777215,
							emissive: 0,
							metalness: 1,
							roughness: 1,
							transparent: !1,
							depthTest: !0,
							side: r.F
						})), d.DefaultMaterial) : this.getDependency("material", c[i].material);
						h.push(t)
					}
					var d;
					return h.push(e.loadGeometries(c)), Promise.all(h).then((function(n) {
						const h = n.slice(0, n.length - 1),
							d = n[n.length - 1],
							f = [];
						for (let i = 0, n = d.length; i < n; i++) {
							const n = d[i],
								m = c[i];
							let v;
							const y = h[i];
							if (m.mode === Lt || m.mode === Pt || m.mode === It || void 0 === m.mode) v = !0 === l.isSkinnedMesh ? new r.Tb(n, y) : new r.jb(n, y), !0 !== v.isSkinnedMesh || v.geometry.attributes.skinWeight.normalized || v.normalizeSkinWeights(), m.mode === Pt ? v.geometry = $t(v.geometry, r.bc) : m.mode === It && (v.geometry = $t(v.geometry, r.ac));
							else if (m.mode === Ct) v = new r.V(n, y);
							else if (m.mode === Dt) v = new r.S(n, y);
							else if (m.mode === Rt) v = new r.U(n, y);
							else {
								if (m.mode !== Et) throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + m.mode);
								v = new r.Eb(n, y)
							}
							Object.keys(v.geometry.morphAttributes).length > 0 && Xt(v, l), v.name = e.createUniqueName(l.name || "mesh_" + t), jt(v, l), m.extensions && Wt(o, v, m), e.assignFinalMaterial(v), f.push(v)
						}
						for (let i = 0, n = f.length; i < n; i++) e.associations.set(f[i], {
							meshes: t,
							primitives: i
						});
						if (1 === f.length) return f[0];
						const m = new r.I;
						e.associations.set(m, {
							meshes: t
						});
						for (let i = 0, t = f.length; i < t; i++) m.add(f[i]);
						return m
					}))
				}
				loadCamera(t) {
					let e;
					const n = this.json.cameras[t],
						o = n[n.type];
					if (o) return "perspective" === n.type ? e = new r.Ab(r.gb.radToDeg(o.yfov), o.aspectRatio || 1, o.znear || 1, o.zfar || 2e6) : "orthographic" === n.type && (e = new r.zb(-o.xmag, o.xmag, o.ymag, -o.ymag, o.znear, o.zfar)), n.name && (e.name = this.createUniqueName(n.name)), jt(e, n), Promise.resolve(e);
					console.warn("THREE.GLTFLoader: Missing camera parameters.")
				}
				loadSkin(t) {
					const e = this.json.skins[t],
						n = {
							joints: e.joints
						};
					return void 0 === e.inverseBindMatrices ? Promise.resolve(n) : this.getDependency("accessor", e.inverseBindMatrices).then((function(t) {
						return n.inverseBindMatrices = t, n
					}))
				}
				loadAnimation(t) {
					const e = this.json.animations[t],
						n = [],
						o = [],
						l = [],
						c = [],
						h = [];
					for (let i = 0, t = e.channels.length; i < t; i++) {
						const t = e.channels[i],
							r = e.samplers[t.sampler],
							d = t.target,
							f = void 0 !== d.node ? d.node : d.id,
							input = void 0 !== e.parameters ? e.parameters[r.input] : r.input,
							output = void 0 !== e.parameters ? e.parameters[r.output] : r.output;
						n.push(this.getDependency("node", f)), o.push(this.getDependency("accessor", input)), l.push(this.getDependency("accessor", output)), c.push(r), h.push(d)
					}
					return Promise.all([Promise.all(n), Promise.all(o), Promise.all(l), Promise.all(c), Promise.all(h)]).then((function(n) {
						const o = n[0],
							l = n[1],
							c = n[2],
							h = n[3],
							d = n[4],
							f = [];
						for (let i = 0, t = o.length; i < t; i++) {
							const t = o[i],
								e = l[i],
								n = c[i],
								m = h[i],
								v = d[i];
							if (void 0 === t) continue;
							let y;
							switch (t.updateMatrix(), t.matrixAutoUpdate = !0, Ut[v.path]) {
								case Ut.weights:
									y = r.xb;
									break;
								case Ut.rotation:
									y = r.Jb;
									break;
								case Ut.position:
								case Ut.scale:
								default:
									y = r.kc
							}
							const x = t.name ? t.name : t.uuid,
								_ = void 0 !== m.interpolation ? zt[m.interpolation] : r.P,
								w = [];
							Ut[v.path] === Ut.weights ? t.traverse((function(object) {
								object.morphTargetInfluences && w.push(object.name ? object.name : object.uuid)
							})) : w.push(x);
							let A = n.array;
							if (n.normalized) {
								const t = qt(A.constructor),
									e = new Float32Array(A.length);
								for (let n = 0, r = A.length; n < r; n++) e[n] = A[n] * t;
								A = e
							}
							for (let t = 0, n = w.length; t < n; t++) {
								const track = new y(w[t] + "." + Ut[v.path], e.array, A, _);
								"CUBICSPLINE" === m.interpolation && (track.createInterpolant = function(t) {
									return new(this instanceof r.Jb ? Tt : Mt)(this.times, this.values, this.getValueSize() / 3, t)
								}, track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0), f.push(track)
							}
						}
						const m = e.name ? e.name : "animation_" + t;
						return new r.b(m, void 0, f)
					}))
				}
				createNodeMesh(t) {
					const e = this.json,
						n = this,
						r = e.nodes[t];
					return void 0 === r.mesh ? null : n.getDependency("mesh", r.mesh).then((function(t) {
						const e = n._getNodeRef(n.meshCache, r.mesh, t);
						return void 0 !== r.weights && e.traverse((function(t) {
							if (t.isMesh)
								for (let i = 0, e = r.weights.length; i < e; i++) t.morphTargetInfluences[i] = r.weights[i]
						})), e
					}))
				}
				loadNode(t) {
					const e = this.json,
						n = this.extensions,
						o = this,
						l = e.nodes[t],
						c = l.name ? o.createUniqueName(l.name) : "";
					return function() {
						const e = [],
							n = o._invokeOne((function(e) {
								return e.createNodeMesh && e.createNodeMesh(t)
							}));
						return n && e.push(n), void 0 !== l.camera && e.push(o.getDependency("camera", l.camera).then((function(t) {
							return o._getNodeRef(o.cameraCache, l.camera, t)
						}))), o._invokeAll((function(e) {
							return e.createNodeAttachment && e.createNodeAttachment(t)
						})).forEach((function(t) {
							e.push(t)
						})), Promise.all(e)
					}().then((function(e) {
						let h;
						if (h = !0 === l.isBone ? new r.i : e.length > 1 ? new r.I : 1 === e.length ? e[0] : new r.yb, h !== e[0])
							for (let i = 0, t = e.length; i < t; i++) h.add(e[i]);
						if (l.name && (h.userData.name = l.name, h.name = c), jt(h, l), l.extensions && Wt(n, h, l), void 0 !== l.matrix) {
							const t = new r.ib;
							t.fromArray(l.matrix), h.applyMatrix4(t)
						} else void 0 !== l.translation && h.position.fromArray(l.translation), void 0 !== l.rotation && h.quaternion.fromArray(l.rotation), void 0 !== l.scale && h.scale.fromArray(l.scale);
						return o.associations.has(h) || o.associations.set(h, {}), o.associations.get(h).nodes = t, h
					}))
				}
				loadScene(t) {
					const e = this.json,
						n = this.extensions,
						o = this.json.scenes[t],
						l = this,
						c = new r.I;
					o.name && (c.name = l.createUniqueName(o.name)), jt(c, o), o.extensions && Wt(n, c, o);
					const h = o.nodes || [],
						d = [];
					for (let i = 0, t = h.length; i < t; i++) d.push(Kt(h[i], c, e, l));
					return Promise.all(d).then((function() {
						return l.associations = (t => {
							const e = new Map;
							for (const [t, n] of l.associations)(t instanceof r.fb || t instanceof r.Xb) && e.set(t, n);
							return t.traverse((t => {
								const n = l.associations.get(t);
								null != n && e.set(t, n)
							})), e
						})(c), c
					}))
				}
			}

			function Kt(t, e, n, o) {
				const l = n.nodes[t];
				return o.getDependency("node", t).then((function(t) {
					if (void 0 === l.skin) return t;
					let e;
					return o.getDependency("skin", l.skin).then((function(t) {
						e = t;
						const n = [];
						for (let i = 0, t = e.joints.length; i < t; i++) n.push(o.getDependency("node", e.joints[i]));
						return Promise.all(n)
					})).then((function(n) {
						return t.traverse((function(t) {
							if (!t.isMesh) return;
							const o = [],
								l = [];
							for (let t = 0, c = n.length; t < c; t++) {
								const c = n[t];
								if (c) {
									o.push(c);
									const n = new r.ib;
									void 0 !== e.inverseBindMatrices && n.fromArray(e.inverseBindMatrices.array, 16 * t), l.push(n)
								} else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', e.joints[t])
							}
							t.bind(new r.Sb(o, l), t.matrixWorld)
						})), t
					}))
				})).then((function(t) {
					e.add(t);
					const r = [];
					if (l.children) {
						const e = l.children;
						for (let i = 0, l = e.length; i < l; i++) {
							const l = e[i];
							r.push(Kt(l, t, n, o))
						}
					}
					return Promise.all(r)
				}))
			}

			function Zt(t, e, n) {
				const o = e.attributes,
					l = [];

				function c(e, r) {
					return n.getDependency("accessor", e).then((function(e) {
						t.setAttribute(r, e)
					}))
				}
				for (const e in o) {
					const n = Nt[e] || e.toLowerCase();
					n in t.attributes || l.push(c(o[e], n))
				}
				if (void 0 !== e.indices && !t.index) {
					const r = n.getDependency("accessor", e.indices).then((function(e) {
						t.setIndex(e)
					}));
					l.push(r)
				}
				return jt(t, e),
					function(t, e, n) {
						const o = e.attributes,
							l = new r.j;
						if (void 0 === o.POSITION) return; {
							const t = n.json.accessors[o.POSITION],
								e = t.min,
								c = t.max;
							if (void 0 === e || void 0 === c) return void console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
							if (l.set(new r.ic(e[0], e[1], e[2]), new r.ic(c[0], c[1], c[2])), t.normalized) {
								const e = qt(Bt[t.componentType]);
								l.min.multiplyScalar(e), l.max.multiplyScalar(e)
							}
						}
						const c = e.targets;
						if (void 0 !== c) {
							const t = new r.ic,
								e = new r.ic;
							for (let i = 0, r = c.length; i < r; i++) {
								const r = c[i];
								if (void 0 !== r.POSITION) {
									const o = n.json.accessors[r.POSITION],
										l = o.min,
										c = o.max;
									if (void 0 !== l && void 0 !== c) {
										if (e.setX(Math.max(Math.abs(l[0]), Math.abs(c[0]))), e.setY(Math.max(Math.abs(l[1]), Math.abs(c[1]))), e.setZ(Math.max(Math.abs(l[2]), Math.abs(c[2]))), o.normalized) {
											const t = qt(Bt[o.componentType]);
											e.multiplyScalar(t)
										}
										t.max(e)
									} else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
								}
							}
							l.expandByVector(t)
						}
						t.boundingBox = l;
						const h = new r.Ub;
						l.getCenter(h.center), h.radius = l.min.distanceTo(l.max) / 2, t.boundingSphere = h
					}(t, e, n), Promise.all(l).then((function() {
						return void 0 !== e.targets ? function(t, e, n) {
							let r = !1,
								o = !1;
							for (let i = 0, t = e.length; i < t; i++) {
								const t = e[i];
								if (void 0 !== t.POSITION && (r = !0), void 0 !== t.NORMAL && (o = !0), r && o) break
							}
							if (!r && !o) return Promise.resolve(t);
							const l = [],
								c = [];
							for (let i = 0, h = e.length; i < h; i++) {
								const h = e[i];
								if (r) {
									const e = void 0 !== h.POSITION ? n.getDependency("accessor", h.POSITION) : t.attributes.position;
									l.push(e)
								}
								if (o) {
									const e = void 0 !== h.NORMAL ? n.getDependency("accessor", h.NORMAL) : t.attributes.normal;
									c.push(e)
								}
							}
							return Promise.all([Promise.all(l), Promise.all(c)]).then((function(e) {
								const n = e[0],
									l = e[1];
								return r && (t.morphAttributes.position = n), o && (t.morphAttributes.normal = l), t.morphTargetsRelative = !0, t
							}))
						}(t, e.targets, n) : t
					}))
			}

			function $t(t, e) {
				let n = t.getIndex();
				if (null === n) {
					const e = [],
						r = t.getAttribute("position");
					if (void 0 === r) return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), t;
					for (let i = 0; i < r.count; i++) e.push(i);
					t.setIndex(e), n = t.getIndex()
				}
				const o = n.count - 2,
					l = [];
				if (e === r.ac)
					for (let i = 1; i <= o; i++) l.push(n.getX(0)), l.push(n.getX(i)), l.push(n.getX(i + 1));
				else
					for (let i = 0; i < o; i++) i % 2 == 0 ? (l.push(n.getX(i)), l.push(n.getX(i + 1)), l.push(n.getX(i + 2))) : (l.push(n.getX(i + 2)), l.push(n.getX(i + 1)), l.push(n.getX(i)));
				l.length / 3 !== o && console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
				const c = t.clone();
				return c.setIndex(l), c
			}
			const te = new WeakMap;
			class ee extends r.bb {
				constructor(t) {
					super(t), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
						position: "POSITION",
						normal: "NORMAL",
						color: "COLOR",
						uv: "TEX_COORD"
					}, this.defaultAttributeTypes = {
						position: "Float32Array",
						normal: "Float32Array",
						color: "Float32Array",
						uv: "Float32Array"
					}
				}
				setDecoderPath(path) {
					return this.decoderPath = path, this
				}
				setDecoderConfig(t) {
					return this.decoderConfig = t, this
				}
				setWorkerLimit(t) {
					return this.workerLimit = t, this
				}
				load(t, e, n, o) {
					const l = new r.D(this.manager);
					l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(t, (t => {
						const n = {
							attributeIDs: this.defaultAttributeIDs,
							attributeTypes: this.defaultAttributeTypes,
							useUniqueIDs: !1
						};
						this.decodeGeometry(t, n).then(e).catch(o)
					}), n, o)
				}
				decodeDracoFile(t, e, n, r) {
					const o = {
						attributeIDs: n || this.defaultAttributeIDs,
						attributeTypes: r || this.defaultAttributeTypes,
						useUniqueIDs: !!n
					};
					this.decodeGeometry(t, o).then(e)
				}
				decodeGeometry(t, e) {
					for (const t in e.attributeTypes) {
						const n = e.attributeTypes[t];
						void 0 !== n.BYTES_PER_ELEMENT && (e.attributeTypes[t] = n.name)
					}
					const n = JSON.stringify(e);
					if (te.has(t)) {
						const e = te.get(t);
						if (e.key === n) return e.promise;
						if (0 === t.byteLength) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
					}
					let r;
					const o = this.workerNextTaskID++,
						l = t.byteLength,
						c = this._getWorker(o, l).then((n => (r = n, new Promise(((n, l) => {
							r._callbacks[o] = {
								resolve: n,
								reject: l
							}, r.postMessage({
								type: "decode",
								id: o,
								taskConfig: e,
								buffer: t
							}, [t])
						}))))).then((t => this._createGeometry(t.geometry)));
					return c.catch((() => !0)).then((() => {
						r && o && this._releaseTask(r, o)
					})), te.set(t, {
						key: n,
						promise: c
					}), c
				}
				_createGeometry(t) {
					const e = new r.l;
					t.index && e.setIndex(new r.k(t.index.array, 1));
					for (let i = 0; i < t.attributes.length; i++) {
						const n = t.attributes[i],
							o = n.name,
							l = n.array,
							c = n.itemSize;
						e.setAttribute(o, new r.k(l, c))
					}
					return e
				}
				_loadLibrary(t, e) {
					const n = new r.D(this.manager);
					return n.setPath(this.decoderPath), n.setResponseType(e), n.setWithCredentials(this.withCredentials), new Promise(((e, r) => {
						n.load(t, e, void 0, r)
					}))
				}
				preload() {
					return this._initDecoder(), this
				}
				_initDecoder() {
					if (this.decoderPending) return this.decoderPending;
					const t = "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
						e = [];
					return t ? e.push(this._loadLibrary("draco_decoder.js", "text")) : (e.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), e.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(e).then((e => {
						const n = e[0];
						t || (this.decoderConfig.wasmBinary = e[1]);
						const r = ne.toString(),
							body = ["/* draco decoder */", n, "", "/* worker */", r.substring(r.indexOf("{") + 1, r.lastIndexOf("}"))].join("\n");
						this.workerSourceURL = URL.createObjectURL(new Blob([body]))
					})), this.decoderPending
				}
				_getWorker(t, e) {
					return this._initDecoder().then((() => {
						if (this.workerPool.length < this.workerLimit) {
							const t = new Worker(this.workerSourceURL);
							t._callbacks = {}, t._taskCosts = {}, t._taskLoad = 0, t.postMessage({
								type: "init",
								decoderConfig: this.decoderConfig
							}), t.onmessage = function(e) {
								const n = e.data;
								switch (n.type) {
									case "decode":
										t._callbacks[n.id].resolve(n);
										break;
									case "error":
										t._callbacks[n.id].reject(n);
										break;
									default:
										console.error('THREE.DRACOLoader: Unexpected message, "' + n.type + '"')
								}
							}, this.workerPool.push(t)
						} else this.workerPool.sort((function(a, b) {
							return a._taskLoad > b._taskLoad ? -1 : 1
						}));
						const n = this.workerPool[this.workerPool.length - 1];
						return n._taskCosts[t] = e, n._taskLoad += e, n
					}))
				}
				_releaseTask(t, e) {
					t._taskLoad -= t._taskCosts[e], delete t._callbacks[e], delete t._taskCosts[e]
				}
				debug() {
					console.log("Task load: ", this.workerPool.map((t => t._taskLoad)))
				}
				dispose() {
					for (let i = 0; i < this.workerPool.length; ++i) this.workerPool[i].terminate();
					return this.workerPool.length = 0, this
				}
			}

			function ne() {
				let t, e;

				function n(t, e, n, r, o, l) {
					const c = l.num_components(),
						h = n.num_points() * c,
						d = h * o.BYTES_PER_ELEMENT,
						f = function(t, e) {
							switch (e) {
								case Float32Array:
									return t.DT_FLOAT32;
								case Int8Array:
									return t.DT_INT8;
								case Int16Array:
									return t.DT_INT16;
								case Int32Array:
									return t.DT_INT32;
								case Uint8Array:
									return t.DT_UINT8;
								case Uint16Array:
									return t.DT_UINT16;
								case Uint32Array:
									return t.DT_UINT32
							}
						}(t, o),
						m = t._malloc(d);
					e.GetAttributeDataArrayForAllPoints(n, l, f, d, m);
					const v = new o(t.HEAPF32.buffer, m, h).slice();
					return t._free(m), {
						name: r,
						array: v,
						itemSize: c
					}
				}
				onmessage = function(r) {
					const o = r.data;
					switch (o.type) {
						case "init":
							t = o.decoderConfig, e = new Promise((function(e) {
								t.onModuleLoaded = function(t) {
									e({
										draco: t
									})
								}, DracoDecoderModule(t)
							}));
							break;
						case "decode":
							const r = o.buffer,
								l = o.taskConfig;
							e.then((t => {
								const e = t.draco,
									c = new e.Decoder,
									h = new e.DecoderBuffer;
								h.Init(new Int8Array(r), r.byteLength);
								try {
									const t = function(t, e, r, o) {
											const l = o.attributeIDs,
												c = o.attributeTypes;
											let h, d;
											const f = e.GetEncodedGeometryType(r);
											if (f === t.TRIANGULAR_MESH) h = new t.Mesh, d = e.DecodeBufferToMesh(r, h);
											else {
												if (f !== t.POINT_CLOUD) throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
												h = new t.PointCloud, d = e.DecodeBufferToPointCloud(r, h)
											}
											if (!d.ok() || 0 === h.ptr) throw new Error("THREE.DRACOLoader: Decoding failed: " + d.error_msg());
											const m = {
												index: null,
												attributes: []
											};
											for (const r in l) {
												const d = self[c[r]];
												let f, v;
												if (o.useUniqueIDs) v = l[r], f = e.GetAttributeByUniqueId(h, v);
												else {
													if (v = e.GetAttributeId(h, t[l[r]]), -1 === v) continue;
													f = e.GetAttribute(h, v)
												}
												m.attributes.push(n(t, e, h, r, d, f))
											}
											f === t.TRIANGULAR_MESH && (m.index = function(t, e, n) {
												const r = 3 * n.num_faces(),
													o = 4 * r,
													l = t._malloc(o);
												e.GetTrianglesUInt32Array(n, o, l);
												const c = new Uint32Array(t.HEAPF32.buffer, l, r).slice();
												return t._free(l), {
													array: c,
													itemSize: 1
												}
											}(t, e, h));
											return t.destroy(h), m
										}(e, c, h, l),
										r = t.attributes.map((t => t.array.buffer));
									t.index && r.push(t.index.array.buffer), self.postMessage({
										type: "decode",
										id: o.id,
										geometry: t
									}, r)
								} catch (t) {
									console.error(t), self.postMessage({
										type: "error",
										id: o.id,
										error: t.message
									})
								} finally {
									e.destroy(h), e.destroy(c)
								}
							}))
					}
				}
			}
			class ie extends r.jb {
				constructor(t, e = {}) {
					super(t), this.type = "Reflector";
					const n = this,
						o = void 0 !== e.color ? new r.o(e.color) : new r.o(8355711),
						l = e.textureWidth || 512,
						c = e.textureHeight || 512,
						h = e.clipBias || 0,
						d = e.shader || ie.ReflectorShader,
						f = new r.Bb,
						m = new r.ic,
						v = new r.ic,
						y = new r.ic,
						x = new r.ib,
						_ = new r.ic(0, 0, -1),
						w = new r.jc,
						view = new r.ic,
						A = new r.ic,
						q = new r.jc,
						M = new r.ib,
						S = new r.Ab,
						T = new r.nc(l, c),
						E = new r.Rb({
							uniforms: r.dc.clone(d.uniforms),
							fragmentShader: d.fragmentShader,
							vertexShader: d.vertexShader
						});
					E.uniforms.tDiffuse.value = T.texture, E.uniforms.color.value = o, E.uniforms.textureMatrix.value = M, this.material = E, this.onBeforeRender = function(t, e, r) {
						if (v.setFromMatrixPosition(n.matrixWorld), y.setFromMatrixPosition(r.matrixWorld), x.extractRotation(n.matrixWorld), m.set(0, 0, 1), m.applyMatrix4(x), view.subVectors(v, y), view.dot(m) > 0) return;
						view.reflect(m).negate(), view.add(v), x.extractRotation(r.matrixWorld), _.set(0, 0, -1), _.applyMatrix4(x), _.add(y), A.subVectors(v, _), A.reflect(m).negate(), A.add(v), S.position.copy(view), S.up.set(0, 1, 0), S.up.applyMatrix4(x), S.up.reflect(m), S.lookAt(A), S.far = r.far, S.updateMatrixWorld(), S.projectionMatrix.copy(r.projectionMatrix), M.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), M.multiply(S.projectionMatrix), M.multiply(S.matrixWorldInverse), M.multiply(n.matrixWorld), f.setFromNormalAndCoplanarPoint(m, v), f.applyMatrix4(S.matrixWorldInverse), w.set(f.normal.x, f.normal.y, f.normal.z, f.constant);
						const o = S.projectionMatrix;
						q.x = (Math.sign(w.x) + o.elements[8]) / o.elements[0], q.y = (Math.sign(w.y) + o.elements[9]) / o.elements[5], q.z = -1, q.w = (1 + o.elements[10]) / o.elements[14], w.multiplyScalar(2 / w.dot(q)), o.elements[2] = w.x, o.elements[6] = w.y, o.elements[10] = w.z + 1 - h, o.elements[14] = w.w, T.texture.encoding = t.outputEncoding, n.visible = !1;
						const l = t.getRenderTarget(),
							c = t.xr.enabled,
							d = t.shadowMap.autoUpdate;
						t.xr.enabled = !1, t.shadowMap.autoUpdate = !1, t.setRenderTarget(T), t.state.buffers.depth.setMask(!0), !1 === t.autoClear && t.clear(), t.render(e, S), t.xr.enabled = c, t.shadowMap.autoUpdate = d, t.setRenderTarget(l);
						const E = r.viewport;
						void 0 !== E && t.state.viewport(E), n.visible = !0
					}, this.getRenderTarget = function() {
						return T
					}, this.dispose = function() {
						T.dispose(), n.material.dispose()
					}
				}
			}
			ie.prototype.isReflector = !0, ie.ReflectorShader = {
				uniforms: {
					color: {
						value: null
					},
					tDiffuse: {
						value: null
					},
					textureMatrix: {
						value: null
					}
				},
				vertexShader: "\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",
				fragmentShader: "\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t}"
			};
			var re = class {
					__config() {
						return se
					}
					constructor(element, t = {}) {
						new(this.__config())(this, element, t), Pe(this, "update", {
							loader: this.__loader,
							world: this.__update
						}), this._create(t), this._ready(t), this._time = new ae
					}
					_create(t) {}
					_ready(t) {
						0 === be().load.total && this._prerender(t)
					}
					destroy() {
						this.off(), this._destroy(), this._story.destroy(), be().destroy()
					}
					_destroy() {}
					resize(t, e, n) {
						be().resize(t, e, n), this._story.resize(be().width, be().height), this._resize(be().width, be().height)
					}
					_resize(t, e) {}
					_loadStart(t) {}
					_loadProgress(t) {}
					_loadComplete(t) {
						this._prerender(t)
					}
					_prerender(t) {
						this._story.prerender(),
							function(t, e, n = 30, r = 150) {
								let time = Date.now(),
									o = 0,
									l = 0;

								function c() {
									const h = Date.now();
									o = 1e3 / (h - time) >= t ? o + 1 : 0, l++, time = h, o < n && l < r ? requestAnimationFrame(c) : e()
								}
								requestAnimationFrame(c)
							}(55, (() => {
								this._time.set(0), this.update.set("world"), this._start(t)
							}))
					}
					_start(t) {}
					__loader(dt) {
						this._story.loader(this._time, this._loader(this._time)), this._time.update(dt)
					}
					__update(dt) {
						this._story.update(this._time, this._update(this._time)), this._time.update(dt)
					}
					_loader(time) {}
					_update(time) {}
				},
				se = class {
					constructor(t, element, e = {}) {
						be(element, this._setupPillow(t, e)), oe(t), this._setupRenderer(t, be().renderer, e), this._setupModules(t, e).forEach((t => be().module(t))), t._story = new ge(this._setupStory(t, e))
					}
					_setupPillow(t, e) {
						return {
							powerPreference: "high-performance",
							antialias: !1,
							stencil: !1,
							depth: !1
						}
					}
					_setupRenderer(t, e, n) {}
					_setupModules(t, e) {
						const n = new Se(be().renderer, new De, e.path);
						return n.once("start", (n => t._loadStart(e))), n.on("progress", (n => t._loadProgress(e))), n.once("complete", (n => t._loadComplete(e))), [n, new Te(be().element)]
					}
					_setupStory(t, e) {
						return [new ve]
					}
				},
				ae = class {
					constructor() {
						this._FRAME = 1 / 60, this.dt = 0, this.et = 0, this.ft = 1
					}
					update(dt = this._FRAME) {
						this.dt = dt, this.ft = dt / this._FRAME, this.et += dt
					}
					set(t) {
						this.et = t
					}
				};

			function oe(t) {
				t.__radio = {}, t.on = le, t.once = ce, t.off = he, t.transmit = ue, t.transmits = de
			}

			function le(t, e) {
				this.__radio[t] || (this.__radio[t] = []), this.__radio[t].includes(e) || this.__radio[t].push(e)
			}

			function ce(t, e) {
				const n = r => {
					this.off(t, n), e(r)
				};
				this.on(t, n)
			}

			function he(t, e) {
				if (t)
					if (e) {
						if (this.__radio[t]) {
							const n = this.__radio[t].indexOf(e); - 1 !== n && this.__radio[t].splice(n, 1)
						}
					} else delete this.__radio[t];
				else this.__radio = {}
			}

			function ue(t, e = {}) {
				this.__radio[t] && this.__radio[t].forEach((n => n({
					signal: t,
					...e
				})))
			}

			function de(t, e) {
				return !(!this.__radio[t] || e && !this.__radio[t].includes(e))
			}
			var pe, fe = class {
					constructor(t) {
						oe(this), this._id = t
					}
					resize(t, e) {
						this._width = t, this._height = e, this._visibleWidth = be().visibleWidth, this._visibleHeight = be().visibleHeight, this._resize()
					}
					_resize() {}
					destroy() {
						this.off(), this._destroy()
					}
					_destroy() {}
					get id() {
						return this._id
					}
				},
				me = class {
					constructor(t = {}) {
						oe(this), this._element = t.element || document.createElement("div"), this._visible = !1, this._create(t)
					}
					_create(t) {}
					destroy() {
						this.off(), this._destroy()
					}
					_destroy() {}
					resize(t, e, n = {}) {
						this._resize(t, e, n)
					}
					_resize(t, e, n) {}
					move(t, e, n) {
						Be(this._element, t, e, n)
					}
					show(t = {}) {
						this._visible || (this._visible = !0, this._show(t))
					}
					hide(t = {}) {
						this._visible && (this._visible = !1, this._hide(t))
					}
					_show(t) {
						this._element.style.display = "block"
					}
					_hide(t) {
						this._element.style.display = "none"
					}
					update(time, t) {
						this._update(time, t)
					}
					_update(time, t) {}
				},
				ge = class {
					constructor(t = [new ve]) {
						this._scenes = t, this._scenes.forEach(((t, e) => {
							t.index = e
						})), this._scene = t[0]
					}
					destroy() {
						this._scenes.forEach((t => {
							t.destroy()
						}))
					}
					resize(t, e, n) {
						this._scenes.forEach((r => {
							r.resize(t, e, n)
						}))
					}
					prerender() {
						this._scenes.forEach((t => {
							t.render(0)
						}))
					}
					action(t) {
						this._scenes.forEach((e => {
							t(e, e.index)
						}))
					}
					to(t, e) {
						const n = this._scenes[t];
						n && (this._scene.leave(e), this._scene = n, this._scene.enter(e))
					}
					next(t, e = !0) {
						const n = this._scene.index + 1;
						this.to(e ? this._loop(n) : n, t)
					}
					prev(t, e = !0) {
						const n = this._scene.index - 1;
						this.to(e ? this._loop(n) : n, t)
					}
					_loop(t) {
						return t < 0 ? this._scenes.length - 1 : t >= this._scenes.length ? 0 : t
					}
					loader(time, t = {}) {
						this._scene.loader(time, t), this._scene.render(time)
					}
					update(time, t = {}) {
						this._scene.update(time, t), this._scene.render(time)
					}
					get scene() {
						return this._scene
					}
				},
				ve = class extends r.Qb {
					constructor(t = {}) {
						super(), oe(this), this._camera = t.camera || this._setupCamera(t), this._renderer = be().renderer, this._setupComposer(this._setupEffects(t), t), this.__render = this._composer && !1 !== t.effects ? this.__composer : this.__renderer, t.background && (this.background = t.background), this._create(t)
					}
					_setupCamera(t) {
						return this._add(new ye(.1, 100, {
							fov: 50
						}))
					}
					_setupComposer(t, e) {
						t && (this._composer = new class {
							constructor(t = null, {
								depthBuffer: e = !0,
								stencilBuffer: n = !1,
								multisampling: r = 0,
								frameBufferType: o
							} = {}) {
								this.renderer = t, this.inputBuffer = null, this.outputBuffer = null, null !== this.renderer && (this.renderer.autoClear = !1, this.inputBuffer = this.createBuffer(e, n, o, r), this.outputBuffer = this.inputBuffer.clone()), this.copyPass = new k(new m), this.depthTexture = null, this.passes = [], this.autoRenderToScreen = !0
							}
							get multisampling() {
								return this.inputBuffer instanceof r.mc ? this.inputBuffer.samples : 0
							}
							set multisampling(t) {
								const e = this.inputBuffer,
									n = this.multisampling;
								n > 0 && t > 0 ? (this.inputBuffer.samples = t, this.outputBuffer.samples = t) : n !== t && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, t), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
							}
							getRenderer() {
								return this.renderer
							}
							replaceRenderer(t, e = !0) {
								const n = this.renderer;
								if (null !== n && n !== t) {
									const o = n.getSize(new r.hc),
										l = t.getSize(new r.hc),
										c = n.domElement.parentNode;
									this.renderer = t, this.renderer.autoClear = !1, o.equals(l) || this.setSize(), e && null !== c && (c.removeChild(n.domElement), c.appendChild(t.domElement))
								}
								return n
							}
							createDepthTexture() {
								const t = this.depthTexture = new r.y;
								return this.inputBuffer.depthTexture = t, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (t.format = r.x, t.type = r.fc) : t.type = r.gc, t
							}
							deleteDepthTexture() {
								if (null !== this.depthTexture) {
									this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
									for (const t of this.passes) t.setDepthTexture(null)
								}
							}
							createBuffer(t, e, n, o) {
								const l = this.renderer.getDrawingBufferSize(new r.hc),
									c = {
										format: this.renderer.getContext().getContextAttributes().alpha || n !== r.ec ? r.Lb : r.Mb,
										minFilter: r.X,
										magFilter: r.X,
										stencilBuffer: e,
										depthBuffer: t,
										type: n
									},
									h = o > 0 ? new r.mc(l.width, l.height, c) : new r.nc(l.width, l.height, c);
								return o > 0 && (h.samples = o), h.texture.name = "EffectComposer.Buffer", h.texture.generateMipmaps = !1, h
							}
							addPass(t, e) {
								const n = this.passes,
									o = this.renderer,
									l = o.getDrawingBufferSize(new r.hc),
									c = o.getContext().getContextAttributes().alpha,
									h = this.inputBuffer.texture.type;
								if (t.setSize(l.width, l.height), t.initialize(o, c, h), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), t.renderToScreen && (this.autoRenderToScreen = !1)), void 0 !== e ? n.splice(e, 0, t) : n.push(t), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), t.needsDepthTexture || null !== this.depthTexture)
									if (null === this.depthTexture) {
										const e = this.createDepthTexture();
										for (t of n) t.setDepthTexture(e)
									} else t.setDepthTexture(this.depthTexture)
							}
							removePass(t) {
								const e = this.passes,
									n = e.indexOf(t);
								if (-1 !== n && e.splice(n, 1).length > 0) {
									if (null !== this.depthTexture) {
										const n = (a, b) => a || b.needsDepthTexture;
										e.reduce(n, !1) || (t.getDepthTexture() === this.depthTexture && t.setDepthTexture(null), this.deleteDepthTexture())
									}
									this.autoRenderToScreen && n === e.length && (t.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0))
								}
							}
							removeAllPasses() {
								const t = this.passes;
								this.deleteDepthTexture(), t.length > 0 && (this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !1), this.passes = [])
							}
							render(t) {
								const e = this.renderer,
									n = this.copyPass;
								let r, o, l, c = this.inputBuffer,
									h = this.outputBuffer,
									d = !1;
								for (const f of this.passes) f.enabled && (f.render(e, c, h, t, d), f.needsSwap && (d && (n.renderToScreen = f.renderToScreen, r = e.getContext(), o = e.state.buffers.stencil, o.setFunc(r.NOTEQUAL, 1, 4294967295), n.render(e, c, h, t, d), o.setFunc(r.EQUAL, 1, 4294967295)), l = c, c = h, h = l), f instanceof z ? d = !0 : f instanceof S && (d = !1))
							}
							setSize(t, e, n) {
								const o = this.renderer;
								if (void 0 === t || void 0 === e) {
									const n = o.getSize(new r.hc);
									t = n.width, e = n.height
								} else o.setSize(t, e, n);
								const l = o.getDrawingBufferSize(new r.hc);
								this.inputBuffer.setSize(l.width, l.height), this.outputBuffer.setSize(l.width, l.height);
								for (const t of this.passes) t.setSize(l.width, l.height)
							}
							reset() {
								this.dispose(), this.autoRenderToScreen = !0
							}
							dispose() {
								for (const t of this.passes) t.dispose();
								this.passes = [], null !== this.inputBuffer && this.inputBuffer.dispose(), null !== this.outputBuffer && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose()
							}
						}(be().renderer), this._composer.addPass(new D(this, this._camera)), t.forEach((t => {
							this._composer.addPass(t)
						})))
					}
					_setupEffects(t) {}
					_create(t) {}
					_add(object, t = this) {
						return t.add(object), object
					}
					_container(object) {
						const t = new r.I;
						return object && this._add(object, t), t
					}
					destroy() {
						this.off(), this._destroy(), this._composer && this._composer.dispose(),
							function(t) {
								function e(t) {
									t.map && t.map.dispose(), t.lightMap && t.lightMap.dispose(), t.bumpMap && t.bumpMap.dispose(), t.normalMap && t.normalMap.dispose(), t.specularMap && t.specularMap.dispose(), t.envMap && t.envMap.dispose(), t.alphaMap && t.alphaMap.dispose(), t.aoMap && t.aoMap.dispose(), t.displacementMap && t.displacementMap.dispose(), t.emissiveMap && t.emissiveMap.dispose(), t.gradientMap && t.gradientMap.dispose(), t.metalnessMap && t.metalnessMap.dispose(), t.roughnessMap && t.roughnessMap.dispose(), t.dispose()
								}
								t.traverse((object => {
									object.geometry && object.geometry.dispose(), object.material && (object.material.length ? object.material.forEach((t => e(t))) : e(object.material)), object.isLight && object.shadow && object.shadow.map && object.shadow.map.dispose()
								}))
							}(this)
					}
					_destroy() {}
					resize(t, e, n = {}) {
						this._camera.resize(t, e), this._composer && this._composer.setSize(t, e), this._resize(t, e, n)
					}
					_resize(t, e, n) {}
					enter(t = {}) {
						this._enter(t)
					}
					_enter(t) {}
					leave(t = {}) {
						this._leave(t)
					}
					_leave(t) {}
					loader(time, t) {
						this._loader(time, t)
					}
					_loader(time, t) {}
					update(time, t) {
						this._update(time, t)
					}
					_update(time, t) {}
					render(time) {
						this.__render(time)
					}
					__renderer(time) {
						this._renderer.render(this, this._camera)
					}
					__composer({
						dt: dt
					}) {
						this._composer.render(dt)
					}
					get index() {
						return this._index
					}
					set index(t) {
						this._index = t
					}
					get camera() {
						return this._camera
					}
				},
				ye = class {
					constructor(t = .1, e = 100, n = {}) {
						const o = n.fov,
							l = o ? new r.Ab(n.fov, window.innerWidth / window.innerHeight, t, e) : new r.zb(.5 * -window.innerWidth, .5 * window.innerWidth, .5 * window.innerHeight, .5 * -window.innerHeight, t, e);
						return l.resize = o ? this.__perspective : this.__orthographic, l.getFrame = o ? this.__perspectiveFrame : this.__orthographicFrame, l.update = this.update, this._create(n), this._construct(l), l
					}
					_construct(t) {
						[...Object.getOwnPropertyNames(this), ...Object.getOwnPropertyNames(Object.getPrototypeOf(this))].forEach((e => t[e] = this[e]))
					}
					_create(t) {}
					__perspective(t, e) {
						this.aspect = t / e, this.updateProjectionMatrix()
					}
					__orthographic(t, e) {
						this.left = .5 * -t, this.right = .5 * t, this.top = .5 * e, this.bottom = .5 * -e, this.updateProjectionMatrix()
					}
					__perspectiveFrame(t) {
						const e = this.fov * Math.PI / 180,
							n = 2 * Math.tan(.5 * e) * this.position.distanceTo(t);
						return {
							width: n * this.aspect,
							height: n
						}
					}
					__orthographicFrame(t) {
						return {
							width: be().width,
							height: be().height
						}
					}
					update(time, t) {
						this._update(time, t)
					}
					_update(time, t) {}
				},
				xe = class extends r.yb {
					constructor(t = {}) {
						super(), oe(this), this._create(t)
					}
					_create(t) {}
					_add(object, t = this) {
						return t.add(object), object
					}
					_container(object) {
						const t = new r.I;
						return object && this._add(object, t), t
					}
					_design(t, e = {}) {
						this.position.copy(t.position), this._model = this._add(t), this._model.position.set(0, 0, 0), this._construct(this._model, e)
					}
					_construct(t, e) {
						Object.entries(e).forEach((e => {
							"string" == typeof e[1] ? this[e[0]] = t.getObjectByName(e[1]) : this[e[0]] = e[1][1](t.getObjectByName(e[1][0]))
						}))
					}
					destroy() {
						this.off(), this._destroy()
					}
					_destroy() {}
					resize(t, e, n = {}) {
						this._resize(t, e, n)
					}
					_resize(t, e, n) {}
					show(t = {}) {
						this._visible || (this._visible = !0, this._show(t))
					}
					hide(t = {}) {
						(void 0 === this._visible || this._visible) && (this._visible = !1, this._hide(t))
					}
					_show(t) {
						this.visible = !0
					}
					_hide(t) {
						this.visible = !1
					}
					update(time, t) {
						this._update(time, t)
					}
					_update(time, t) {}
				},
				_e = class extends xe {
					constructor(t = {}) {
						super(t), this._range = 0, this._timeline = Z.a.timeline({
							paused: !0
						}), this._timeline.set(this, {
							_range: 1
						}, 1), this._setupTimeline(t), this._timeline.progress(1, !0), this._timeline.progress(0, !0)
					}
					_setupTimeline(t) {}
					_animate(t, e, n, r, o) {
						this._timeline.fromTo(t, r, {
							ease: "none",
							...o,
							duration: n - e
						}, e)
					}
					_set(t, time, e) {
						this._timeline.set(t, e, time)
					}
					_trigger(t, time) {
						this._timeline.add(t, time)
					}
					_update(time, {
						progress: progress
					}) {
						this._timeline.progress(progress)
					}
				},
				we = class extends ve {
					constructor(t = {}) {
						super(t), this._output = this._setupOutput(t)
					}
					_setupOutput(t) {
						return new r.nc(window.innerWidth, window.innerHeight, t)
					}
					destroy() {
						this._output.dispose(), super.destroy()
					}
					resize(t, e, n) {
						super.resize(t, e, n), this._resizeOutput(t, e)
					}
					_resizeOutput(t, e) {
						this._output.setSize(t, e)
					}
					update(time, t) {
						super.update(time, t), this._renderer.setRenderTarget(this._output), this._renderer.clear(), this.render(time), this._renderer.setRenderTarget(null)
					}
					get output() {
						return this._output.texture
					}
				},
				Ae = class extends M {
					constructor(t, e, n, o) {
						super(t), this._material = new r.Rb({
							vertexShader: e || Ce,
							fragmentShader: n || Re,
							uniforms: {
								...o,
								_input: {
									value: null
								}
							}
						}), this.setFullscreenMaterial(this._material)
					}
					destroy() {
						this._material.dispose(), this._destroy()
					}
					_destroy() {}
					setSize(t, e) {
						this._width = t, this._height = e, this._resize()
					}
					_resize() {}
					update(time, t = {}) {
						this._update(time, t)
					}
					_update(time, t) {}
					render(t, e, n) {
						this._material.uniforms._input.value = e.texture, t.setRenderTarget(this.renderToScreen ? null : n), t.render(this.scene, this.camera)
					}
					_uniform(t, e) {
						this._material.uniforms[t].value = e
					}
				},
				be = (element, t) => pe = pe || new class {
					constructor(element, t = {}) {
						oe(this), this._renderer = new r.oc(t), this._canvas = this._renderer.domElement, this._canvas.style.position = "absolute", this._element = element, this._element.appendChild(this._canvas), this._modules = [], this._minAspectRatio = t.minAspectRatio || 0, this._maxAspectRatio = t.maxAspectRatio || 2
					}
					module(t) {
						this._modules.push(this[t.id] = t)
					}
					destroy() {
						this.off(), this._modules.forEach((t => {
							t.destroy()
						}))
					}
					resize(t, e, n) {
						this._width = this._visibleWidth = t, this._height = this._visibleHeight = e, this._pixelRatio = Math.min(n, 2), this._applyAspectRatio(this._width, this._height), this._renderer.setSize(this._width, this._height), this._renderer.setPixelRatio(this._pixelRatio), this._modules.forEach((t => t.resize(this._width, this._height)))
					}
					_applyAspectRatio(t, e) {
						const n = t / e;
						n < this._minAspectRatio ? (this._width *= this._minAspectRatio / n, this._width = Math.round(this._width), this._canvas.style.top = 0, this._canvas.style.left = `-${.5*(this._width-t)}px`) : n > this._maxAspectRatio ? (this._height *= n / this._maxAspectRatio, this._height = Math.round(this._height), this._canvas.style.top = `-${.5*(this._height-e)}px`, this._canvas.style.left = 0) : (this._canvas.style.top = 0, this._canvas.style.left = 0)
					}
					get element() {
						return this._element
					}
					get renderer() {
						return this._renderer
					}
					get width() {
						return this._width
					}
					get height() {
						return this._height
					}
					get visibleWidth() {
						return this._visibleWidth
					}
					get visibleHeight() {
						return this._visibleHeight
					}
					get pixelRatio() {
						return this._pixelRatio
					}
				}(element, t),
				Me = class extends Ae {
					constructor(t, e, n, o, l = 1) {
						super(t, e, n, {
							...o,
							_buffer: {
								value: null
							}
						}), this._prev = new r.nc(window.innerWidth, window.innerHeight, {
							minFilter: r.rb,
							magFilter: r.rb
						}), this._next = new r.nc(window.innerWidth, window.innerHeight, {
							minFilter: r.rb,
							magFilter: r.rb
						}), this._scale = l
					}
					_destroy() {
						this._prev.dispose(), this._next.dispose()
					}
					setSize(t, e) {
						this._prev.setSize(t * this._scale, e * this._scale), this._next.setSize(t * this._scale, e * this._scale), super.setSize(t, e)
					}
					render(t, e, n) {
						this._material.uniforms._buffer.value = this._prev.texture, super.render(t, e, n), t.setRenderTarget(this._next), t.render(this.scene, this.camera);
						const r = this._prev;
						this._prev = this._next, this._next = r
					}
				},
				Se = class extends fe {
					constructor(t, e, path = "") {
						super("load"), this._renderer = t, this._cache = e, this._path = `${path}/`, this._itemsStart = 0, this._itemsLoaded = 0, this._itemsTotal = 0, this._progress = 0, this._setup()
					}
					_setup() {
						this._manager = new r.db, this._manager.onStart = (t, e, n) => {
							this._onStart(t, e, n)
						}, this._manager.onProgress = (t, e, n) => {
							this._onProgress(t, e, n)
						}, this._manager.onError = t => {
							this._onError(t)
						}, this._DRACO = new ee, this._DRACO.setDecoderPath("./draco/")
					}
					model(source, t = (t => {})) {
						const e = new $(this._manager);
						e.setDRACOLoader(this._DRACO), e.load(`${this._path}${source}`, (e => {
							t(e)
						}))
					}
					texture(source, t = {}, e = (t => {})) {
						const image = this._cache.retrieve(source);
						if (image) {
							const n = new r.Xb(image);
							return Ie(n, t).needsUpdate = !0, this._renderer.initTexture(n), e(n), n
						}
						return Ie(new r.Yb(this._manager).load(`${this._path}${source}`, (t => {
							this._cache.store(source, t.image), this._renderer.initTexture(t), e(t)
						})), t)
					}
					cubeTexture(source, t, e = {}, n = (t => {})) {
						const o = this._cache.retrieve(source);
						if (o) {
							const t = new r.s(o);
							return Ie(t, e).needsUpdate = !0, n(t), t
						}
						Ie(new r.t(this._manager).setPath(`${this._path}${source}/`).load([`px.${t}`, `nx.${t}`, `py.${t}`, `ny.${t}`, `pz.${t}`, `nz.${t}`], (t => {
							this._cache.store(source, t.images), n(t)
						})), e)
					}
					audio(source, t, e = !1, n = (audio => {})) {
						const audio = new(e ? r.Gb : r.c)(t),
							o = this._cache.retrieve(source);
						return o ? (audio.setBuffer(o), n(audio)) : new r.f(this._manager).load(`${this._path}${source}`, (t => {
							this._cache.store(source, t), audio.setBuffer(t), n(audio)
						})), audio
					}
					_onStart(t, e, n) {
						this._itemsStart = e, this._itemsTotal = n - this._itemsStart, this._progress = 0, this.transmit("start")
					}
					_onProgress(t, e, n) {
						this._itemsLoaded = e - this._itemsStart, this._itemsTotal = n - this._itemsStart, this._progress = this._itemsLoaded / this._itemsTotal, this.transmit("progress"), e === n && this.transmit("complete")
					}
					_onError(t) {
						console.warn("PillowLoader.ERROR:", t)
					}
					get current() {
						return this._itemsLoaded
					}
					get total() {
						return this._itemsTotal
					}
					get progress() {
						return this._progress
					}
				},
				Te = class extends fe {
					constructor(element) {
						super("touch"), this._x = 0, this._y = 0, this._down = !1, this._location = {
							x: 0,
							y: 0
						}, this._target = {
							x: 0,
							y: 0
						}, this._velocity = {
							x: 0,
							y: 0
						}, this._setupEvents(element)
					}
					_onDown(t, e) {
						this._onMove(t, e), this._down = !0, this.transmit("down")
					}
					_onUp(t, e) {
						this._onMove(t, e), this._down = !1, this.transmit("up")
					}
					_onMove(t, e) {
						this._x = t, this._y = e, this._target.x = t / this._visibleWidth * 2 - 1, this._target.y = e / this._visibleHeight * 2 - 1, this.transmit("move")
					}
					ease(t) {
						this._location.x += (this._target.x - this._location.x) * t, this._location.y += (this._target.y - this._location.y) * t
					}
					spring(t, e) {
						this._velocity.x += (this._target.x - this._location.x) * t, this._velocity.y += (this._target.y - this._location.y) * t, this._velocity.x *= e, this._velocity.y *= e, this._location.x += this._velocity.x, this._location.y += this._velocity.y
					}
					get x() {
						return this._x
					}
					get y() {
						return this._y
					}
					get down() {
						return this._down
					}
					get location() {
						return this._location
					}
					get target() {
						return this._target
					}
					get velocity() {
						return this._velocity
					}
					_setupEvents(element) {
						const t = window.PointerEvent ? "pointer" : "mouse";
						element.addEventListener(`${t}down`, (({
							clientX: t,
							clientY: e
						}) => this._onDown(t, e))), document.addEventListener(`${t}up`, (({
							clientX: t,
							clientY: e
						}) => this._onUp(t, e))), document.addEventListener(`${t}move`, (({
							clientX: t,
							clientY: e
						}) => this._onMove(t, e))), !window.PointerEvent && window.TouchEvent && (element.addEventListener("touchstart", (({
							changedTouches: t
						}) => this._onDown(t[0].clientX, t[0].clientY))), document.addEventListener("touchend", (({
							changedTouches: t
						}) => this._onUp(t[0].clientX, t[0].clientY))), document.addEventListener("touchmove", (({
							changedTouches: t
						}) => this._onMove(t[0].clientX, t[0].clientY))))
					}
				};
			var Ee = class extends fe {
					constructor(t = 1) {
						super("pulse"), this._listener = new r.e, this._context = this._listener.context,
							function(t, e, n) {
								var r;

								function o(t, e, n, r, o) {
									for (var i = 0; i < e.length; ++i) t.addEventListener(e[i], n, {
										capture: r,
										passive: o
									})
								}

								function l(t, e, n, r, o) {
									for (var i = 0; i < e.length; ++i) t.removeEventListener(e[i], n, {
										capture: r,
										passive: o
									})
								}

								function c() {}
								void 0 === e && (e = !1), void 0 === n && (n = !1), void 0 !== document.hidden ? r = {
									hidden: "hidden",
									visibilitychange: "visibilitychange"
								} : void 0 !== document.webkitHidden ? r = {
									hidden: "webkitHidden",
									visibilitychange: "webkitvisibilitychange"
								} : void 0 !== document.mozHidden ? r = {
									hidden: "mozHidden",
									visibilitychange: "mozvisibilitychange"
								} : void 0 !== document.msHidden && (r = {
									hidden: "msHidden",
									visibilitychange: "msvisibilitychange"
								});
								var h = navigator.userAgent.toLowerCase(),
									d = n || h.indexOf("iphone") >= 0 && h.indexOf("like iphone") < 0 || h.indexOf("ipad") >= 0 && h.indexOf("like ipad") < 0 || h.indexOf("ipod") >= 0 && h.indexOf("like ipod") < 0 || h.indexOf("mac os x") >= 0 && navigator.maxTouchPoints > 0,
									f = !0;

								function m() {
									var t = !(!e && (r && document[r.hidden] || d && !document.hasFocus()));
									t !== f && (f = t, S(!1), x())
								}

								function v() {
									m()
								}

								function y(t) {
									t && t.target !== window || m()
								}

								function x() {
									var p;
									f ? "running" !== t.state && "closed" !== t.state && C && (p = t.resume()) && p.then(c, c).catch(c) : "running" === t.state && (p = t.suspend()) && p.then(c, c).catch(c)
								}

								function _(t) {
									t && t.unmute_handled || (t.unmute_handled = !0, x())
								}
								r && o(document, [r.visibilitychange], v, !0, !0), d && o(window, ["focus", "blur"], y, !0, !0), o(t, ["statechange"], _, !0, !0), t.onstatechange || (t.onstatechange = _);
								var w = null;

								function A(t, e) {
									for (var n = e; t > 1; t--) n += e;
									return n
								}
								var M = "data:audio/mpeg;base64,//uQx" + A(23, "A") + "WGluZwAAAA8AAAACAAACcQCA" + A(16, "gICA") + A(66, "/") + "8AAABhTEFNRTMuMTAwA8MAAAAAAAAAABQgJAUHQQAB9AAAAnGMHkkI" + A(320, "A") + "//sQxAADgnABGiAAQBCqgCRMAAgEAH" + A(15, "/") + "7+n/9FTuQsQH//////2NG0jWUGlio5gLQTOtIoeR2WX////X4s9Atb/JRVCbBUpeRUq" + A(18, "/") + "9RUi0f2jn/+xDECgPCjAEQAABN4AAANIAAAAQVTEFNRTMuMTAw" + A(97, "V") + "Q==";

								function S(t) {
									if (d)
										if (f) {
											if (t) {
												if (!w) {
													var e = document.createElement("div");
													e.innerHTML = "<audio x-webkit-airplay='deny'></audio>", (w = e.children.item(0)).controls = !1, w.disableRemotePlayback = !0, w.preload = "auto", w.src = M, w.loop = !0, w.load()
												}
												if (w.paused) {
													var p = w.play();
													p && p.then(c, T).catch(T)
												}
											}
										} else T()
								}

								function T() {
									w && (w.src = "about:blank", w.load(), w = null)
								}
								var E = ["click", "contextmenu", "auxclick", "dblclick", "mousedown", "mouseup", "touchend", "keydown", "keyup"],
									C = !1;

								function R() {
									C = !0, S(!0), x()
								}
								o(window, E, R, !0, !0)
							}(this._context), this._audio = {}, this.volume = t, this._muted = !1
					}
					audio(t, source, {
						position: e = !1,
						volume: n = 1,
						rate: o = 1,
						loop: l,
						offset: c = 0,
						autoplay: h,
						analyse: d = 0
					}, f = (audio => {})) {
						return this._audio[t] = be().load.audio(source, this._listener, e, (audio => {
							audio.setVolume(n), audio.setPlaybackRate(o), audio.setLoop(l), audio.offset = c, h && audio.play();
							const t = audio.buffer;
							if (audio.getDuration = () => t.duration, d) {
								const t = new r.d(audio, d);
								audio.getData = () => t.getFrequencyData(), audio.getAverage = () => t.getAverageFrequency()
							}
							f(audio)
						}))
					}
					get(t) {
						return t ? this._audio[t] : this._audio
					}
					mute() {
						this._muted = !0, this._listener.setMasterVolume(0)
					}
					unmute() {
						this._muted = !1, this._updateVolume()
					}
					_updateVolume() {
						this._muted || this._listener.setMasterVolume(this._volume)
					}
					get time() {
						return this._context.currentTime
					}
					get volume() {
						return this._listener.getMasterVolume()
					}
					set volume(t) {
						this._volume = t, this._updateVolume()
					}
					get muted() {
						return this._muted
					}
				},
				Ce = "precision highp float;\n#define GLSLIFY 1\nvarying vec2 _uv;void main(void){_uv=uv;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}",
				Re = "precision highp float;\n#define GLSLIFY 1\nvarying vec2 _uv;void main(void){gl_FragColor=vec4(1.0);}";
			var De = class {
				constructor() {
					this._storage = []
				}
				store(t, data) {
					const e = this._storage.findIndex((e => e.id === t)); - 1 !== e ? this._storage[e].data = data : this._storage.push({
						id: t,
						data: data
					})
				}
				retrieve(t) {
					const e = this._storage.find((e => e.id === t));
					if (e) return e.data
				}
				remove(t) {
					const e = this._storage.findIndex((e => e.id === t));
					if (-1 !== e) return this._storage.splice(e, 1)[0].data
				}
				clear() {
					this._storage = []
				}
			};

			function Le(t) {
				let e = 0,
					n = Date.now(),
					r = requestAnimationFrame((function o() {
						r = requestAnimationFrame(o);
						const l = Date.now(),
							dt = l - n;
						e += dt, n = l, t(dt, e)
					}));
				return document.addEventListener("visibilitychange", (() => {
					n = Date.now()
				})), () => {
					cancelAnimationFrame(r)
				}
			}

			function Pe(object, t, e) {
				Object.values(e).forEach((n => {
					n.set = n => {
						e[n] && (object[t] = e[n])
					}
				})), object[t] = Object.values(e)[0]
			}

			function Ie(object, t = {}) {
				return Object.entries(t).forEach((t => object[t[0]] = t[1])), object
			}

			function Be(t, e = 0, n = 0, r = 0) {
				t.style.transform = `translate3d(${e}px, ${n}px, ${r}px)`
			}

			function Oe(t, e) {
				return (t % e + e) % e
			}
			Math.PI;
			var Fe = 2 * Math.PI,
				He = .5 * Math.PI
		},
		218: function(t, e, n) {
			"use strict";

			function r(t) {
				if (void 0 === t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
				return t
			}

			function o(t, e) {
				t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
			}
			n.d(e, "a", (function() {
				return qi
			}));
			var l, c, h, d, f, m, v, y, x, _, w, A, M, S, T, E, C, R, D, L, P, I, B, O, F, H, N, U, z = {
					autoSleep: 120,
					force3D: "auto",
					nullTargetWarn: 1,
					units: {
						lineHeight: ""
					}
				},
				k = {
					duration: .5,
					overwrite: !1,
					delay: 0
				},
				G = 1e8,
				V = 1e-8,
				W = 2 * Math.PI,
				j = W / 4,
				X = 0,
				Y = Math.sqrt,
				Q = Math.cos,
				J = Math.sin,
				K = function(t) {
					return "string" == typeof t
				},
				Z = function(t) {
					return "function" == typeof t
				},
				$ = function(t) {
					return "number" == typeof t
				},
				tt = function(t) {
					return void 0 === t
				},
				et = function(t) {
					return "object" == typeof t
				},
				nt = function(t) {
					return !1 !== t
				},
				it = function() {
					return "undefined" != typeof window
				},
				st = function(t) {
					return Z(t) || K(t)
				},
				at = "function" == typeof ArrayBuffer && ArrayBuffer.isView || function() {},
				ot = Array.isArray,
				lt = /(?:-?\.?\d|\.)+/gi,
				ct = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
				ht = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
				ut = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
				pt = /[+-]=-?[.\d]+/,
				ft = /[^,'"\[\]\s]+/gi,
				mt = /[\d.+\-=]+(?:e[-+]\d*)*/i,
				gt = {},
				vt = {},
				yt = function(t) {
					return (vt = Vt(t, gt)) && Pn
				},
				xt = function(t, e) {
					return console.warn("Invalid property", t, "set to", e, "Missing plugin? gsap.registerPlugin()")
				},
				_t = function(t, e) {
					return !e && console.warn(t)
				},
				wt = function(t, e) {
					return t && (gt[t] = e) && vt && (vt[t] = e) || gt
				},
				At = function() {
					return 0
				},
				bt = {},
				Mt = [],
				St = {},
				Tt = {},
				Et = {},
				Ct = 30,
				Rt = [],
				Dt = "",
				Lt = function(t) {
					var e, i, n = t[0];
					if (et(n) || Z(n) || (t = [t]), !(e = (n._gsap || {}).harness)) {
						for (i = Rt.length; i-- && !Rt[i].targetTest(n););
						e = Rt[i]
					}
					for (i = t.length; i--;) t[i] && (t[i]._gsap || (t[i]._gsap = new en(t[i], e))) || t.splice(i, 1);
					return t
				},
				Pt = function(t) {
					return t._gsap || Lt(_e(t))[0]._gsap
				},
				It = function(t, e, n) {
					return (n = t[e]) && Z(n) ? t[e]() : tt(n) && t.getAttribute && t.getAttribute(e) || n
				},
				Bt = function(t, e) {
					return (t = t.split(",")).forEach(e) || t
				},
				Ot = function(t) {
					return Math.round(1e5 * t) / 1e5 || 0
				},
				Ft = function(t) {
					return Math.round(1e7 * t) / 1e7 || 0
				},
				Ht = function(t, e) {
					for (var n = e.length, i = 0; t.indexOf(e[i]) < 0 && ++i < n;);
					return i < n
				},
				Nt = function() {
					var i, t, e = Mt.length,
						a = Mt.slice(0);
					for (St = {}, Mt.length = 0, i = 0; i < e; i++)(t = a[i]) && t._lazy && (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0)
				},
				Ut = function(t, time, e, n) {
					Mt.length && Nt(), t.render(time, e, n), Mt.length && Nt()
				},
				zt = function(t) {
					var e = parseFloat(t);
					return (e || 0 === e) && (t + "").match(ft).length < 2 ? e : K(t) ? t.trim() : t
				},
				kt = function(p) {
					return p
				},
				Gt = function(t, e) {
					for (var p in e) p in t || (t[p] = e[p]);
					return t
				},
				Vt = function(base, t) {
					for (var p in t) base[p] = t[p];
					return base
				},
				Wt = function t(base, e) {
					for (var p in e) "__proto__" !== p && "constructor" !== p && "prototype" !== p && (base[p] = et(e[p]) ? t(base[p] || (base[p] = {}), e[p]) : e[p]);
					return base
				},
				jt = function(t, e) {
					var p, n = {};
					for (p in t) p in e || (n[p] = t[p]);
					return n
				},
				Xt = function(t) {
					var e, n = t.parent || c,
						r = t.keyframes ? (e = ot(t.keyframes), function(t, n) {
							for (var p in n) p in t || "duration" === p && e || "ease" === p || (t[p] = n[p])
						}) : Gt;
					if (nt(t.inherit))
						for (; n;) r(t, n.vars.defaults), n = n.parent || n._dp;
					return t
				},
				Yt = function(t, e, n, r) {
					void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
					var o = e._prev,
						l = e._next;
					o ? o._next = l : t[n] === e && (t[n] = l), l ? l._prev = o : t[r] === e && (t[r] = o), e._next = e._prev = e.parent = null
				},
				Qt = function(t, e) {
					t.parent && (!e || t.parent.autoRemoveChildren) && t.parent.remove(t), t._act = 0
				},
				qt = function(t, e) {
					if (t && (!e || e._end > t._dur || e._start < 0))
						for (var a = t; a;) a._dirty = 1, a = a.parent;
					return t
				},
				Jt = function(t) {
					for (var e = t.parent; e && e.parent;) e._dirty = 1, e.totalDuration(), e = e.parent;
					return t
				},
				Kt = function t(e) {
					return !e || e._ts && t(e.parent)
				},
				Zt = function(t) {
					return t._repeat ? $t(t._tTime, t = t.duration() + t._rDelay) * t : 0
				},
				$t = function(t, e) {
					var n = Math.floor(t /= e);
					return t && n === t ? n - 1 : n
				},
				te = function(t, e) {
					return (t - e._start) * e._ts + (e._ts >= 0 ? 0 : e._dirty ? e.totalDuration() : e._tDur)
				},
				ee = function(t) {
					return t._end = Ft(t._start + (t._tDur / Math.abs(t._ts || t._rts || V) || 0))
				},
				ne = function(t, e) {
					var n = t._dp;
					return n && n.smoothChildTiming && t._ts && (t._start = Ft(n._time - (t._ts > 0 ? e / t._ts : ((t._dirty ? t.totalDuration() : t._tDur) - e) / -t._ts)), ee(t), n._dirty || qt(n, t)), t
				},
				ie = function(t, e) {
					var n;
					if ((e._time || e._initted && !e._dur) && (n = te(t.rawTime(), e), (!e._dur || me(0, e.totalDuration(), n) - e._tTime > V) && e.render(n, !0)), qt(t, e)._dp && t._initted && t._time >= t._dur && t._ts) {
						if (t._dur < t.duration())
							for (n = t; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
						t._zTime = -1e-8
					}
				},
				re = function(t, e, n, r) {
					return e.parent && Qt(e), e._start = Ft(($(n) ? n : n || t !== c ? de(t, n, e) : t._time) + e._delay), e._end = Ft(e._start + (e.totalDuration() / Math.abs(e.timeScale()) || 0)),
						function(t, e, n, r, o) {
							void 0 === n && (n = "_first"), void 0 === r && (r = "_last");
							var l, c = t[r];
							if (o)
								for (l = e[o]; c && c[o] > l;) c = c._prev;
							c ? (e._next = c._next, c._next = e) : (e._next = t[n], t[n] = e), e._next ? e._next._prev = e : t[r] = e, e._prev = c, e.parent = e._dp = t
						}(t, e, "_first", "_last", t._sort ? "_start" : 0), le(e) || (t._recent = e), r || ie(t, e), t
				},
				se = function(t, e) {
					return (gt.ScrollTrigger || xt("scrollTrigger", e)) && gt.ScrollTrigger.create(e, t)
				},
				ae = function(t, e, n, r) {
					return cn(t, e), t._initted ? !n && t._pt && (t._dur && !1 !== t.vars.lazy || !t._dur && t.vars.lazy) && v !== Ge.frame ? (Mt.push(t), t._lazy = [e, r], 1) : void 0 : 1
				},
				oe = function t(e) {
					var n = e.parent;
					return n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || t(n))
				},
				le = function(t) {
					var data = t.data;
					return "isFromStart" === data || "isStart" === data
				},
				ce = function(t, e, n, r) {
					var o = t._repeat,
						l = Ft(e) || 0,
						c = t._tTime / t._tDur;
					return c && !r && (t._time *= l / t._dur), t._dur = l, t._tDur = o ? o < 0 ? 1e10 : Ft(l * (o + 1) + t._rDelay * o) : l, c > 0 && !r ? ne(t, t._tTime = t._tDur * c) : t.parent && ee(t), n || qt(t.parent, t), t
				},
				he = function(t) {
					return t instanceof rn ? qt(t) : ce(t, t._dur)
				},
				ue = {
					_start: 0,
					endTime: At,
					totalDuration: At
				},
				de = function t(e, n, r) {
					var i, o, l, c = e.labels,
						h = e._recent || ue,
						d = e.duration() >= G ? h.endTime(!1) : e._dur;
					return K(n) && (isNaN(n) || n in c) ? (o = n.charAt(0), l = "%" === n.substr(-1), i = n.indexOf("="), "<" === o || ">" === o ? (i >= 0 && (n = n.replace(/=/, "")), ("<" === o ? h._start : h.endTime(h._repeat >= 0)) + (parseFloat(n.substr(1)) || 0) * (l ? (i < 0 ? h : r).totalDuration() / 100 : 1)) : i < 0 ? (n in c || (c[n] = d), c[n]) : (o = parseFloat(n.charAt(i - 1) + n.substr(i + 1)), l && r && (o = o / 100 * (ot(r) ? r[0] : r).totalDuration()), i > 1 ? t(e, n.substr(0, i - 1), r) + o : d + o)) : null == n ? d : +n
				},
				pe = function(t, e, n) {
					var r, o, l = $(e[1]),
						c = (l ? 2 : 1) + (t < 2 ? 0 : 1),
						h = e[c];
					if (l && (h.duration = e[1]), h.parent = n, t) {
						for (r = h, o = n; o && !("immediateRender" in r);) r = o.vars.defaults || {}, o = nt(o.vars.inherit) && o.parent;
						h.immediateRender = nt(r.immediateRender), t < 2 ? h.runBackwards = 1 : h.startAt = e[c - 1]
					}
					return new fn(e[0], h, e[c + 1])
				},
				fe = function(t, e) {
					return t || 0 === t ? e(t) : e
				},
				me = function(t, e, n) {
					return n < t ? t : n > e ? e : n
				},
				ge = function(t, e) {
					return K(t) && (e = mt.exec(t)) ? t.substr(e.index + e[0].length) : ""
				},
				ve = [].slice,
				ye = function(t, e) {
					return t && et(t) && "length" in t && (!e && !t.length || t.length - 1 in t && et(t[0])) && !t.nodeType && t !== h
				},
				xe = function(t, e, n) {
					return void 0 === n && (n = []), t.forEach((function(t) {
						var r;
						return K(t) && !e || ye(t, 1) ? (r = n).push.apply(r, _e(t)) : n.push(t)
					})) || n
				},
				_e = function(t, e, n) {
					return !K(t) || n || !d && Ve() ? ot(t) ? xe(t, n) : ye(t) ? ve.call(t, 0) : t ? [t] : [] : ve.call((e || f).querySelectorAll(t), 0)
				},
				we = function(a) {
					return a.sort((function() {
						return .5 - Math.random()
					}))
				},
				Ae = function(t) {
					if (Z(t)) return t;
					var e = et(t) ? t : {
							each: t
						},
						n = Je(e.ease),
						r = e.from || 0,
						base = parseFloat(e.base) || 0,
						o = {},
						l = r > 0 && r < 1,
						c = isNaN(r) || l,
						h = e.axis,
						d = r,
						f = r;
					return K(r) ? d = f = {
							center: .5,
							edges: .5,
							end: 1
						} [r] || 0 : !l && c && (d = r[0], f = r[1]),
						function(i, t, a) {
							var l, m, v, y, x, _, w, A, M, S = (a || e).length,
								T = o[S];
							if (!T) {
								if (!(M = "auto" === e.grid ? 0 : (e.grid || [1, G])[1])) {
									for (w = -G; w < (w = a[M++].getBoundingClientRect().left) && M < S;);
									M--
								}
								for (T = o[S] = [], l = c ? Math.min(M, S) * d - .5 : r % M, m = M === G ? 0 : c ? S * f / M - .5 : r / M | 0, w = 0, A = G, _ = 0; _ < S; _++) v = _ % M - l, y = m - (_ / M | 0), T[_] = x = h ? Math.abs("y" === h ? y : v) : Y(v * v + y * y), x > w && (w = x), x < A && (A = x);
								"random" === r && we(T), T.max = w - A, T.min = A, T.v = S = (parseFloat(e.amount) || parseFloat(e.each) * (M > S ? S - 1 : h ? "y" === h ? S / M : M : Math.max(M, S / M)) || 0) * ("edges" === r ? -1 : 1), T.b = S < 0 ? base - S : base, T.u = ge(e.amount || e.each) || 0, n = n && S < 0 ? Qe(n) : n
							}
							return S = (T[i] - T.min) / T.max || 0, Ft(T.b + (n ? n(S) : S) * T.v) + T.u
						}
				},
				be = function(t) {
					var p = Math.pow(10, ((t + "").split(".")[1] || "").length);
					return function(e) {
						var n = Math.round(parseFloat(e) / t) * t * p;
						return (n - n % 1) / p + ($(e) ? 0 : ge(e))
					}
				},
				Me = function(t, e) {
					var n, r, o = ot(t);
					return !o && et(t) && (n = o = t.radius || G, t.values ? (t = _e(t.values), (r = !$(t[0])) && (n *= n)) : t = be(t.increment)), fe(e, o ? Z(t) ? function(e) {
						return r = t(e), Math.abs(r - e) <= n ? r : e
					} : function(e) {
						for (var o, l, c = parseFloat(r ? e.x : e), h = parseFloat(r ? e.y : 0), d = G, f = 0, i = t.length; i--;)(o = r ? (o = t[i].x - c) * o + (l = t[i].y - h) * l : Math.abs(t[i] - c)) < d && (d = o, f = i);
						return f = !n || d <= n ? t[f] : e, r || f === e || $(e) ? f : f + ge(e)
					} : be(t))
				},
				Se = function(t, e, n, r) {
					return fe(ot(t) ? !e : !0 === n ? !!(n = 0) : !r, (function() {
						return ot(t) ? t[~~(Math.random() * t.length)] : (n = n || 1e-5) && (r = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((t - n / 2 + Math.random() * (e - t + .99 * n)) / n) * n * r) / r
					}))
				},
				Te = function(a, t, e) {
					return fe(e, (function(e) {
						return a[~~t(e)]
					}))
				},
				Ee = function(t) {
					for (var i, e, n, r, o = 0, s = ""; ~(i = t.indexOf("random(", o));) n = t.indexOf(")", i), r = "[" === t.charAt(i + 7), e = t.substr(i + 7, n - i - 7).match(r ? ft : lt), s += t.substr(o, i - o) + Se(r ? e : +e[0], r ? 0 : +e[1], +e[2] || 1e-5), o = n + 1;
					return s + t.substr(o, t.length - o)
				},
				Ce = function(t, e, n, r, o) {
					var l = e - t,
						c = r - n;
					return fe(o, (function(e) {
						return n + ((e - t) / l * c || 0)
					}))
				},
				Re = function(t, e, n) {
					var p, r, label, o = t.labels,
						l = G;
					for (p in o)(r = o[p] - e) < 0 == !!n && r && l > (r = Math.abs(r)) && (label = p, l = r);
					return label
				},
				De = function(t, e, n) {
					var r, o, l = t.vars,
						c = l[e];
					if (c) return r = l[e + "Params"], o = l.callbackScope || t, n && Mt.length && Nt(), r ? c.apply(o, r) : c.call(o)
				},
				Le = function(t) {
					return Qt(t), t.scrollTrigger && t.scrollTrigger.kill(!1), t.progress() < 1 && De(t, "onInterrupt"), t
				},
				Pe = function(t) {
					var e = (t = !t.name && t.default || t).name,
						n = Z(t),
						r = e && !n && t.init ? function() {
							this._props = []
						} : t,
						o = {
							init: At,
							render: bn,
							add: on,
							kill: Sn,
							modifier: Mn,
							rawVars: 0
						},
						l = {
							targetTest: 0,
							get: 0,
							getSetter: xn,
							aliases: {},
							register: 0
						};
					if (Ve(), t !== r) {
						if (Tt[e]) return;
						Gt(r, Gt(jt(t, o), l)), Vt(r.prototype, Vt(o, jt(t, l))), Tt[r.prop = e] = r, t.targetTest && (Rt.push(r), bt[e] = 1), e = ("css" === e ? "CSS" : e.charAt(0).toUpperCase() + e.substr(1)) + "Plugin"
					}
					wt(e, r), t.register && t.register(Pn, r, Cn)
				},
				Ie = 255,
				Be = {
					aqua: [0, Ie, Ie],
					lime: [0, Ie, 0],
					silver: [192, 192, 192],
					black: [0, 0, 0],
					maroon: [128, 0, 0],
					teal: [0, 128, 128],
					blue: [0, 0, Ie],
					navy: [0, 0, 128],
					white: [Ie, Ie, Ie],
					olive: [128, 128, 0],
					yellow: [Ie, Ie, 0],
					orange: [Ie, 165, 0],
					gray: [128, 128, 128],
					purple: [128, 0, 128],
					green: [0, 128, 0],
					red: [Ie, 0, 0],
					pink: [Ie, 192, 203],
					cyan: [0, Ie, Ie],
					transparent: [Ie, Ie, Ie, 0]
				},
				Oe = function(t, e, n) {
					return (6 * (t += t < 0 ? 1 : t > 1 ? -1 : 0) < 1 ? e + (n - e) * t * 6 : t < .5 ? n : 3 * t < 2 ? e + (n - e) * (2 / 3 - t) * 6 : e) * Ie + .5 | 0
				},
				Fe = function(t, e, n) {
					var r, g, b, o, s, l, c, h, d, f, a = t ? $(t) ? [t >> 16, t >> 8 & Ie, t & Ie] : 0 : Be.black;
					if (!a) {
						if ("," === t.substr(-1) && (t = t.substr(0, t.length - 1)), Be[t]) a = Be[t];
						else if ("#" === t.charAt(0)) {
							if (t.length < 6 && (r = t.charAt(1), g = t.charAt(2), b = t.charAt(3), t = "#" + r + r + g + g + b + b + (5 === t.length ? t.charAt(4) + t.charAt(4) : "")), 9 === t.length) return [(a = parseInt(t.substr(1, 6), 16)) >> 16, a >> 8 & Ie, a & Ie, parseInt(t.substr(7), 16) / 255];
							a = [(t = parseInt(t.substr(1), 16)) >> 16, t >> 8 & Ie, t & Ie]
						} else if ("hsl" === t.substr(0, 3))
							if (a = f = t.match(lt), e) {
								if (~t.indexOf("=")) return a = t.match(ct), n && a.length < 4 && (a[3] = 1), a
							} else o = +a[0] % 360 / 360, s = +a[1] / 100, r = 2 * (l = +a[2] / 100) - (g = l <= .5 ? l * (s + 1) : l + s - l * s), a.length > 3 && (a[3] *= 1), a[0] = Oe(o + 1 / 3, r, g), a[1] = Oe(o, r, g), a[2] = Oe(o - 1 / 3, r, g);
						else a = t.match(lt) || Be.transparent;
						a = a.map(Number)
					}
					return e && !f && (r = a[0] / Ie, g = a[1] / Ie, b = a[2] / Ie, l = ((c = Math.max(r, g, b)) + (h = Math.min(r, g, b))) / 2, c === h ? o = s = 0 : (d = c - h, s = l > .5 ? d / (2 - c - h) : d / (c + h), o = c === r ? (g - b) / d + (g < b ? 6 : 0) : c === g ? (b - r) / d + 2 : (r - g) / d + 4, o *= 60), a[0] = ~~(o + .5), a[1] = ~~(100 * s + .5), a[2] = ~~(100 * l + .5)), n && a.length < 4 && (a[3] = 1), a
				},
				He = function(t) {
					var e = [],
						n = [],
						i = -1;
					return t.split(Ue).forEach((function(t) {
						var a = t.match(ht) || [];
						e.push.apply(e, a), n.push(i += a.length + 1)
					})), e.c = n, e
				},
				Ne = function(s, t, e) {
					var n, r, o, l, c = "",
						h = (s + c).match(Ue),
						d = t ? "hsla(" : "rgba(",
						i = 0;
					if (!h) return s;
					if (h = h.map((function(e) {
							return (e = Fe(e, t, 1)) && d + (t ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3] : e.join(",")) + ")"
						})), e && (o = He(s), (n = e.c).join(c) !== o.c.join(c)))
						for (l = (r = s.replace(Ue, "1").split(ht)).length - 1; i < l; i++) c += r[i] + (~n.indexOf(i) ? h.shift() || d + "0,0,0,0)" : (o.length ? o : h.length ? h : e).shift());
					if (!r)
						for (l = (r = s.split(Ue)).length - 1; i < l; i++) c += r[i] + h[i];
					return c + r[l]
				},
				Ue = function() {
					var p, s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
					for (p in Be) s += "|" + p + "\\b";
					return new RegExp(s + ")", "gi")
				}(),
				ze = /hsl[a]?\(/,
				ke = function(a) {
					var t, e = a.join(" ");
					if (Ue.lastIndex = 0, Ue.test(e)) return t = ze.test(e), a[1] = Ne(a[1], t), a[0] = Ne(a[0], t, He(a[1])), !0
				},
				Ge = (E = Date.now, C = 500, R = 33, D = E(), L = D, I = P = 1e3 / 240, O = function t(e) {
					var n, r, time, o, l = E() - L,
						c = !0 === e;
					if (l > C && (D += l - R), ((n = (time = (L += l) - D) - I) > 0 || c) && (o = ++M.frame, S = time - 1e3 * M.time, M.time = time /= 1e3, I += n + (n >= P ? 4 : P - n), r = 1), c || (_ = w(t)), r)
						for (T = 0; T < B.length; T++) B[T](time, S, o, e)
				}, M = {
					time: 0,
					frame: 0,
					tick: function() {
						O(!0)
					},
					deltaRatio: function(t) {
						return S / (1e3 / (t || 60))
					},
					wake: function() {
						m && (!d && it() && (h = d = window, f = h.document || {}, gt.gsap = Pn, (h.gsapVersions || (h.gsapVersions = [])).push(Pn.version), yt(vt || h.GreenSockGlobals || !h.gsap && h || {}), A = h.requestAnimationFrame), _ && M.sleep(), w = A || function(t) {
							return setTimeout(t, I - 1e3 * M.time + 1 | 0)
						}, x = 1, O(2))
					},
					sleep: function() {
						(A ? h.cancelAnimationFrame : clearTimeout)(_), x = 0, w = At
					},
					lagSmoothing: function(t, e) {
						C = t || 1e8, R = Math.min(e, C, 0)
					},
					fps: function(t) {
						P = 1e3 / (t || 240), I = 1e3 * M.time + P
					},
					add: function(t) {
						B.indexOf(t) < 0 && B.push(t), Ve()
					},
					remove: function(t, i) {
						~(i = B.indexOf(t)) && B.splice(i, 1) && T >= i && T--
					},
					_listeners: B = []
				}),
				Ve = function() {
					return !x && Ge.wake()
				},
				We = {},
				je = /^[\d.\-M][\d.\-,\s]/,
				Xe = /["']/g,
				Ye = function(t) {
					for (var e, n, r, o = {}, l = t.substr(1, t.length - 3).split(":"), c = l[0], i = 1, h = l.length; i < h; i++) n = l[i], e = i !== h - 1 ? n.lastIndexOf(",") : n.length, r = n.substr(0, e), o[c] = isNaN(r) ? r.replace(Xe, "").trim() : +r, c = n.substr(e + 1).trim();
					return o
				},
				Qe = function(t) {
					return function(p) {
						return 1 - t(1 - p)
					}
				},
				qe = function t(e, n) {
					for (var r, o = e._first; o;) o instanceof rn ? t(o, n) : !o.vars.yoyoEase || o._yoyo && o._repeat || o._yoyo === n || (o.timeline ? t(o.timeline, n) : (r = o._ease, o._ease = o._yEase, o._yEase = r, o._yoyo = n)), o = o._next
				},
				Je = function(t, e) {
					return t && (Z(t) ? t : We[t] || function(t) {
						var e, n, r, o, l = (t + "").split("("),
							c = We[l[0]];
						return c && l.length > 1 && c.config ? c.config.apply(null, ~t.indexOf("{") ? [Ye(l[1])] : (e = t, n = e.indexOf("(") + 1, r = e.indexOf(")"), o = e.indexOf("(", n), e.substring(n, ~o && o < r ? e.indexOf(")", r + 1) : r)).split(",").map(zt)) : We._CE && je.test(t) ? We._CE("", t) : c
					}(t)) || e
				},
				Ke = function(t, e, n, r) {
					void 0 === n && (n = function(p) {
						return 1 - e(1 - p)
					}), void 0 === r && (r = function(p) {
						return p < .5 ? e(2 * p) / 2 : 1 - e(2 * (1 - p)) / 2
					});
					var o, l = {
						easeIn: e,
						easeOut: n,
						easeInOut: r
					};
					return Bt(t, (function(t) {
						for (var p in We[t] = gt[t] = l, We[o = t.toLowerCase()] = n, l) We[o + ("easeIn" === p ? ".in" : "easeOut" === p ? ".out" : ".inOut")] = We[t + "." + p] = l[p]
					})), l
				},
				Ze = function(t) {
					return function(p) {
						return p < .5 ? (1 - t(1 - 2 * p)) / 2 : .5 + t(2 * (p - .5)) / 2
					}
				},
				$e = function t(e, n, r) {
					var o = n >= 1 ? n : 1,
						l = (r || (e ? .3 : .45)) / (n < 1 ? n : 1),
						c = l / W * (Math.asin(1 / o) || 0),
						h = function(p) {
							return 1 === p ? 1 : o * Math.pow(2, -10 * p) * J((p - c) * l) + 1
						},
						d = "out" === e ? h : "in" === e ? function(p) {
							return 1 - h(1 - p)
						} : Ze(h);
					return l = W / l, d.config = function(n, r) {
						return t(e, n, r)
					}, d
				},
				tn = function t(e, n) {
					void 0 === n && (n = 1.70158);
					var r = function(p) {
							return p ? --p * p * ((n + 1) * p + n) + 1 : 0
						},
						o = "out" === e ? r : "in" === e ? function(p) {
							return 1 - r(1 - p)
						} : Ze(r);
					return o.config = function(n) {
						return t(e, n)
					}, o
				};
			Bt("Linear,Quad,Cubic,Quart,Quint,Strong", (function(t, i) {
				var e = i < 5 ? i + 1 : i;
				Ke(t + ",Power" + (e - 1), i ? function(p) {
					return Math.pow(p, e)
				} : function(p) {
					return p
				}, (function(p) {
					return 1 - Math.pow(1 - p, e)
				}), (function(p) {
					return p < .5 ? Math.pow(2 * p, e) / 2 : 1 - Math.pow(2 * (1 - p), e) / 2
				}))
			})), We.Linear.easeNone = We.none = We.Linear.easeIn, Ke("Elastic", $e("in"), $e("out"), $e()), F = 7.5625, N = 1 / (H = 2.75), Ke("Bounce", (function(p) {
				return 1 - U(1 - p)
			}), U = function(p) {
				return p < N ? F * p * p : p < .7272727272727273 ? F * Math.pow(p - 1.5 / H, 2) + .75 : p < .9090909090909092 ? F * (p -= 2.25 / H) * p + .9375 : F * Math.pow(p - 2.625 / H, 2) + .984375
			}), Ke("Expo", (function(p) {
				return p ? Math.pow(2, 10 * (p - 1)) : 0
			})), Ke("Circ", (function(p) {
				return -(Y(1 - p * p) - 1)
			})), Ke("Sine", (function(p) {
				return 1 === p ? 1 : 1 - Q(p * j)
			})), Ke("Back", tn("in"), tn("out"), tn()), We.SteppedEase = We.steps = gt.SteppedEase = {
				config: function(t, e) {
					void 0 === t && (t = 1);
					var n = 1 / t,
						r = t + (e ? 0 : 1),
						o = e ? 1 : 0;
					return function(p) {
						return ((r * me(0, .99999999, p) | 0) + o) * n
					}
				}
			}, k.ease = We["quad.out"], Bt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", (function(t) {
				return Dt += t + "," + t + "Params,"
			}));
			var en = function(t, e) {
					this.id = X++, t._gsap = this, this.target = t, this.harness = e, this.get = e ? e.get : It, this.set = e ? e.getSetter : xn
				},
				nn = function() {
					function t(t) {
						this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, ce(this, +t.duration, 1, 1), this.data = t.data, x || Ge.wake()
					}
					var e = t.prototype;
					return e.delay = function(t) {
						return t || 0 === t ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + t - this._delay), this._delay = t, this) : this._delay
					}, e.duration = function(t) {
						return arguments.length ? this.totalDuration(this._repeat > 0 ? t + (t + this._rDelay) * this._repeat : t) : this.totalDuration() && this._dur
					}, e.totalDuration = function(t) {
						return arguments.length ? (this._dirty = 0, ce(this, this._repeat < 0 ? t : (t - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
					}, e.totalTime = function(t, e) {
						if (Ve(), !arguments.length) return this._tTime;
						var n = this._dp;
						if (n && n.smoothChildTiming && this._ts) {
							for (ne(this, t), !n._dp || n.parent || ie(n, this); n && n.parent;) n.parent._time !== n._start + (n._ts >= 0 ? n._tTime / n._ts : (n.totalDuration() - n._tTime) / -n._ts) && n.totalTime(n._tTime, !0), n = n.parent;
							!this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && t < this._tDur || this._ts < 0 && t > 0 || !this._tDur && !t) && re(this._dp, this, this._start - this._delay)
						}
						return (this._tTime !== t || !this._dur && !e || this._initted && Math.abs(this._zTime) === V || !t && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = t), Ut(this, t, e)), this
					}, e.time = function(t, e) {
						return arguments.length ? this.totalTime(Math.min(this.totalDuration(), t + Zt(this)) % (this._dur + this._rDelay) || (t ? this._dur : 0), e) : this._time
					}, e.totalProgress = function(t, e) {
						return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.ratio
					}, e.progress = function(t, e) {
						return arguments.length ? this.totalTime(this.duration() * (!this._yoyo || 1 & this.iteration() ? t : 1 - t) + Zt(this), e) : this.duration() ? Math.min(1, this._time / this._dur) : this.ratio
					}, e.iteration = function(t, e) {
						var n = this.duration() + this._rDelay;
						return arguments.length ? this.totalTime(this._time + (t - 1) * n, e) : this._repeat ? $t(this._tTime, n) + 1 : 1
					}, e.timeScale = function(t) {
						if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
						if (this._rts === t) return this;
						var e = this.parent && this._ts ? te(this.parent._time, this) : this._tTime;
						return this._rts = +t || 0, this._ts = this._ps || -1e-8 === t ? 0 : this._rts, Jt(this.totalTime(me(-this._delay, this._tDur, e), !0)), ee(this), this
					}, e.paused = function(t) {
						return arguments.length ? (this._ps !== t && (this._ps = t, t ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Ve(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, 1 === this.progress() && Math.abs(this._zTime) !== V && (this._tTime -= V)))), this) : this._ps
					}, e.startTime = function(t) {
						if (arguments.length) {
							this._start = t;
							var e = this.parent || this._dp;
							return e && (e._sort || !this.parent) && re(e, this, t - this._delay), this
						}
						return this._start
					}, e.endTime = function(t) {
						return this._start + (nt(t) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
					}, e.rawTime = function(t) {
						var e = this.parent || this._dp;
						return e ? t && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? te(e.rawTime(t), this) : this._tTime : this._tTime
					}, e.globalTime = function(t) {
						for (var e = this, time = arguments.length ? t : e.rawTime(); e;) time = e._start + time / (e._ts || 1), e = e._dp;
						return time
					}, e.repeat = function(t) {
						return arguments.length ? (this._repeat = t === 1 / 0 ? -2 : t, he(this)) : -2 === this._repeat ? 1 / 0 : this._repeat
					}, e.repeatDelay = function(t) {
						if (arguments.length) {
							var time = this._time;
							return this._rDelay = t, he(this), time ? this.time(time) : this
						}
						return this._rDelay
					}, e.yoyo = function(t) {
						return arguments.length ? (this._yoyo = t, this) : this._yoyo
					}, e.seek = function(t, e) {
						return this.totalTime(de(this, t), nt(e))
					}, e.restart = function(t, e) {
						return this.play().totalTime(t ? -this._delay : 0, nt(e))
					}, e.play = function(t, e) {
						return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
					}, e.reverse = function(t, e) {
						return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
					}, e.pause = function(t, e) {
						return null != t && this.seek(t, e), this.paused(!0)
					}, e.resume = function() {
						return this.paused(!1)
					}, e.reversed = function(t) {
						return arguments.length ? (!!t !== this.reversed() && this.timeScale(-this._rts || (t ? -1e-8 : 0)), this) : this._rts < 0
					}, e.invalidate = function() {
						return this._initted = this._act = 0, this._zTime = -1e-8, this
					}, e.isActive = function() {
						var t, e = this.parent || this._dp,
							n = this._start;
						return !(e && !(this._ts && this._initted && e.isActive() && (t = e.rawTime(!0)) >= n && t < this.endTime(!0) - V))
					}, e.eventCallback = function(t, e, n) {
						var r = this.vars;
						return arguments.length > 1 ? (e ? (r[t] = e, n && (r[t + "Params"] = n), "onUpdate" === t && (this._onUpdate = e)) : delete r[t], this) : r[t]
					}, e.then = function(t) {
						var e = this;
						return new Promise((function(n) {
							var r = Z(t) ? t : kt,
								o = function() {
									var t = e.then;
									e.then = null, Z(r) && (r = r(e)) && (r.then || r === e) && (e.then = t), n(r), e.then = t
								};
							e._initted && 1 === e.totalProgress() && e._ts >= 0 || !e._tTime && e._ts < 0 ? o() : e._prom = o
						}))
					}, e.kill = function() {
						Le(this)
					}, t
				}();
			Gt(nn.prototype, {
				_time: 0,
				_start: 0,
				_end: 0,
				_tTime: 0,
				_tDur: 0,
				_dirty: 0,
				_repeat: 0,
				_yoyo: !1,
				parent: null,
				_initted: !1,
				_rDelay: 0,
				_ts: 1,
				_dp: 0,
				ratio: 0,
				_zTime: -1e-8,
				_prom: 0,
				_ps: !1,
				_rts: 1
			});
			var rn = function(t) {
				function e(e, n) {
					var o;
					return void 0 === e && (e = {}), (o = t.call(this, e) || this).labels = {}, o.smoothChildTiming = !!e.smoothChildTiming, o.autoRemoveChildren = !!e.autoRemoveChildren, o._sort = nt(e.sortChildren), c && re(e.parent || c, r(o), n), e.reversed && o.reverse(), e.paused && o.paused(!0), e.scrollTrigger && se(r(o), e.scrollTrigger), o
				}
				o(e, t);
				var n = e.prototype;
				return n.to = function(t, e, n) {
					return pe(0, arguments, this), this
				}, n.from = function(t, e, n) {
					return pe(1, arguments, this), this
				}, n.fromTo = function(t, e, n, r) {
					return pe(2, arguments, this), this
				}, n.set = function(t, e, n) {
					return e.duration = 0, e.parent = this, Xt(e).repeatDelay || (e.repeat = 0), e.immediateRender = !!e.immediateRender, new fn(t, e, de(this, n), 1), this
				}, n.call = function(t, e, n) {
					return re(this, fn.delayedCall(0, t, e), n)
				}, n.staggerTo = function(t, e, n, r, o, l, c) {
					return n.duration = e, n.stagger = n.stagger || r, n.onComplete = l, n.onCompleteParams = c, n.parent = this, new fn(t, n, de(this, o)), this
				}, n.staggerFrom = function(t, e, n, r, o, l, c) {
					return n.runBackwards = 1, Xt(n).immediateRender = nt(n.immediateRender), this.staggerTo(t, e, n, r, o, l, c)
				}, n.staggerFromTo = function(t, e, n, r, o, l, c, h) {
					return r.startAt = n, Xt(r).immediateRender = nt(r.immediateRender), this.staggerTo(t, e, r, o, l, c, h)
				}, n.render = function(t, e, n) {
					var time, r, o, l, h, d, f, m, v, y, x, _, w = this._time,
						A = this._dirty ? this.totalDuration() : this._tDur,
						M = this._dur,
						S = t <= 0 ? 0 : Ft(t),
						T = this._zTime < 0 != t < 0 && (this._initted || !M);
					if (this !== c && S > A && t >= 0 && (S = A), S !== this._tTime || n || T) {
						if (w !== this._time && M && (S += this._time - w, t += this._time - w), time = S, v = this._start, d = !(m = this._ts), T && (M || (w = this._zTime), (t || !e) && (this._zTime = t)), this._repeat) {
							if (x = this._yoyo, h = M + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * h + t, e, n);
							if (time = Ft(S % h), S === A ? (l = this._repeat, time = M) : ((l = ~~(S / h)) && l === S / h && (time = M, l--), time > M && (time = M)), y = $t(this._tTime, h), !w && this._tTime && y !== l && (y = l), x && 1 & l && (time = M - time, _ = 1), l !== y && !this._lock) {
								var E = x && 1 & y,
									C = E === (x && 1 & l);
								if (l < y && (E = !E), w = E ? 0 : M, this._lock = 1, this.render(w || (_ ? 0 : Ft(l * h)), e, !M)._lock = 0, this._tTime = S, !e && this.parent && De(this, "onRepeat"), this.vars.repeatRefresh && !_ && (this.invalidate()._lock = 1), w && w !== this._time || d !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
								if (M = this._dur, A = this._tDur, C && (this._lock = 2, w = E ? M : -1e-4, this.render(w, !0), this.vars.repeatRefresh && !_ && this.invalidate()), this._lock = 0, !this._ts && !d) return this;
								qe(this, _)
							}
						}
						if (this._hasPause && !this._forcing && this._lock < 2 && (f = function(t, e, time) {
								var n;
								if (time > e)
									for (n = t._first; n && n._start <= time;) {
										if ("isPause" === n.data && n._start > e) return n;
										n = n._next
									} else
										for (n = t._last; n && n._start >= time;) {
											if ("isPause" === n.data && n._start < e) return n;
											n = n._prev
										}
							}(this, Ft(w), Ft(time))) && (S -= time - (time = f._start)), this._tTime = S, this._time = time, this._act = !m, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = t, w = 0), !w && time && !e && (De(this, "onStart"), this._tTime !== S)) return this;
						if (time >= w && t >= 0)
							for (r = this._first; r;) {
								if (o = r._next, (r._act || time >= r._start) && r._ts && f !== r) {
									if (r.parent !== this) return this.render(t, e, n);
									if (r.render(r._ts > 0 ? (time - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (time - r._start) * r._ts, e, n), time !== this._time || !this._ts && !d) {
										f = 0, o && (S += this._zTime = -1e-8);
										break
									}
								}
								r = o
							} else {
								r = this._last;
								for (var R = t < 0 ? t : time; r;) {
									if (o = r._prev, (r._act || R <= r._end) && r._ts && f !== r) {
										if (r.parent !== this) return this.render(t, e, n);
										if (r.render(r._ts > 0 ? (R - r._start) * r._ts : (r._dirty ? r.totalDuration() : r._tDur) + (R - r._start) * r._ts, e, n), time !== this._time || !this._ts && !d) {
											f = 0, o && (S += this._zTime = R ? -1e-8 : V);
											break
										}
									}
									r = o
								}
							}
						if (f && !e && (this.pause(), f.render(time >= w ? 0 : -1e-8)._zTime = time >= w ? 1 : -1, this._ts)) return this._start = v, ee(this), this.render(t, e, n);
						this._onUpdate && !e && De(this, "onUpdate", !0), (S === A && A >= this.totalDuration() || !S && w) && (v !== this._start && Math.abs(m) === Math.abs(this._ts) || this._lock || ((t || !M) && (S === A && this._ts > 0 || !S && this._ts < 0) && Qt(this, 1), e || t < 0 && !w || !S && !w && A || (De(this, S === A && t >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(S < A && this.timeScale() > 0) && this._prom())))
					}
					return this
				}, n.add = function(t, e) {
					var n = this;
					if ($(e) || (e = de(this, e, t)), !(t instanceof nn)) {
						if (ot(t)) return t.forEach((function(t) {
							return n.add(t, e)
						})), this;
						if (K(t)) return this.addLabel(t, e);
						if (!Z(t)) return this;
						t = fn.delayedCall(0, t)
					}
					return this !== t ? re(this, t, e) : this
				}, n.getChildren = function(t, e, n, r) {
					void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === n && (n = !0), void 0 === r && (r = -G);
					for (var a = [], o = this._first; o;) o._start >= r && (o instanceof fn ? e && a.push(o) : (n && a.push(o), t && a.push.apply(a, o.getChildren(!0, e, n)))), o = o._next;
					return a
				}, n.getById = function(t) {
					for (var e = this.getChildren(1, 1, 1), i = e.length; i--;)
						if (e[i].vars.id === t) return e[i]
				}, n.remove = function(t) {
					return K(t) ? this.removeLabel(t) : Z(t) ? this.killTweensOf(t) : (Yt(this, t), t === this._recent && (this._recent = this._last), qt(this))
				}, n.totalTime = function(e, n) {
					return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Ft(Ge.time - (this._ts > 0 ? e / this._ts : (this.totalDuration() - e) / -this._ts))), t.prototype.totalTime.call(this, e, n), this._forcing = 0, this) : this._tTime
				}, n.addLabel = function(label, t) {
					return this.labels[label] = de(this, t), this
				}, n.removeLabel = function(label) {
					return delete this.labels[label], this
				}, n.addPause = function(t, e, n) {
					var r = fn.delayedCall(0, e || At, n);
					return r.data = "isPause", this._hasPause = 1, re(this, r, de(this, t))
				}, n.removePause = function(t) {
					var e = this._first;
					for (t = de(this, t); e;) e._start === t && "isPause" === e.data && Qt(e), e = e._next
				}, n.killTweensOf = function(t, e, n) {
					for (var r = this.getTweensOf(t, n), i = r.length; i--;) sn !== r[i] && r[i].kill(t, e);
					return this
				}, n.getTweensOf = function(t, e) {
					for (var n, a = [], r = _e(t), o = this._first, l = $(e); o;) o instanceof fn ? Ht(o._targets, r) && (l ? (!sn || o._initted && o._ts) && o.globalTime(0) <= e && o.globalTime(o.totalDuration()) > e : !e || o.isActive()) && a.push(o) : (n = o.getTweensOf(r, e)).length && a.push.apply(a, n), o = o._next;
					return a
				}, n.tweenTo = function(t, e) {
					e = e || {};
					var n, r = this,
						o = de(r, t),
						l = e,
						c = l.startAt,
						h = l.onStart,
						d = l.onStartParams,
						f = l.immediateRender,
						m = fn.to(r, Gt({
							ease: e.ease || "none",
							lazy: !1,
							immediateRender: !1,
							time: o,
							overwrite: "auto",
							duration: e.duration || Math.abs((o - (c && "time" in c ? c.time : r._time)) / r.timeScale()) || V,
							onStart: function() {
								if (r.pause(), !n) {
									var t = e.duration || Math.abs((o - (c && "time" in c ? c.time : r._time)) / r.timeScale());
									m._dur !== t && ce(m, t, 0, 1).render(m._time, !0, !0), n = 1
								}
								h && h.apply(m, d || [])
							}
						}, e));
					return f ? m.render(0) : m
				}, n.tweenFromTo = function(t, e, n) {
					return this.tweenTo(e, Gt({
						startAt: {
							time: de(this, t)
						}
					}, n))
				}, n.recent = function() {
					return this._recent
				}, n.nextLabel = function(t) {
					return void 0 === t && (t = this._time), Re(this, de(this, t))
				}, n.previousLabel = function(t) {
					return void 0 === t && (t = this._time), Re(this, de(this, t), 1)
				}, n.currentLabel = function(t) {
					return arguments.length ? this.seek(t, !0) : this.previousLabel(this._time + V)
				}, n.shiftChildren = function(t, e, n) {
					void 0 === n && (n = 0);
					for (var p, r = this._first, o = this.labels; r;) r._start >= n && (r._start += t, r._end += t), r = r._next;
					if (e)
						for (p in o) o[p] >= n && (o[p] += t);
					return qt(this)
				}, n.invalidate = function() {
					var e = this._first;
					for (this._lock = 0; e;) e.invalidate(), e = e._next;
					return t.prototype.invalidate.call(this)
				}, n.clear = function(t) {
					void 0 === t && (t = !0);
					for (var e, n = this._first; n;) e = n._next, this.remove(n), n = e;
					return this._dp && (this._time = this._tTime = this._pTime = 0), t && (this.labels = {}), qt(this)
				}, n.totalDuration = function(t) {
					var e, n, r, o = 0,
						l = this,
						h = l._last,
						d = G;
					if (arguments.length) return l.timeScale((l._repeat < 0 ? l.duration() : l.totalDuration()) / (l.reversed() ? -t : t));
					if (l._dirty) {
						for (r = l.parent; h;) e = h._prev, h._dirty && h.totalDuration(), (n = h._start) > d && l._sort && h._ts && !l._lock ? (l._lock = 1, re(l, h, n - h._delay, 1)._lock = 0) : d = n, n < 0 && h._ts && (o -= n, (!r && !l._dp || r && r.smoothChildTiming) && (l._start += n / l._ts, l._time -= n, l._tTime -= n), l.shiftChildren(-n, !1, -Infinity), d = 0), h._end > o && h._ts && (o = h._end), h = e;
						ce(l, l === c && l._time > o ? l._time : o, 1, 1), l._dirty = 0
					}
					return l._tDur
				}, e.updateRoot = function(time) {
					if (c._ts && (Ut(c, te(time, c)), v = Ge.frame), Ge.frame >= Ct) {
						Ct += z.autoSleep || 120;
						var t = c._first;
						if ((!t || !t._ts) && z.autoSleep && Ge._listeners.length < 2) {
							for (; t && !t._ts;) t = t._next;
							t || Ge.sleep()
						}
					}
				}, e
			}(nn);
			Gt(rn.prototype, {
				_lock: 0,
				_hasPause: 0,
				_forcing: 0
			});
			var sn, an = function(t, e, n, r, o, l, c) {
					var h, d, f, m, v, y, x, a, _ = new Cn(this._pt, t, e, 0, 1, An, null, o),
						w = 0,
						A = 0;
					for (_.b = n, _.e = r, n += "", (x = ~(r += "").indexOf("random(")) && (r = Ee(r)), l && (l(a = [n, r], t, e), n = a[0], r = a[1]), d = n.match(ut) || []; h = ut.exec(r);) m = h[0], v = r.substring(w, h.index), f ? f = (f + 1) % 5 : "rgba(" === v.substr(-5) && (f = 1), m !== d[A++] && (y = parseFloat(d[A - 1]) || 0, _._pt = {
						_next: _._pt,
						p: v || 1 === A ? v : ",",
						s: y,
						c: "=" === m.charAt(1) ? parseFloat(m.substr(2)) * ("-" === m.charAt(0) ? -1 : 1) : parseFloat(m) - y,
						m: f && f < 4 ? Math.round : 0
					}, w = ut.lastIndex);
					return _.c = w < r.length ? r.substring(w, r.length) : "", _.fp = c, (pt.test(r) || x) && (_.e = 0), this._pt = _, _
				},
				on = function(t, e, n, r, o, l, c, h, d) {
					Z(r) && (r = r(o || 0, t, l));
					var f, m = t[e],
						v = "get" !== n ? n : Z(m) ? d ? t[e.indexOf("set") || !Z(t["get" + e.substr(3)]) ? e : "get" + e.substr(3)](d) : t[e]() : m,
						y = Z(m) ? d ? vn : gn : mn;
					if (K(r) && (~r.indexOf("random(") && (r = Ee(r)), "=" === r.charAt(1) && ((f = parseFloat(v) + parseFloat(r.substr(2)) * ("-" === r.charAt(0) ? -1 : 1) + (ge(v) || 0)) || 0 === f) && (r = f)), v !== r) return isNaN(v * r) || "" === r ? (!m && !(e in t) && xt(e, r), an.call(this, t, e, v, r, y, h || z.stringFilter, d)) : (f = new Cn(this._pt, t, e, +v || 0, r - (v || 0), "boolean" == typeof m ? wn : _n, 0, y), d && (f.fp = d), c && f.modifier(c, this, t), this._pt = f)
				},
				ln = function(t, e, n, r, o, l) {
					var c, h, d, i;
					if (Tt[t] && !1 !== (c = new Tt[t]).init(o, c.rawVars ? e[t] : function(t, e, n, r, o) {
							if (Z(t) && (t = un(t, o, e, n, r)), !et(t) || t.style && t.nodeType || ot(t) || at(t)) return K(t) ? un(t, o, e, n, r) : t;
							var p, l = {};
							for (p in t) l[p] = un(t[p], o, e, n, r);
							return l
						}(e[t], r, o, l, n), n, r, l) && (n._pt = h = new Cn(n._pt, o, t, 0, 1, c.render, c, 0, c.priority), n !== y))
						for (d = n._ptLookup[n._targets.indexOf(o)], i = c._props.length; i--;) d[c._props[i]] = h;
					return c
				},
				cn = function t(e, time) {
					var n, i, p, r, o, h, d, f, m, v, y, x, _, w = e.vars,
						A = w.ease,
						M = w.startAt,
						S = w.immediateRender,
						T = w.lazy,
						E = w.onUpdate,
						C = w.onUpdateParams,
						R = w.callbackScope,
						D = w.runBackwards,
						L = w.yoyoEase,
						P = w.keyframes,
						I = w.autoRevert,
						B = e._dur,
						O = e._startAt,
						F = e._targets,
						H = e.parent,
						N = H && "nested" === H.data ? H.parent._targets : F,
						U = "auto" === e._overwrite && !l,
						z = e.timeline;
					if (z && (!P || !A) && (A = "none"), e._ease = Je(A, k.ease), e._yEase = L ? Qe(Je(!0 === L ? A : L, k.ease)) : 0, L && e._yoyo && !e._repeat && (L = e._yEase, e._yEase = e._ease, e._ease = L), e._from = !z && !!w.runBackwards, !z || P && !w.stagger) {
						if (x = (f = F[0] ? Pt(F[0]).harness : 0) && w[f.prop], n = jt(w, bt), O && Qt(O.render(-1, !0)), M)
							if (Qt(e._startAt = fn.set(F, Gt({
									data: "isStart",
									overwrite: !1,
									parent: H,
									immediateRender: !0,
									lazy: nt(T),
									startAt: null,
									delay: 0,
									onUpdate: E,
									onUpdateParams: C,
									callbackScope: R,
									stagger: 0
								}, M))), time < 0 && !S && !I && e._startAt.render(-1, !0), S) {
								if (time > 0 && !I && (e._startAt = 0), B && time <= 0) return void(time && (e._zTime = time))
							} else !1 === I && (e._startAt = 0);
						else if (D && B)
							if (O) !I && (e._startAt = 0);
							else if (time && (S = !1), p = Gt({
								overwrite: !1,
								data: "isFromStart",
								lazy: S && nt(T),
								immediateRender: S,
								stagger: 0,
								parent: H
							}, n), x && (p[f.prop] = x), Qt(e._startAt = fn.set(F, p)), time < 0 && e._startAt.render(-1, !0), e._zTime = time, S) {
							if (!time) return
						} else t(e._startAt, V);
						for (e._pt = 0, T = B && nt(T) || T && !B, i = 0; i < F.length; i++) {
							if (d = (o = F[i])._gsap || Lt(F)[i]._gsap, e._ptLookup[i] = v = {}, St[d.id] && Mt.length && Nt(), y = N === F ? i : N.indexOf(o), f && !1 !== (m = new f).init(o, x || n, e, y, N) && (e._pt = r = new Cn(e._pt, o, m.name, 0, 1, m.render, m, 0, m.priority), m._props.forEach((function(t) {
									v[t] = r
								})), m.priority && (h = 1)), !f || x)
								for (p in n) Tt[p] && (m = ln(p, n, e, y, o, N)) ? m.priority && (h = 1) : v[p] = r = on.call(e, o, p, "get", n[p], y, N, 0, w.stringFilter);
							e._op && e._op[i] && e.kill(o, e._op[i]), U && e._pt && (sn = e, c.killTweensOf(o, v, e.globalTime(time)), _ = !e.parent, sn = 0), e._pt && T && (St[d.id] = 1)
						}
						h && En(e), e._onInit && e._onInit(e)
					}
					e._onUpdate = E, e._initted = (!e._op || e._pt) && !_, P && time <= 0 && z.render(G, !0, !0)
				},
				hn = function(t, e, n, r) {
					var p, a, o = e.ease || r || "power1.inOut";
					if (ot(e)) a = n[t] || (n[t] = []), e.forEach((function(t, i) {
						return a.push({
							t: i / (e.length - 1) * 100,
							v: t,
							e: o
						})
					}));
					else
						for (p in e) a = n[p] || (n[p] = []), "ease" === p || a.push({
							t: parseFloat(t),
							v: e[p],
							e: o
						})
				},
				un = function(t, e, i, n, r) {
					return Z(t) ? t.call(e, i, n, r) : K(t) && ~t.indexOf("random(") ? Ee(t) : t
				},
				dn = Dt + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase",
				pn = {};
			Bt(dn + ",id,stagger,delay,duration,paused,scrollTrigger", (function(t) {
				return pn[t] = 1
			}));
			var fn = function(t) {
				function e(e, n, o, h) {
					var d;
					"number" == typeof n && (o.duration = n, n = o, o = null);
					var f, i, m, v, p, y, x, _, w = (d = t.call(this, h ? n : Xt(n)) || this).vars,
						A = w.duration,
						M = w.delay,
						S = w.immediateRender,
						T = w.stagger,
						E = w.overwrite,
						C = w.keyframes,
						R = w.defaults,
						D = w.scrollTrigger,
						L = w.yoyoEase,
						P = n.parent || c,
						I = (ot(e) || at(e) ? $(e[0]) : "length" in n) ? [e] : _e(e);
					if (d._targets = I.length ? Lt(I) : _t("GSAP target " + e + " not found. https://greensock.com", !z.nullTargetWarn) || [], d._ptLookup = [], d._overwrite = E, C || T || st(A) || st(M)) {
						if (n = d.vars, (f = d.timeline = new rn({
								data: "nested",
								defaults: R || {}
							})).kill(), f.parent = f._dp = r(d), f._start = 0, T || st(A) || st(M)) {
							if (v = I.length, x = T && Ae(T), et(T))
								for (p in T) ~dn.indexOf(p) && (_ || (_ = {}), _[p] = T[p]);
							for (i = 0; i < v; i++)(m = jt(n, pn)).stagger = 0, L && (m.yoyoEase = L), _ && Vt(m, _), y = I[i], m.duration = +un(A, r(d), i, y, I), m.delay = (+un(M, r(d), i, y, I) || 0) - d._delay, !T && 1 === v && m.delay && (d._delay = M = m.delay, d._start += M, m.delay = 0), f.to(y, m, x ? x(i, y, I) : 0), f._ease = We.none;
							f.duration() ? A = M = 0 : d.timeline = 0
						} else if (C) {
							Xt(Gt(f.vars.defaults, {
								ease: "none"
							})), f._ease = Je(C.ease || n.ease || "none");
							var a, B, O, time = 0;
							if (ot(C)) C.forEach((function(t) {
								return f.to(I, t, ">")
							}));
							else {
								for (p in m = {}, C) "ease" === p || "easeEach" === p || hn(p, C[p], m, C.easeEach);
								for (p in m)
									for (a = m[p].sort((function(a, b) {
											return a.t - b.t
										})), time = 0, i = 0; i < a.length; i++)(O = {
										ease: (B = a[i]).e,
										duration: (B.t - (i ? a[i - 1].t : 0)) / 100 * A
									})[p] = B.v, f.to(I, O, time), time += O.duration;
								f.duration() < A && f.to({}, {
									duration: A - f.duration()
								})
							}
						}
						A || d.duration(A = f.duration())
					} else d.timeline = 0;
					return !0 !== E || l || (sn = r(d), c.killTweensOf(I), sn = 0), re(P, r(d), o), n.reversed && d.reverse(), n.paused && d.paused(!0), (S || !A && !C && d._start === Ft(P._time) && nt(S) && Kt(r(d)) && "nested" !== P.data) && (d._tTime = -1e-8, d.render(Math.max(0, -M))), D && se(r(d), D), d
				}
				o(e, t);
				var n = e.prototype;
				return n.render = function(t, e, n) {
					var time, r, o, l, c, h, d, f, m, v = this._time,
						y = this._tDur,
						x = this._dur,
						_ = t > y - V && t >= 0 ? y : t < V ? 0 : t;
					if (x) {
						if (_ !== this._tTime || !t || n || !this._initted && this._tTime || this._startAt && this._zTime < 0 != t < 0) {
							if (time = _, f = this.timeline, this._repeat) {
								if (l = x + this._rDelay, this._repeat < -1 && t < 0) return this.totalTime(100 * l + t, e, n);
								if (time = Ft(_ % l), _ === y ? (o = this._repeat, time = x) : ((o = ~~(_ / l)) && o === _ / l && (time = x, o--), time > x && (time = x)), (h = this._yoyo && 1 & o) && (m = this._yEase, time = x - time), c = $t(this._tTime, l), time === v && !n && this._initted) return this;
								o !== c && (f && this._yEase && qe(f, h), !this.vars.repeatRefresh || h || this._lock || (this._lock = n = 1, this.render(Ft(l * o), !0).invalidate()._lock = 0))
							}
							if (!this._initted) {
								if (ae(this, t < 0 ? t : time, n, e)) return this._tTime = 0, this;
								if (x !== this._dur) return this.render(t, e, n)
							}
							if (this._tTime = _, this._time = time, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = d = (m || this._ease)(time / x), this._from && (this.ratio = d = 1 - d), time && !v && !e && (De(this, "onStart"), this._tTime !== _)) return this;
							for (r = this._pt; r;) r.r(d, r.d), r = r._next;
							f && f.render(t < 0 ? t : !time && h ? -1e-8 : f._dur * f._ease(time / this._dur), e, n) || this._startAt && (this._zTime = t), this._onUpdate && !e && (t < 0 && this._startAt && this._startAt.render(t, !0, n), De(this, "onUpdate")), this._repeat && o !== c && this.vars.onRepeat && !e && this.parent && De(this, "onRepeat"), _ !== this._tDur && _ || this._tTime !== _ || (t < 0 && this._startAt && !this._onUpdate && this._startAt.render(t, !0, !0), (t || !x) && (_ === this._tDur && this._ts > 0 || !_ && this._ts < 0) && Qt(this, 1), e || t < 0 && !v || !_ && !v || (De(this, _ === y ? "onComplete" : "onReverseComplete", !0), this._prom && !(_ < y && this.timeScale() > 0) && this._prom()))
						}
					} else ! function(t, e, n, r) {
						var o, l, c, h = t.ratio,
							d = e < 0 || !e && (!t._start && oe(t) && (t._initted || !le(t)) || (t._ts < 0 || t._dp._ts < 0) && !le(t)) ? 0 : 1,
							f = t._rDelay,
							m = 0;
						if (f && t._repeat && (m = me(0, t._tDur, e), l = $t(m, f), t._yoyo && 1 & l && (d = 1 - d), l !== $t(t._tTime, f) && (h = 1 - d, t.vars.repeatRefresh && t._initted && t.invalidate())), d !== h || r || t._zTime === V || !e && t._zTime) {
							if (!t._initted && ae(t, e, r, n)) return;
							for (c = t._zTime, t._zTime = e || (n ? V : 0), n || (n = e && !c), t.ratio = d, t._from && (d = 1 - d), t._time = 0, t._tTime = m, o = t._pt; o;) o.r(d, o.d), o = o._next;
							t._startAt && e < 0 && t._startAt.render(e, !0, !0), t._onUpdate && !n && De(t, "onUpdate"), m && t._repeat && !n && t.parent && De(t, "onRepeat"), (e >= t._tDur || e < 0) && t.ratio === d && (d && Qt(t, 1), n || (De(t, d ? "onComplete" : "onReverseComplete", !0), t._prom && t._prom()))
						} else t._zTime || (t._zTime = e)
					}(this, t, e, n);
					return this
				}, n.targets = function() {
					return this._targets
				}, n.invalidate = function() {
					return this._pt = this._op = this._startAt = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(), t.prototype.invalidate.call(this)
				}, n.kill = function(t, e) {
					if (void 0 === e && (e = "all"), !(t || e && "all" !== e)) return this._lazy = this._pt = 0, this.parent ? Le(this) : this;
					if (this.timeline) {
						var n = this.timeline.totalDuration();
						return this.timeline.killTweensOf(t, e, sn && !0 !== sn.vars.overwrite)._first || Le(this), this.parent && n !== this.timeline.totalDuration() && ce(this, this._dur * this.timeline._tDur / n, 0, 1), this
					}
					var r, o, l, c, p, h, i, d = this._targets,
						f = t ? _e(t) : d,
						m = this._ptLookup,
						v = this._pt;
					if ((!e || "all" === e) && function(t, e) {
							for (var i = t.length, n = i === e.length; n && i-- && t[i] === e[i];);
							return i < 0
						}(d, f)) return "all" === e && (this._pt = 0), Le(this);
					for (r = this._op = this._op || [], "all" !== e && (K(e) && (p = {}, Bt(e, (function(t) {
							return p[t] = 1
						})), e = p), e = function(t, e) {
							var n, p, i, r, o = t[0] ? Pt(t[0]).harness : 0,
								l = o && o.aliases;
							if (!l) return e;
							for (p in n = Vt({}, e), l)
								if (p in n)
									for (i = (r = l[p].split(",")).length; i--;) n[r[i]] = n[p];
							return n
						}(d, e)), i = d.length; i--;)
						if (~f.indexOf(d[i]))
							for (p in o = m[i], "all" === e ? (r[i] = e, c = o, l = {}) : (l = r[i] = r[i] || {}, c = e), c)(h = o && o[p]) && ("kill" in h.d && !0 !== h.d.kill(p) || Yt(this, h, "_pt"), delete o[p]), "all" !== l && (l[p] = 1);
					return this._initted && !this._pt && v && Le(this), this
				}, e.to = function(t, n) {
					return new e(t, n, arguments[2])
				}, e.from = function(t, e) {
					return pe(1, arguments)
				}, e.delayedCall = function(t, n, r, o) {
					return new e(n, 0, {
						immediateRender: !1,
						lazy: !1,
						overwrite: !1,
						delay: t,
						onComplete: n,
						onReverseComplete: n,
						onCompleteParams: r,
						onReverseCompleteParams: r,
						callbackScope: o
					})
				}, e.fromTo = function(t, e, n) {
					return pe(2, arguments)
				}, e.set = function(t, n) {
					return n.duration = 0, n.repeatDelay || (n.repeat = 0), new e(t, n)
				}, e.killTweensOf = function(t, e, n) {
					return c.killTweensOf(t, e, n)
				}, e
			}(nn);
			Gt(fn.prototype, {
				_targets: [],
				_lazy: 0,
				_startAt: 0,
				_op: 0,
				_onInit: 0
			}), Bt("staggerTo,staggerFrom,staggerFromTo", (function(t) {
				fn[t] = function() {
					var e = new rn,
						n = ve.call(arguments, 0);
					return n.splice("staggerFromTo" === t ? 5 : 4, 0, 0), e[t].apply(e, n)
				}
			}));
			var mn = function(t, e, n) {
					return t[e] = n
				},
				gn = function(t, e, n) {
					return t[e](n)
				},
				vn = function(t, e, n, data) {
					return t[e](data.fp, n)
				},
				yn = function(t, e, n) {
					return t.setAttribute(e, n)
				},
				xn = function(t, e) {
					return Z(t[e]) ? gn : tt(t[e]) && t.setAttribute ? yn : mn
				},
				_n = function(t, data) {
					return data.set(data.t, data.p, Math.round(1e6 * (data.s + data.c * t)) / 1e6, data)
				},
				wn = function(t, data) {
					return data.set(data.t, data.p, !!(data.s + data.c * t), data)
				},
				An = function(t, data) {
					var e = data._pt,
						s = "";
					if (!t && data.b) s = data.b;
					else if (1 === t && data.e) s = data.e;
					else {
						for (; e;) s = e.p + (e.m ? e.m(e.s + e.c * t) : Math.round(1e4 * (e.s + e.c * t)) / 1e4) + s, e = e._next;
						s += data.c
					}
					data.set(data.t, data.p, s, data)
				},
				bn = function(t, data) {
					for (var e = data._pt; e;) e.r(t, e.d), e = e._next
				},
				Mn = function(t, e, n, r) {
					for (var o, l = this._pt; l;) o = l._next, l.p === r && l.modifier(t, e, n), l = o
				},
				Sn = function(t) {
					for (var e, n, r = this._pt; r;) n = r._next, r.p === t && !r.op || r.op === t ? Yt(this, r, "_pt") : r.dep || (e = 1), r = n;
					return !e
				},
				Tn = function(t, e, n, data) {
					data.mSet(t, e, data.m.call(data.tween, n, data.mt), data)
				},
				En = function(t) {
					for (var e, n, r, o, l = t._pt; l;) {
						for (e = l._next, n = r; n && n.pr > l.pr;) n = n._next;
						(l._prev = n ? n._prev : o) ? l._prev._next = l: r = l, (l._next = n) ? n._prev = l : o = l, l = e
					}
					t._pt = r
				},
				Cn = function() {
					function t(t, e, n, r, o, l, data, c, h) {
						this.t = e, this.s = r, this.c = o, this.p = n, this.r = l || _n, this.d = data || this, this.set = c || mn, this.pr = h || 0, this._next = t, t && (t._prev = this)
					}
					return t.prototype.modifier = function(t, e, n) {
						this.mSet = this.mSet || this.set, this.set = Tn, this.m = t, this.mt = n, this.tween = e
					}, t
				}();
			Bt(Dt + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", (function(t) {
				return bt[t] = 1
			})), gt.TweenMax = gt.TweenLite = fn, gt.TimelineLite = gt.TimelineMax = rn, c = new rn({
				sortChildren: !1,
				defaults: k,
				autoRemoveChildren: !0,
				id: "root",
				smoothChildTiming: !0
			}), z.stringFilter = ke;
			var Rn = {
				registerPlugin: function() {
					for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
					e.forEach((function(t) {
						return Pe(t)
					}))
				},
				timeline: function(t) {
					return new rn(t)
				},
				getTweensOf: function(t, e) {
					return c.getTweensOf(t, e)
				},
				getProperty: function(t, e, n, r) {
					K(t) && (t = _e(t)[0]);
					var o = Pt(t || {}).get,
						l = n ? kt : zt;
					return "native" === n && (n = ""), t ? e ? l((Tt[e] && Tt[e].get || o)(t, e, n, r)) : function(e, n, r) {
						return l((Tt[e] && Tt[e].get || o)(t, e, n, r))
					} : t
				},
				quickSetter: function(t, e, n) {
					if ((t = _e(t)).length > 1) {
						var r = t.map((function(t) {
								return Pn.quickSetter(t, e, n)
							})),
							o = r.length;
						return function(t) {
							for (var i = o; i--;) r[i](t)
						}
					}
					t = t[0] || {};
					var l = Tt[e],
						c = Pt(t),
						p = c.harness && (c.harness.aliases || {})[e] || e,
						h = l ? function(e) {
							var p = new l;
							y._pt = 0, p.init(t, n ? e + n : e, y, 0, [t]), p.render(1, p), y._pt && bn(1, y)
						} : c.set(t, p);
					return l ? h : function(e) {
						return h(t, p, n ? e + n : e, c, 1)
					}
				},
				isTweening: function(t) {
					return c.getTweensOf(t, !0).length > 0
				},
				defaults: function(t) {
					return t && t.ease && (t.ease = Je(t.ease, k.ease)), Wt(k, t || {})
				},
				config: function(t) {
					return Wt(z, t || {})
				},
				registerEffect: function(t) {
					var e = t.name,
						n = t.effect,
						r = t.plugins,
						o = t.defaults,
						l = t.extendTimeline;
					(r || "").split(",").forEach((function(t) {
						return t && !Tt[t] && !gt[t] && _t(e + " effect requires " + t + " plugin.")
					})), Et[e] = function(t, e, r) {
						return n(_e(t), Gt(e || {}, o), r)
					}, l && (rn.prototype[e] = function(t, n, r) {
						return this.add(Et[e](t, et(n) ? n : (r = n) && {}, this), r)
					})
				},
				registerEase: function(t, e) {
					We[t] = Je(e)
				},
				parseEase: function(t, e) {
					return arguments.length ? Je(t, e) : We
				},
				getById: function(t) {
					return c.getById(t)
				},
				exportRoot: function(t, e) {
					void 0 === t && (t = {});
					var n, r, o = new rn(t);
					for (o.smoothChildTiming = nt(t.smoothChildTiming), c.remove(o), o._dp = 0, o._time = o._tTime = c._time, n = c._first; n;) r = n._next, !e && !n._dur && n instanceof fn && n.vars.onComplete === n._targets[0] || re(o, n, n._start - n._delay), n = r;
					return re(c, o, 0), o
				},
				utils: {
					wrap: function t(e, n, r) {
						var o = n - e;
						return ot(e) ? Te(e, t(0, e.length), n) : fe(r, (function(t) {
							return (o + (t - e) % o) % o + e
						}))
					},
					wrapYoyo: function t(e, n, r) {
						var o = n - e,
							l = 2 * o;
						return ot(e) ? Te(e, t(0, e.length - 1), n) : fe(r, (function(t) {
							return e + ((t = (l + (t - e) % l) % l || 0) > o ? l - t : t)
						}))
					},
					distribute: Ae,
					random: Se,
					snap: Me,
					normalize: function(t, e, n) {
						return Ce(t, e, 0, 1, n)
					},
					getUnit: ge,
					clamp: function(t, e, n) {
						return fe(n, (function(n) {
							return me(t, e, n)
						}))
					},
					splitColor: Fe,
					toArray: _e,
					selector: function(t) {
						return t = _e(t)[0] || _t("Invalid scope") || {},
							function(e) {
								var n = t.current || t.nativeElement || t;
								return _e(e, n.querySelectorAll ? n : n === t ? _t("Invalid scope") || f.createElement("div") : t)
							}
					},
					mapRange: Ce,
					pipe: function() {
						for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++) e[n] = arguments[n];
						return function(t) {
							return e.reduce((function(t, e) {
								return e(t)
							}), t)
						}
					},
					unitize: function(t, e) {
						return function(n) {
							return t(parseFloat(n)) + (e || ge(n))
						}
					},
					interpolate: function t(e, n, progress, r) {
						var o = isNaN(e + n) ? 0 : function(p) {
							return (1 - p) * e + p * n
						};
						if (!o) {
							var p, i, l, c, h, d = K(e),
								f = {};
							if (!0 === progress && (r = 1) && (progress = null), d) e = {
								p: e
							}, n = {
								p: n
							};
							else if (ot(e) && !ot(n)) {
								for (l = [], c = e.length, h = c - 2, i = 1; i < c; i++) l.push(t(e[i - 1], e[i]));
								c--, o = function(p) {
									p *= c;
									var i = Math.min(h, ~~p);
									return l[i](p - i)
								}, progress = n
							} else r || (e = Vt(ot(e) ? [] : {}, e));
							if (!l) {
								for (p in n) on.call(f, e, p, "get", n[p]);
								o = function(p) {
									return bn(p, f) || (d ? e.p : e)
								}
							}
						}
						return fe(progress, o)
					},
					shuffle: we
				},
				install: yt,
				effects: Et,
				ticker: Ge,
				updateRoot: rn.updateRoot,
				plugins: Tt,
				globalTimeline: c,
				core: {
					PropTween: Cn,
					globals: wt,
					Tween: fn,
					Timeline: rn,
					Animation: nn,
					getCache: Pt,
					_removeLinkedListItem: Yt,
					suppressOverwrites: function(t) {
						return l = t
					}
				}
			};
			Bt("to,from,fromTo,delayedCall,set,killTweensOf", (function(t) {
				return Rn[t] = fn[t]
			})), Ge.add(rn.updateRoot), y = Rn.to({}, {
				duration: 0
			});
			var Dn = function(t, e) {
					for (var n = t._pt; n && n.p !== e && n.op !== e && n.fp !== e;) n = n._next;
					return n
				},
				Ln = function(t, e) {
					return {
						name: t,
						rawVars: 1,
						init: function(t, n, r) {
							r._onInit = function(t) {
								var r, p;
								if (K(n) && (r = {}, Bt(n, (function(t) {
										return r[t] = 1
									})), n = r), e) {
									for (p in r = {}, n) r[p] = e(n[p]);
									n = r
								}! function(t, e) {
									var p, i, n, r = t._targets;
									for (p in e)
										for (i = r.length; i--;)(n = t._ptLookup[i][p]) && (n = n.d) && (n._pt && (n = Dn(n, p)), n && n.modifier && n.modifier(e[p], t, r[i], p))
								}(t, n)
							}
						}
					}
				},
				Pn = Rn.registerPlugin({
					name: "attr",
					init: function(t, e, n, r, o) {
						var p, l;
						for (p in e)(l = this.add(t, "setAttribute", (t.getAttribute(p) || 0) + "", e[p], r, o, 0, 0, p)) && (l.op = p), this._props.push(p)
					}
				}, {
					name: "endArray",
					init: function(t, e) {
						for (var i = e.length; i--;) this.add(t, i, t[i] || 0, e[i])
					}
				}, Ln("roundProps", be), Ln("modifiers"), Ln("snap", Me)) || Rn;
			fn.version = rn.version = Pn.version = "3.9.1", m = 1, it() && Ve();
			We.Power0, We.Power1, We.Power2, We.Power3, We.Power4, We.Linear, We.Quad, We.Cubic, We.Quart, We.Quint, We.Strong, We.Elastic, We.Back, We.SteppedEase, We.Bounce, We.Sine, We.Expo, We.Circ;
			var In, Bn, On, Fn, Hn, Nn, Un, zn = {},
				kn = 180 / Math.PI,
				Gn = Math.PI / 180,
				Vn = Math.atan2,
				Wn = /([A-Z])/g,
				jn = /(?:left|right|width|margin|padding|x)/i,
				Xn = /[\s,\(]\S/,
				Yn = {
					autoAlpha: "opacity,visibility",
					scale: "scaleX,scaleY",
					alpha: "opacity"
				},
				Qn = function(t, data) {
					return data.set(data.t, data.p, Math.round(1e4 * (data.s + data.c * t)) / 1e4 + data.u, data)
				},
				qn = function(t, data) {
					return data.set(data.t, data.p, 1 === t ? data.e : Math.round(1e4 * (data.s + data.c * t)) / 1e4 + data.u, data)
				},
				Jn = function(t, data) {
					return data.set(data.t, data.p, t ? Math.round(1e4 * (data.s + data.c * t)) / 1e4 + data.u : data.b, data)
				},
				Kn = function(t, data) {
					var e = data.s + data.c * t;
					data.set(data.t, data.p, ~~(e + (e < 0 ? -.5 : .5)) + data.u, data)
				},
				Zn = function(t, data) {
					return data.set(data.t, data.p, t ? data.e : data.b, data)
				},
				$n = function(t, data) {
					return data.set(data.t, data.p, 1 !== t ? data.b : data.e, data)
				},
				ti = function(t, e, n) {
					return t.style[e] = n
				},
				ei = function(t, e, n) {
					return t.style.setProperty(e, n)
				},
				ni = function(t, e, n) {
					return t._gsap[e] = n
				},
				ii = function(t, e, n) {
					return t._gsap.scaleX = t._gsap.scaleY = n
				},
				ri = function(t, e, n, data, r) {
					var o = t._gsap;
					o.scaleX = o.scaleY = n, o.renderTransform(r, o)
				},
				si = function(t, e, n, data, r) {
					var o = t._gsap;
					o[e] = n, o.renderTransform(r, o)
				},
				ai = "transform",
				oi = ai + "Origin",
				ci = function(t, e) {
					var n = Bn.createElementNS ? Bn.createElementNS((e || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), t) : Bn.createElement(t);
					return n.style ? n : Bn.createElement(t)
				},
				hi = function t(e, n, r) {
					var o = getComputedStyle(e);
					return o[n] || o.getPropertyValue(n.replace(Wn, "-$1").toLowerCase()) || o.getPropertyValue(n) || !r && t(e, di(n) || n, 1) || ""
				},
				ui = "O,Moz,ms,Ms,Webkit".split(","),
				di = function(t, element, e) {
					var s = (element || Hn).style,
						i = 5;
					if (t in s && !e) return t;
					for (t = t.charAt(0).toUpperCase() + t.substr(1); i-- && !(ui[i] + t in s););
					return i < 0 ? null : (3 === i ? "ms" : i >= 0 ? ui[i] : "") + t
				},
				pi = function() {
					"undefined" != typeof window && window.document && (In = window, Bn = In.document, On = Bn.documentElement, Hn = ci("div") || {
						style: {}
					}, ci("div"), ai = di(ai), oi = ai + "Origin", Hn.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Un = !!di("perspective"), Fn = 1)
				},
				fi = function t(e) {
					var n, svg = ci("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
						r = this.parentNode,
						o = this.nextSibling,
						l = this.style.cssText;
					if (On.appendChild(svg), svg.appendChild(this), this.style.display = "block", e) try {
						n = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = t
					} catch (t) {} else this._gsapBBox && (n = this._gsapBBox());
					return r && (o ? r.insertBefore(this, o) : r.appendChild(this)), On.removeChild(svg), this.style.cssText = l, n
				},
				mi = function(t, e) {
					for (var i = e.length; i--;)
						if (t.hasAttribute(e[i])) return t.getAttribute(e[i])
				},
				gi = function(t) {
					var e;
					try {
						e = t.getBBox()
					} catch (n) {
						e = fi.call(t, !0)
					}
					return e && (e.width || e.height) || t.getBBox === fi || (e = fi.call(t, !0)), !e || e.width || e.x || e.y ? e : {
						x: +mi(t, ["x", "cx", "x1"]) || 0,
						y: +mi(t, ["y", "cy", "y1"]) || 0,
						width: 0,
						height: 0
					}
				},
				vi = function(t) {
					return !(!t.getCTM || t.parentNode && !t.ownerSVGElement || !gi(t))
				},
				yi = function(t, e) {
					if (e) {
						var style = t.style;
						e in zn && e !== oi && (e = ai), style.removeProperty ? ("ms" !== e.substr(0, 2) && "webkit" !== e.substr(0, 6) || (e = "-" + e), style.removeProperty(e.replace(Wn, "-$1").toLowerCase())) : style.removeAttribute(e)
					}
				},
				xi = function(t, e, n, r, o, l) {
					var c = new Cn(t._pt, e, n, 0, 1, l ? $n : Zn);
					return t._pt = c, c.b = r, c.e = o, t._props.push(n), c
				},
				_i = {
					deg: 1,
					rad: 1,
					turn: 1
				},
				wi = function t(e, n, r, o) {
					var l, c, h, d, f = parseFloat(r) || 0,
						m = (r + "").trim().substr((f + "").length) || "px",
						style = Hn.style,
						v = jn.test(n),
						y = "svg" === e.tagName.toLowerCase(),
						x = (y ? "client" : "offset") + (v ? "Width" : "Height"),
						_ = 100,
						w = "px" === o,
						A = "%" === o;
					return o === m || !f || _i[o] || _i[m] ? f : ("px" !== m && !w && (f = t(e, n, r, "px")), d = e.getCTM && vi(e), !A && "%" !== m || !zn[n] && !~n.indexOf("adius") ? (style[v ? "width" : "height"] = _ + (w ? m : o), c = ~n.indexOf("adius") || "em" === o && e.appendChild && !y ? e : e.parentNode, d && (c = (e.ownerSVGElement || {}).parentNode), c && c !== Bn && c.appendChild || (c = Bn.body), (h = c._gsap) && A && h.width && v && h.time === Ge.time ? Ot(f / h.width * _) : ((A || "%" === m) && (style.position = hi(e, "position")), c === e && (style.position = "static"), c.appendChild(Hn), l = Hn[x], c.removeChild(Hn), style.position = "absolute", v && A && ((h = Pt(c)).time = Ge.time, h.width = c[x]), Ot(w ? l * f / _ : l && f ? _ / l * f : 0))) : (l = d ? e.getBBox()[v ? "width" : "height"] : e[x], Ot(A ? f / l * _ : f / 100 * l)))
				},
				Ai = function(t, e, n, r) {
					var o;
					return Fn || pi(), e in Yn && "transform" !== e && ~(e = Yn[e]).indexOf(",") && (e = e.split(",")[0]), zn[e] && "transform" !== e ? (o = Ii(t, r), o = "transformOrigin" !== e ? o[e] : o.svg ? o.origin : Bi(hi(t, oi)) + " " + o.zOrigin + "px") : (!(o = t.style[e]) || "auto" === o || r || ~(o + "").indexOf("calc(")) && (o = Ti[e] && Ti[e](t, e, n) || hi(t, e) || It(t, e) || ("opacity" === e ? 1 : 0)), n && !~(o + "").trim().indexOf(" ") ? wi(t, e, o, n) + n : o
				},
				bi = function(t, e, n, r) {
					if (!n || "none" === n) {
						var p = di(e, t, 1),
							s = p && hi(t, p, 1);
						s && s !== n ? (e = p, n = s) : "borderColor" === e && (n = hi(t, "borderTopColor"))
					}
					var a, o, l, c, h, d, f, m, v, y, x, _, w = new Cn(this._pt, t.style, e, 0, 1, An),
						A = 0,
						M = 0;
					if (w.b = n, w.e = r, n += "", "auto" === (r += "") && (t.style[e] = r, r = hi(t, e) || r, t.style[e] = n), ke(a = [n, r]), r = a[1], l = (n = a[0]).match(ht) || [], (r.match(ht) || []).length) {
						for (; o = ht.exec(r);) f = o[0], v = r.substring(A, o.index), h ? h = (h + 1) % 5 : "rgba(" !== v.substr(-5) && "hsla(" !== v.substr(-5) || (h = 1), f !== (d = l[M++] || "") && (c = parseFloat(d) || 0, x = d.substr((c + "").length), (_ = "=" === f.charAt(1) ? +(f.charAt(0) + "1") : 0) && (f = f.substr(2)), m = parseFloat(f), y = f.substr((m + "").length), A = ht.lastIndex - y.length, y || (y = y || z.units[e] || x, A === r.length && (r += y, w.e += y)), x !== y && (c = wi(t, e, d, y) || 0), w._pt = {
							_next: w._pt,
							p: v || 1 === M ? v : ",",
							s: c,
							c: _ ? _ * m : m - c,
							m: h && h < 4 || "zIndex" === e ? Math.round : 0
						});
						w.c = A < r.length ? r.substring(A, r.length) : ""
					} else w.r = "display" === e && "none" === r ? $n : Zn;
					return pt.test(r) && (w.e = 0), this._pt = w, w
				},
				Mi = {
					top: "0%",
					bottom: "100%",
					left: "0%",
					right: "100%",
					center: "50%"
				},
				Si = function(t, data) {
					if (data.tween && data.tween._time === data.tween._dur) {
						var e, n, i, r = data.t,
							style = r.style,
							o = data.u,
							l = r._gsap;
						if ("all" === o || !0 === o) style.cssText = "", n = 1;
						else
							for (i = (o = o.split(",")).length; --i > -1;) e = o[i], zn[e] && (n = 1, e = "transformOrigin" === e ? oi : ai), yi(r, e);
						n && (yi(r, ai), l && (l.svg && r.removeAttribute("transform"), Ii(r, 1), l.uncache = 1))
					}
				},
				Ti = {
					clearProps: function(t, e, n, r, o) {
						if ("isFromStart" !== o.data) {
							var l = t._pt = new Cn(t._pt, e, n, 0, 0, Si);
							return l.u = r, l.pr = -10, l.tween = o, t._props.push(n), 1
						}
					}
				},
				Ei = [1, 0, 0, 1, 0, 0],
				Ci = {},
				Ri = function(t) {
					return "matrix(1, 0, 0, 1, 0, 0)" === t || "none" === t || !t
				},
				Di = function(t) {
					var e = hi(t, ai);
					return Ri(e) ? Ei : e.substr(7).match(ct).map(Ot)
				},
				Li = function(t, e) {
					var n, r, o, l, c = t._gsap || Pt(t),
						style = t.style,
						h = Di(t);
					return c.svg && t.getAttribute("transform") ? "1,0,0,1,0,0" === (h = [(o = t.transform.baseVal.consolidate().matrix).a, o.b, o.c, o.d, o.e, o.f]).join(",") ? Ei : h : (h !== Ei || t.offsetParent || t === On || c.svg || (o = style.display, style.display = "block", (n = t.parentNode) && t.offsetParent || (l = 1, r = t.nextSibling, On.appendChild(t)), h = Di(t), o ? style.display = o : yi(t, "display"), l && (r ? n.insertBefore(t, r) : n ? n.appendChild(t) : On.removeChild(t))), e && h.length > 6 ? [h[0], h[1], h[4], h[5], h[12], h[13]] : h)
				},
				Pi = function(t, e, n, r, o, l) {
					var c, h, d, f = t._gsap,
						m = o || Li(t, !0),
						v = f.xOrigin || 0,
						y = f.yOrigin || 0,
						x = f.xOffset || 0,
						_ = f.yOffset || 0,
						a = m[0],
						b = m[1],
						w = m[2],
						A = m[3],
						M = m[4],
						S = m[5],
						T = e.split(" "),
						E = parseFloat(T[0]) || 0,
						C = parseFloat(T[1]) || 0;
					n ? m !== Ei && (h = a * A - b * w) && (d = E * (-b / h) + C * (a / h) - (a * S - b * M) / h, E = E * (A / h) + C * (-w / h) + (w * S - A * M) / h, C = d) : (E = (c = gi(t)).x + (~T[0].indexOf("%") ? E / 100 * c.width : E), C = c.y + (~(T[1] || T[0]).indexOf("%") ? C / 100 * c.height : C)), r || !1 !== r && f.smooth ? (M = E - v, S = C - y, f.xOffset = x + (M * a + S * w) - M, f.yOffset = _ + (M * b + S * A) - S) : f.xOffset = f.yOffset = 0, f.xOrigin = E, f.yOrigin = C, f.smooth = !!r, f.origin = e, f.originIsAbsolute = !!n, t.style[oi] = "0px 0px", l && (xi(l, f, "xOrigin", v, E), xi(l, f, "yOrigin", y, C), xi(l, f, "xOffset", x, f.xOffset), xi(l, f, "yOffset", _, f.yOffset)), t.setAttribute("data-svg-origin", E + " " + C)
				},
				Ii = function(t, e) {
					var n = t._gsap || new en(t);
					if ("x" in n && !e && !n.uncache) return n;
					var r, o, l, c, h, d, f, m, v, y, x, _, w, A, M, S, T, a, b, E, C, R, D, L, P, I, B, O, F, H, N, U, style = t.style,
						k = n.scaleX < 0,
						G = "px",
						V = "deg",
						W = hi(t, oi) || "0";
					return r = o = l = d = f = m = v = y = x = 0, c = h = 1, n.svg = !(!t.getCTM || !vi(t)), A = Li(t, n.svg), n.svg && (L = (!n.uncache || "0px 0px" === W) && !e && t.getAttribute("data-svg-origin"), Pi(t, L || W, !!L || n.originIsAbsolute, !1 !== n.smooth, A)), _ = n.xOrigin || 0, w = n.yOrigin || 0, A !== Ei && (a = A[0], b = A[1], E = A[2], C = A[3], r = R = A[4], o = D = A[5], 6 === A.length ? (c = Math.sqrt(a * a + b * b), h = Math.sqrt(C * C + E * E), d = a || b ? Vn(b, a) * kn : 0, (v = E || C ? Vn(E, C) * kn + d : 0) && (h *= Math.abs(Math.cos(v * Gn))), n.svg && (r -= _ - (_ * a + w * E), o -= w - (_ * b + w * C))) : (U = A[6], H = A[7], B = A[8], O = A[9], F = A[10], N = A[11], r = A[12], o = A[13], l = A[14], f = (M = Vn(U, F)) * kn, M && (L = R * (S = Math.cos(-M)) + B * (T = Math.sin(-M)), P = D * S + O * T, I = U * S + F * T, B = R * -T + B * S, O = D * -T + O * S, F = U * -T + F * S, N = H * -T + N * S, R = L, D = P, U = I), m = (M = Vn(-E, F)) * kn, M && (S = Math.cos(-M), N = C * (T = Math.sin(-M)) + N * S, a = L = a * S - B * T, b = P = b * S - O * T, E = I = E * S - F * T), d = (M = Vn(b, a)) * kn, M && (L = a * (S = Math.cos(M)) + b * (T = Math.sin(M)), P = R * S + D * T, b = b * S - a * T, D = D * S - R * T, a = L, R = P), f && Math.abs(f) + Math.abs(d) > 359.9 && (f = d = 0, m = 180 - m), c = Ot(Math.sqrt(a * a + b * b + E * E)), h = Ot(Math.sqrt(D * D + U * U)), M = Vn(R, D), v = Math.abs(M) > 2e-4 ? M * kn : 0, x = N ? 1 / (N < 0 ? -N : N) : 0), n.svg && (L = t.getAttribute("transform"), n.forceCSS = t.setAttribute("transform", "") || !Ri(hi(t, ai)), L && t.setAttribute("transform", L))), Math.abs(v) > 90 && Math.abs(v) < 270 && (k ? (c *= -1, v += d <= 0 ? 180 : -180, d += d <= 0 ? 180 : -180) : (h *= -1, v += v <= 0 ? 180 : -180)), n.x = r - ((n.xPercent = r && (n.xPercent || (Math.round(t.offsetWidth / 2) === Math.round(-r) ? -50 : 0))) ? t.offsetWidth * n.xPercent / 100 : 0) + G, n.y = o - ((n.yPercent = o && (n.yPercent || (Math.round(t.offsetHeight / 2) === Math.round(-o) ? -50 : 0))) ? t.offsetHeight * n.yPercent / 100 : 0) + G, n.z = l + G, n.scaleX = Ot(c), n.scaleY = Ot(h), n.rotation = Ot(d) + V, n.rotationX = Ot(f) + V, n.rotationY = Ot(m) + V, n.skewX = v + V, n.skewY = y + V, n.transformPerspective = x + G, (n.zOrigin = parseFloat(W.split(" ")[2]) || 0) && (style[oi] = Bi(W)), n.xOffset = n.yOffset = 0, n.force3D = z.force3D, n.renderTransform = n.svg ? ki : Un ? zi : Fi, n.uncache = 0, n
				},
				Bi = function(t) {
					return (t = t.split(" "))[0] + " " + t[1]
				},
				Oi = function(t, e, n) {
					var r = ge(e);
					return Ot(parseFloat(e) + parseFloat(wi(t, "x", n + "px", r))) + r
				},
				Fi = function(t, e) {
					e.z = "0px", e.rotationY = e.rotationX = "0deg", e.force3D = 0, zi(t, e)
				},
				Hi = "0deg",
				Ni = "0px",
				Ui = ") ",
				zi = function(t, e) {
					var n = e || this,
						r = n.xPercent,
						o = n.yPercent,
						l = n.x,
						c = n.y,
						h = n.z,
						d = n.rotation,
						f = n.rotationY,
						m = n.rotationX,
						v = n.skewX,
						y = n.skewY,
						x = n.scaleX,
						_ = n.scaleY,
						w = n.transformPerspective,
						A = n.force3D,
						M = n.target,
						S = n.zOrigin,
						T = "",
						E = "auto" === A && t && 1 !== t || !0 === A;
					if (S && (m !== Hi || f !== Hi)) {
						var C, R = parseFloat(f) * Gn,
							D = Math.sin(R),
							L = Math.cos(R);
						R = parseFloat(m) * Gn, C = Math.cos(R), l = Oi(M, l, D * C * -S), c = Oi(M, c, -Math.sin(R) * -S), h = Oi(M, h, L * C * -S + S)
					}
					w !== Ni && (T += "perspective(" + w + Ui), (r || o) && (T += "translate(" + r + "%, " + o + "%) "), (E || l !== Ni || c !== Ni || h !== Ni) && (T += h !== Ni || E ? "translate3d(" + l + ", " + c + ", " + h + ") " : "translate(" + l + ", " + c + Ui), d !== Hi && (T += "rotate(" + d + Ui), f !== Hi && (T += "rotateY(" + f + Ui), m !== Hi && (T += "rotateX(" + m + Ui), v === Hi && y === Hi || (T += "skew(" + v + ", " + y + Ui), 1 === x && 1 === _ || (T += "scale(" + x + ", " + _ + Ui), M.style[ai] = T || "translate(0, 0)"
				},
				ki = function(t, e) {
					var n, r, o, l, c, h = e || this,
						d = h.xPercent,
						f = h.yPercent,
						m = h.x,
						v = h.y,
						y = h.rotation,
						x = h.skewX,
						_ = h.skewY,
						w = h.scaleX,
						A = h.scaleY,
						M = h.target,
						S = h.xOrigin,
						T = h.yOrigin,
						E = h.xOffset,
						C = h.yOffset,
						R = h.forceCSS,
						D = parseFloat(m),
						L = parseFloat(v);
					y = parseFloat(y), x = parseFloat(x), (_ = parseFloat(_)) && (x += _ = parseFloat(_), y += _), y || x ? (y *= Gn, x *= Gn, n = Math.cos(y) * w, r = Math.sin(y) * w, o = Math.sin(y - x) * -A, l = Math.cos(y - x) * A, x && (_ *= Gn, c = Math.tan(x - _), o *= c = Math.sqrt(1 + c * c), l *= c, _ && (c = Math.tan(_), n *= c = Math.sqrt(1 + c * c), r *= c)), n = Ot(n), r = Ot(r), o = Ot(o), l = Ot(l)) : (n = w, l = A, r = o = 0), (D && !~(m + "").indexOf("px") || L && !~(v + "").indexOf("px")) && (D = wi(M, "x", m, "px"), L = wi(M, "y", v, "px")), (S || T || E || C) && (D = Ot(D + S - (S * n + T * o) + E), L = Ot(L + T - (S * r + T * l) + C)), (d || f) && (c = M.getBBox(), D = Ot(D + d / 100 * c.width), L = Ot(L + f / 100 * c.height)), c = "matrix(" + n + "," + r + "," + o + "," + l + "," + D + "," + L + ")", M.setAttribute("transform", c), R && (M.style[ai] = c)
				},
				Gi = function(t, e, n, r, o, l) {
					var c, h, d = 360,
						f = K(o),
						m = parseFloat(o) * (f && ~o.indexOf("rad") ? kn : 1),
						v = l ? m * l : m - r,
						y = r + v + "deg";
					return f && ("short" === (c = o.split("_")[1]) && (v %= d) !== v % 180 && (v += v < 0 ? d : -360), "cw" === c && v < 0 ? v = (v + 36e9) % d - ~~(v / d) * d : "ccw" === c && v > 0 && (v = (v - 36e9) % d - ~~(v / d) * d)), t._pt = h = new Cn(t._pt, e, n, r, v, qn), h.e = y, h.u = "deg", t._props.push(n), h
				},
				Vi = function(t, source) {
					for (var p in source) t[p] = source[p];
					return t
				},
				Wi = function(t, e, n) {
					var r, p, o, l, c, h, d, f = Vi({}, n._gsap),
						style = n.style;
					for (p in f.svg ? (o = n.getAttribute("transform"), n.setAttribute("transform", ""), style[ai] = e, r = Ii(n, 1), yi(n, ai), n.setAttribute("transform", o)) : (o = getComputedStyle(n)[ai], style[ai] = e, r = Ii(n, 1), style[ai] = o), zn)(o = f[p]) !== (l = r[p]) && "perspective,force3D,transformOrigin,svgOrigin".indexOf(p) < 0 && (c = ge(o) !== (d = ge(l)) ? wi(n, p, o, d) : parseFloat(o), h = parseFloat(l), t._pt = new Cn(t._pt, r, p, c, h - c, Qn), t._pt.u = d || 0, t._props.push(p));
					Vi(r, f)
				};
			Bt("padding,margin,Width,Radius", (function(t, e) {
				var n = "Top",
					r = "Right",
					b = "Bottom",
					o = "Left",
					l = (e < 3 ? [n, r, b, o] : [n + o, n + r, b + r, b + o]).map((function(n) {
						return e < 2 ? t + n : "border" + n + t
					}));
				Ti[e > 1 ? "border" + t : t] = function(t, e, n, r, o) {
					var a, c;
					if (arguments.length < 4) return a = l.map((function(e) {
						return Ai(t, e, n)
					})), 5 === (c = a.join(" ")).split(a[0]).length ? a[0] : c;
					a = (r + "").split(" "), c = {}, l.forEach((function(t, i) {
						return c[t] = a[i] = a[i] || a[(i - 1) / 2 | 0]
					})), t.init(e, c, o)
				}
			}));
			var ji, Xi, Yi, Qi = {
				name: "css",
				register: pi,
				targetTest: function(t) {
					return t.style && t.nodeType
				},
				init: function(t, e, n, r, o) {
					var l, c, h, d, f, m, p, v, y, x, _, w, A, M, S, T, E, C, R, D = this._props,
						style = t.style,
						L = n.vars.startAt;
					for (p in Fn || pi(), e)
						if ("autoRound" !== p && (c = e[p], !Tt[p] || !ln(p, e, n, r, t, o)))
							if (f = typeof c, m = Ti[p], "function" === f && (f = typeof(c = c.call(n, r, t, o))), "string" === f && ~c.indexOf("random(") && (c = Ee(c)), m) m(this, t, p, c, n) && (S = 1);
							else if ("--" === p.substr(0, 2)) l = (getComputedStyle(t).getPropertyValue(p) + "").trim(), c += "", Ue.lastIndex = 0, Ue.test(l) || (v = ge(l), y = ge(c)), y ? v !== y && (l = wi(t, p, l, y) + y) : v && (c += v), this.add(style, "setProperty", l, c, r, o, 0, 0, p), D.push(p);
					else if ("undefined" !== f) {
						if (L && p in L ? (l = "function" == typeof L[p] ? L[p].call(n, r, t, o) : L[p], K(l) && ~l.indexOf("random(") && (l = Ee(l)), ge(l + "") || (l += z.units[p] || ge(Ai(t, p)) || ""), "=" === (l + "").charAt(1) && (l = Ai(t, p))) : l = Ai(t, p), d = parseFloat(l), (x = "string" === f && "=" === c.charAt(1) ? +(c.charAt(0) + "1") : 0) && (c = c.substr(2)), h = parseFloat(c), p in Yn && ("autoAlpha" === p && (1 === d && "hidden" === Ai(t, "visibility") && h && (d = 0), xi(this, style, "visibility", d ? "inherit" : "hidden", h ? "inherit" : "hidden", !h)), "scale" !== p && "transform" !== p && ~(p = Yn[p]).indexOf(",") && (p = p.split(",")[0])), _ = p in zn)
							if (w || ((A = t._gsap).renderTransform && !e.parseTransform || Ii(t, e.parseTransform), M = !1 !== e.smoothOrigin && A.smooth, (w = this._pt = new Cn(this._pt, style, ai, 0, 1, A.renderTransform, A, 0, -1)).dep = 1), "scale" === p) this._pt = new Cn(this._pt, A, "scaleY", A.scaleY, (x ? x * h : h - A.scaleY) || 0), D.push("scaleY", p), p += "X";
							else {
								if ("transformOrigin" === p) {
									E = void 0, C = void 0, R = void 0, E = (T = c).split(" "), C = E[0], R = E[1] || "50%", "top" !== C && "bottom" !== C && "left" !== R && "right" !== R || (T = C, C = R, R = T), E[0] = Mi[C] || C, E[1] = Mi[R] || R, c = E.join(" "), A.svg ? Pi(t, c, 0, M, 0, this) : ((y = parseFloat(c.split(" ")[2]) || 0) !== A.zOrigin && xi(this, A, "zOrigin", A.zOrigin, y), xi(this, style, p, Bi(l), Bi(c)));
									continue
								}
								if ("svgOrigin" === p) {
									Pi(t, c, 1, M, 0, this);
									continue
								}
								if (p in Ci) {
									Gi(this, A, p, d, c, x);
									continue
								}
								if ("smoothOrigin" === p) {
									xi(this, A, "smooth", A.smooth, c);
									continue
								}
								if ("force3D" === p) {
									A[p] = c;
									continue
								}
								if ("transform" === p) {
									Wi(this, c, t);
									continue
								}
							}
						else p in style || (p = di(p) || p);
						if (_ || (h || 0 === h) && (d || 0 === d) && !Xn.test(c) && p in style) h || (h = 0), (v = (l + "").substr((d + "").length)) !== (y = ge(c) || (p in z.units ? z.units[p] : v)) && (d = wi(t, p, l, y)), this._pt = new Cn(this._pt, _ ? A : style, p, d, x ? x * h : h - d, _ || "px" !== y && "zIndex" !== p || !1 === e.autoRound ? Qn : Kn), this._pt.u = y || 0, v !== y && "%" !== y && (this._pt.b = l, this._pt.r = Jn);
						else if (p in style) bi.call(this, t, p, l, c);
						else {
							if (!(p in t)) {
								xt(p, c);
								continue
							}
							this.add(t, p, l || t[p], c, r, o)
						}
						D.push(p)
					}
					S && En(this)
				},
				get: Ai,
				aliases: Yn,
				getSetter: function(t, e, n) {
					var p = Yn[e];
					return p && p.indexOf(",") < 0 && (e = p), e in zn && e !== oi && (t._gsap.x || Ai(t, "x")) ? n && Nn === n ? "scale" === e ? ii : ni : (Nn = n || {}) && ("scale" === e ? ri : si) : t.style && !tt(t.style[e]) ? ti : ~e.indexOf("-") ? ei : xn(t, e)
				},
				core: {
					_removeProperty: yi,
					_getMatrix: Li
				}
			};
			Pn.utils.checkPrefix = di, Yi = Bt((ji = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") + "," + (Xi = "rotation,rotationX,rotationY,skewX,skewY") + ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", (function(t) {
				zn[t] = 1
			})), Bt(Xi, (function(t) {
				z.units[t] = "deg", Ci[t] = 1
			})), Yn[Yi[13]] = ji + "," + Xi, Bt("0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY", (function(t) {
				var e = t.split(":");
				Yn[e[1]] = Yi[e[0]]
			})), Bt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", (function(t) {
				z.units[t] = "px"
			})), Pn.registerPlugin(Qi);
			var qi = Pn.registerPlugin(Qi) || Pn;
			qi.core.Tween
		},
		261: function(module, exports, __webpack_require__) {
			(function(process, global) {
				var __WEBPACK_AMD_DEFINE_RESULT__;
				(function() {
					"use strict";
					var root = "object" == typeof window ? window : {},
						NODE_JS = !root.JS_SHA1_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node;
					NODE_JS && (root = global);
					var COMMON_JS = !root.JS_SHA1_NO_COMMON_JS && "object" == typeof module && module.exports,
						AMD = __webpack_require__(262),
						HEX_CHARS = "0123456789abcdef".split(""),
						EXTRA = [-2147483648, 8388608, 32768, 128],
						SHIFT = [24, 16, 8, 0],
						OUTPUT_TYPES = ["hex", "array", "digest", "arrayBuffer"],
						blocks = [],
						createOutputMethod = function(t) {
							return function(e) {
								return new Sha1(!0).update(e)[t]()
							}
						},
						createMethod = function() {
							var t = createOutputMethod("hex");
							NODE_JS && (t = nodeWrap(t)), t.create = function() {
								return new Sha1
							}, t.update = function(e) {
								return t.create().update(e)
							};
							for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
								var e = OUTPUT_TYPES[i];
								t[e] = createOutputMethod(e)
							}
							return t
						},
						nodeWrap = function(method) {
							var crypto = eval("require('crypto')"),
								Buffer = eval("require('buffer').Buffer"),
								nodeMethod = function(t) {
									if ("string" == typeof t) return crypto.createHash("sha1").update(t, "utf8").digest("hex");
									if (t.constructor === ArrayBuffer) t = new Uint8Array(t);
									else if (void 0 === t.length) return method(t);
									return crypto.createHash("sha1").update(new Buffer(t)).digest("hex")
								};
							return nodeMethod
						};

					function Sha1(t) {
						t ? (blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0, this.blocks = blocks) : this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.h0 = 1732584193, this.h1 = 4023233417, this.h2 = 2562383102, this.h3 = 271733878, this.h4 = 3285377520, this.block = this.start = this.bytes = this.hBytes = 0, this.finalized = this.hashed = !1, this.first = !0
					}
					Sha1.prototype.update = function(t) {
						if (!this.finalized) {
							var e = "string" != typeof t;
							e && t.constructor === root.ArrayBuffer && (t = new Uint8Array(t));
							for (var code, i, n = 0, r = t.length || 0, o = this.blocks; n < r;) {
								if (this.hashed && (this.hashed = !1, o[0] = this.block, o[16] = o[1] = o[2] = o[3] = o[4] = o[5] = o[6] = o[7] = o[8] = o[9] = o[10] = o[11] = o[12] = o[13] = o[14] = o[15] = 0), e)
									for (i = this.start; n < r && i < 64; ++n) o[i >> 2] |= t[n] << SHIFT[3 & i++];
								else
									for (i = this.start; n < r && i < 64; ++n)(code = t.charCodeAt(n)) < 128 ? o[i >> 2] |= code << SHIFT[3 & i++] : code < 2048 ? (o[i >> 2] |= (192 | code >> 6) << SHIFT[3 & i++], o[i >> 2] |= (128 | 63 & code) << SHIFT[3 & i++]) : code < 55296 || code >= 57344 ? (o[i >> 2] |= (224 | code >> 12) << SHIFT[3 & i++], o[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[3 & i++], o[i >> 2] |= (128 | 63 & code) << SHIFT[3 & i++]) : (code = 65536 + ((1023 & code) << 10 | 1023 & t.charCodeAt(++n)), o[i >> 2] |= (240 | code >> 18) << SHIFT[3 & i++], o[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[3 & i++], o[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[3 & i++], o[i >> 2] |= (128 | 63 & code) << SHIFT[3 & i++]);
								this.lastByteIndex = i, this.bytes += i - this.start, i >= 64 ? (this.block = o[16], this.start = i - 64, this.hash(), this.hashed = !0) : this.start = i
							}
							return this.bytes > 4294967295 && (this.hBytes += this.bytes / 4294967296 << 0, this.bytes = this.bytes % 4294967296), this
						}
					}, Sha1.prototype.finalize = function() {
						if (!this.finalized) {
							this.finalized = !0;
							var t = this.blocks,
								i = this.lastByteIndex;
							t[16] = this.block, t[i >> 2] |= EXTRA[3 & i], this.block = t[16], i >= 56 && (this.hashed || this.hash(), t[0] = this.block, t[16] = t[1] = t[2] = t[3] = t[4] = t[5] = t[6] = t[7] = t[8] = t[9] = t[10] = t[11] = t[12] = t[13] = t[14] = t[15] = 0), t[14] = this.hBytes << 3 | this.bytes >>> 29, t[15] = this.bytes << 3, this.hash()
						}
					}, Sha1.prototype.hash = function() {
						var t, e, a = this.h0,
							b = this.h1,
							n = this.h2,
							r = this.h3,
							o = this.h4,
							l = this.blocks;
						for (t = 16; t < 80; ++t) e = l[t - 3] ^ l[t - 8] ^ l[t - 14] ^ l[t - 16], l[t] = e << 1 | e >>> 31;
						for (t = 0; t < 20; t += 5) a = (e = (b = (e = (n = (e = (r = (e = (o = (e = a << 5 | a >>> 27) + (b & n | ~b & r) + o + 1518500249 + l[t] << 0) << 5 | o >>> 27) + (a & (b = b << 30 | b >>> 2) | ~a & n) + r + 1518500249 + l[t + 1] << 0) << 5 | r >>> 27) + (o & (a = a << 30 | a >>> 2) | ~o & b) + n + 1518500249 + l[t + 2] << 0) << 5 | n >>> 27) + (r & (o = o << 30 | o >>> 2) | ~r & a) + b + 1518500249 + l[t + 3] << 0) << 5 | b >>> 27) + (n & (r = r << 30 | r >>> 2) | ~n & o) + a + 1518500249 + l[t + 4] << 0, n = n << 30 | n >>> 2;
						for (; t < 40; t += 5) a = (e = (b = (e = (n = (e = (r = (e = (o = (e = a << 5 | a >>> 27) + (b ^ n ^ r) + o + 1859775393 + l[t] << 0) << 5 | o >>> 27) + (a ^ (b = b << 30 | b >>> 2) ^ n) + r + 1859775393 + l[t + 1] << 0) << 5 | r >>> 27) + (o ^ (a = a << 30 | a >>> 2) ^ b) + n + 1859775393 + l[t + 2] << 0) << 5 | n >>> 27) + (r ^ (o = o << 30 | o >>> 2) ^ a) + b + 1859775393 + l[t + 3] << 0) << 5 | b >>> 27) + (n ^ (r = r << 30 | r >>> 2) ^ o) + a + 1859775393 + l[t + 4] << 0, n = n << 30 | n >>> 2;
						for (; t < 60; t += 5) a = (e = (b = (e = (n = (e = (r = (e = (o = (e = a << 5 | a >>> 27) + (b & n | b & r | n & r) + o - 1894007588 + l[t] << 0) << 5 | o >>> 27) + (a & (b = b << 30 | b >>> 2) | a & n | b & n) + r - 1894007588 + l[t + 1] << 0) << 5 | r >>> 27) + (o & (a = a << 30 | a >>> 2) | o & b | a & b) + n - 1894007588 + l[t + 2] << 0) << 5 | n >>> 27) + (r & (o = o << 30 | o >>> 2) | r & a | o & a) + b - 1894007588 + l[t + 3] << 0) << 5 | b >>> 27) + (n & (r = r << 30 | r >>> 2) | n & o | r & o) + a - 1894007588 + l[t + 4] << 0, n = n << 30 | n >>> 2;
						for (; t < 80; t += 5) a = (e = (b = (e = (n = (e = (r = (e = (o = (e = a << 5 | a >>> 27) + (b ^ n ^ r) + o - 899497514 + l[t] << 0) << 5 | o >>> 27) + (a ^ (b = b << 30 | b >>> 2) ^ n) + r - 899497514 + l[t + 1] << 0) << 5 | r >>> 27) + (o ^ (a = a << 30 | a >>> 2) ^ b) + n - 899497514 + l[t + 2] << 0) << 5 | n >>> 27) + (r ^ (o = o << 30 | o >>> 2) ^ a) + b - 899497514 + l[t + 3] << 0) << 5 | b >>> 27) + (n ^ (r = r << 30 | r >>> 2) ^ o) + a - 899497514 + l[t + 4] << 0, n = n << 30 | n >>> 2;
						this.h0 = this.h0 + a << 0, this.h1 = this.h1 + b << 0, this.h2 = this.h2 + n << 0, this.h3 = this.h3 + r << 0, this.h4 = this.h4 + o << 0
					}, Sha1.prototype.hex = function() {
						this.finalize();
						var t = this.h0,
							h1 = this.h1,
							h2 = this.h2,
							h3 = this.h3,
							h4 = this.h4;
						return HEX_CHARS[t >> 28 & 15] + HEX_CHARS[t >> 24 & 15] + HEX_CHARS[t >> 20 & 15] + HEX_CHARS[t >> 16 & 15] + HEX_CHARS[t >> 12 & 15] + HEX_CHARS[t >> 8 & 15] + HEX_CHARS[t >> 4 & 15] + HEX_CHARS[15 & t] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[15 & h1] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[15 & h2] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[15 & h3] + HEX_CHARS[h4 >> 28 & 15] + HEX_CHARS[h4 >> 24 & 15] + HEX_CHARS[h4 >> 20 & 15] + HEX_CHARS[h4 >> 16 & 15] + HEX_CHARS[h4 >> 12 & 15] + HEX_CHARS[h4 >> 8 & 15] + HEX_CHARS[h4 >> 4 & 15] + HEX_CHARS[15 & h4]
					}, Sha1.prototype.toString = Sha1.prototype.hex, Sha1.prototype.digest = function() {
						this.finalize();
						var t = this.h0,
							h1 = this.h1,
							h2 = this.h2,
							h3 = this.h3,
							h4 = this.h4;
						return [t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, h1 >> 24 & 255, h1 >> 16 & 255, h1 >> 8 & 255, 255 & h1, h2 >> 24 & 255, h2 >> 16 & 255, h2 >> 8 & 255, 255 & h2, h3 >> 24 & 255, h3 >> 16 & 255, h3 >> 8 & 255, 255 & h3, h4 >> 24 & 255, h4 >> 16 & 255, h4 >> 8 & 255, 255 & h4]
					}, Sha1.prototype.array = Sha1.prototype.digest, Sha1.prototype.arrayBuffer = function() {
						this.finalize();
						var t = new ArrayBuffer(20),
							e = new DataView(t);
						return e.setUint32(0, this.h0), e.setUint32(4, this.h1), e.setUint32(8, this.h2), e.setUint32(12, this.h3), e.setUint32(16, this.h4), t
					};
					var exports = createMethod();
					COMMON_JS ? module.exports = exports : (root.sha1 = exports, AMD && (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
						return exports
					}.call(exports, __webpack_require__, exports, module), void 0 === __WEBPACK_AMD_DEFINE_RESULT__ || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)))
				})()
			}).call(this, __webpack_require__(159), __webpack_require__(34))
		}
	}
]);
//# sourceMappingURL=a5d960a.js.map